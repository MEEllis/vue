(function (b, a) { typeof exports === "object" && typeof module !== "undefined" ? a(exports) : typeof define === "function" && define.amd ? define(["exports"], a) : (a((b.echarts = {}))) }(this, (function (rA) {
  var v8; if (typeof window !== "undefined") { v8 = window.__DEV__ } else { if (typeof global !== "undefined") { v8 = global.__DEV__ } } if (typeof v8 === "undefined") { v8 = true } var ok = v8; var HB = 2311; var dq = function () { return HB++ }; var hp = {}; if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") { hp = { browser: {}, os: {}, node: false, wxa: true, canvasSupported: true, svgSupported: false, touchEventsSupported: true, domSupported: false } } else { if (typeof document === "undefined" && typeof self !== "undefined") { hp = { browser: {}, os: {}, node: false, worker: true, canvasSupported: true, domSupported: false } } else { if (typeof navigator === "undefined") { hp = { browser: {}, os: {}, node: true, worker: false, canvasSupported: true, svgSupported: true, domSupported: false } } else { hp = k9(navigator.userAgent) } } } var sW = hp; function k9(k) { var Z = {}; var e = {}; var v = k.match(/Firefox\/([\d.]+)/); var v1 = k.match(/MSIE\s([\d.]+)/) || k.match(/Trident\/.+?rv:(([\d.]+))/); var m = k.match(/Edge\/([\d.]+)/); var i = (/micromessenger/i).test(k); if (v) { e.firefox = true; e.version = v[1] } if (v1) { e.ie = true; e.version = v1[1] } if (m) { e.edge = true; e.version = m[1] } if (i) { e.weChat = true } return { browser: e, os: Z, node: false, canvasSupported: !!document.createElement("canvas").getContext, svgSupported: typeof SVGRect !== "undefined", touchEventsSupported: "ontouchstart" in window && !e.ie && !e.edge, pointerEventsSupported: "onpointerdown" in window && (e.edge || (e.ie && e.version >= 11)), domSupported: typeof document !== "undefined" } } var xa = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1 }; var bZ = { "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1 }; var zC = Object.prototype.toString; var c5 = Array.prototype; var r4 = c5.forEach; var l1 = c5.filter; var Gf = c5.slice; var cB = c5.map; var C1 = c5.reduce; var no = {}; function AQ(e, i) { if (e === "createCanvas") { hb = null } no[e] = i } function C5(v2) { if (v2 == null || typeof v2 != "object") { return v2 } var m = v2; var k = zC.call(v2); if (k === "[object Array]") { if (!l9(v2)) { m = []; for (var v1 = 0, e = v2.length; v1 < e; v1++) { m[v1] = C5(v2[v1]) } } } else { if (bZ[k]) { if (!l9(v2)) { var v = v2.constructor; if (v2.constructor.from) { m = v.from(v2) } else { m = new v(v2.length); for (var v1 = 0, e = v2.length; v1 < e; v1++) { m[v1] = C5(v2[v1]) } } } } else { if (!xa[k] && !l9(v2) && !ay(v2)) { m = {}; for (var Z in v2) { if (v2.hasOwnProperty(Z)) { m[Z] = C5(v2[Z]) } } } } } return m } function v4(v, m, i) { if (!tJ(m) || !tJ(v)) { return i ? C5(m) : v } for (var k in m) { if (m.hasOwnProperty(k)) { var e = v[k]; var Z = m[k]; if (tJ(Z) && tJ(e) && !GG(Z) && !GG(e) && !ay(Z) && !ay(e) && !wk(Z) && !wk(e) && !l9(Z) && !l9(e)) { v4(e, Z, i) } else { if (i || !(k in v)) { v[k] = C5(m[k], true) } } } } return v } function aa(Z, m) { var k = Z[0]; for (var v = 1, e = Z.length; v < e; v++) { k = v4(k, Z[v], m) } return k } function b0(k, i) { for (var e in i) { if (i.hasOwnProperty(e)) { k[e] = i[e] } } return k } function De(m, k, e) { for (var i in k) { if (k.hasOwnProperty(i) && (e ? k[i] != null : m[i] == null)) { m[i] = k[i] } } return m } var Dc = function () { return no.createCanvas() }; no.createCanvas = function () { return document.createElement("canvas") }; var hb; function oH() { if (!hb) { hb = Dc().getContext("2d") } return hb } function eP(v, m) { if (v) { if (v.indexOf) { return v.indexOf(m) } for (var k = 0, e = v.length; k < e; k++) { if (v[k] === m) { return k } } } return -1 } function mr(i, e) { var k = i.prototype; function m() { } m.prototype = e.prototype; i.prototype = new m(); for (var v in k) { i.prototype[v] = k[v] } i.prototype.constructor = i; i.superClass = e } function Gq(k, i, e) { k = "prototype" in k ? k.prototype : k; i = "prototype" in i ? i.prototype : i; De(k, i, e) } function sP(e) { if (!e) { return } if (typeof e == "string") { return false } return typeof e.length == "number" } function o9(v1, k, Z) { if (!(v1 && k)) { return } if (v1.forEach && v1.forEach === r4) { v1.forEach(k, Z) } else { if (v1.length === +v1.length) { for (var v = 0, e = v1.length; v < e; v++) { k.call(Z, v1[v], v, v1) } } else { for (var m in v1) { if (v1.hasOwnProperty(m)) { k.call(Z, v1[m], m, v1) } } } } } function Ef(v1, m, Z) { if (!(v1 && m)) { return } if (v1.map && v1.map === cB) { return v1.map(m, Z) } else { var k = []; for (var v = 0, e = v1.length; v < e; v++) { k.push(m.call(Z, v1[v], v, v1)) } return k } } function xc(v1, k, m, Z) { if (!(v1 && k)) { return } if (v1.reduce && v1.reduce === C1) { return v1.reduce(k, m, Z) } else { for (var v = 0, e = v1.length; v < e; v++) { m = k.call(Z, m, v1[v], v, v1) } return m } } function q4(v1, m, Z) { if (!(v1 && m)) { return } if (v1.filter && v1.filter === l1) { return v1.filter(m, Z) } else { var k = []; for (var v = 0, e = v1.length; v < e; v++) { if (m.call(Z, v1[v], v, v1)) { k.push(v1[v]) } } return k } } function rx(Z, k, v) { if (!(Z && k)) { return } for (var m = 0, e = Z.length; m < e; m++) { if (k.call(v, Z[m], m, Z)) { return Z[m] } } } function km(k, i) { var e = Gf.call(arguments, 2); return function () { return k.apply(i, e.concat(Gf.call(arguments))) } } function sv(i) { var e = Gf.call(arguments, 1); return function () { return i.apply(this, e.concat(Gf.call(arguments))) } } function GG(e) {
    return zC.call(e) === "[object Array]"
  } function E5(e) { return typeof e === "function" } function wb(e) { return zC.call(e) === "[object String]" } function tJ(i) { var e = typeof i; return e === "function" || (!!i && e == "object") } function wk(e) { return !!xa[zC.call(e)] } function HU(e) { return !!bZ[zC.call(e)] } function ay(e) { return typeof e === "object" && typeof e.nodeType === "number" && typeof e.ownerDocument === "object" } function lu(e) { return e !== e } function gu(k) { for (var m = 0, e = arguments.length; m < e; m++) { if (arguments[m] != null) { return arguments[m] } } } function kb(i, e) { return i != null ? i : e } function ka(k, i, e) { return k != null ? k : i != null ? i : e } function h7() { return Function.call.apply(Gf, arguments) } function Dv(i) { if (typeof (i) === "number") { return [i, i, i, i] } var e = i.length; if (e === 2) { return [i[0], i[1], i[0], i[1]] } else { if (e === 3) { return [i[0], i[1], i[2], i[1]] } } return i } function bM(i, e) { if (!i) { throw new Error(e) } } function Gs(e) { if (e == null) { return null } else { if (typeof e.trim === "function") { return e.trim() } else { return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") } } } var sj = "__ec_primitive__"; function A(e) { e[sj] = true } function l9(e) { return e[sj] } function pv(k) { var i = GG(k); this.data = {}; var m = this; (k instanceof pv) ? k.each(e) : (k && o9(k, e)); function e(Z, v) { i ? m.set(Z, v) : m.set(v, Z) } } pv.prototype = { constructor: pv, get: function (e) { return this.data.hasOwnProperty(e) ? this.data[e] : null }, set: function (e, i) { return (this.data[e] = i) }, each: function (e, k) { k !== void 0 && (e = km(e, k)); for (var i in this.data) { this.data.hasOwnProperty(i) && e(this.data[i], i) } }, removeKey: function (e) { delete this.data[e] } }; function CJ(e) { return new pv(e) } function ld(m, k) { var e = new m.constructor(m.length + k.length); for (var v = 0; v < m.length; v++) { e[v] = m[v] } var Z = m.length; for (v = 0; v < k.length; v++) { e[v + Z] = k[v] } return e } function V() { } var xh = (Object.freeze || Object)({ $override: AQ, clone: C5, merge: v4, mergeAll: aa, extend: b0, defaults: De, createCanvas: Dc, getContext: oH, indexOf: eP, inherits: mr, mixin: Gq, isArrayLike: sP, each: o9, map: Ef, reduce: xc, filter: q4, find: rx, bind: km, curry: sv, isArray: GG, isFunction: E5, isString: wb, isObject: tJ, isBuiltInObject: wk, isTypedArray: HU, isDom: ay, eqNaN: lu, retrieve: gu, retrieve2: kb, retrieve3: ka, slice: h7, normalizeCssArray: Dv, assert: bM, trim: Gs, setAsPrimitive: A, isPrimitive: l9, createHashMap: CJ, concatArray: ld, noop: V }); var C = typeof Float32Array === "undefined" ? Array : Float32Array; function G7(e, k) { var i = new C(2); if (e == null) { e = 0 } if (k == null) { k = 0 } i[0] = e; i[1] = k; return i } function yI(i, e) { i[0] = e[0]; i[1] = e[1]; return i } function uS(e) { var i = new C(2); i[0] = e[0]; i[1] = e[1]; return i } function GL(k, i, e) { k[0] = i; k[1] = e; return k } function uA(e, k, i) { e[0] = k[0] + i[0]; e[1] = k[1] + i[1]; return e } function A6(i, m, k, e) { i[0] = m[0] + k[0] * e; i[1] = m[1] + k[1] * e; return i } function BN(e, k, i) { e[0] = k[0] - i[0]; e[1] = k[1] - i[1]; return e } function ey(e) { return Math.sqrt(m4(e)) } var m8 = ey; function m4(e) { return e[0] * e[0] + e[1] * e[1] } var bz = m4; function wW(e, k, i) { e[0] = k[0] * i[0]; e[1] = k[1] * i[1]; return e } function uQ(e, k, i) { e[0] = k[0] / i[0]; e[1] = k[1] / i[1]; return e } function st(i, e) { return i[0] * e[0] + i[1] * e[1] } function HG(i, e, k) { i[0] = e[0] * k; i[1] = e[1] * k; return i } function wH(i, e) { var k = ey(e); if (k === 0) { i[0] = 0; i[1] = 0 } else { i[0] = e[0] / k; i[1] = e[1] / k } return i } function z8(i, e) { return Math.sqrt((i[0] - e[0]) * (i[0] - e[0]) + (i[1] - e[1]) * (i[1] - e[1])) } var DV = z8; function EK(i, e) { return (i[0] - e[0]) * (i[0] - e[0]) + (i[1] - e[1]) * (i[1] - e[1]) } var ck = EK; function k1(i, e) { i[0] = -e[0]; i[1] = -e[1]; return i } function rH(e, m, k, i) { e[0] = m[0] + i * (k[0] - m[0]); e[1] = m[1] + i * (k[1] - m[1]); return e } function aY(Z, k, i) { var e = k[0]; var v1 = k[1]; Z[0] = i[0] * e + i[2] * v1 + i[4]; Z[1] = i[1] * e + i[3] * v1 + i[5]; return Z } function Bu(e, k, i) { e[0] = Math.min(k[0], i[0]); e[1] = Math.min(k[1], i[1]); return e } function D5(e, k, i) { e[0] = Math.max(k[0], i[0]); e[1] = Math.max(k[1], i[1]); return e } var EC = (Object.freeze || Object)({ create: G7, copy: yI, clone: uS, set: GL, add: uA, scaleAndAdd: A6, sub: BN, len: ey, length: m8, lenSquare: m4, lengthSquare: bz, mul: wW, div: uQ, dot: st, scale: HG, normalize: wH, distance: z8, dist: DV, distanceSquare: EK, distSquare: ck, negate: k1, lerp: rH, applyTransform: aY, min: Bu, max: D5 }); function ni() { this.on("mousedown", this._dragStart, this); this.on("mousemove", this._drag, this); this.on("mouseup", this._dragEnd, this); this.on("globalout", this._dragEnd, this) } ni.prototype = { constructor: ni, _dragStart: function (k) { var i = k.target; if (i && i.draggable) { this._draggingTarget = i; i.dragging = true; this._x = k.offsetX; this._y = k.offsetY; this.dispatchToElement(kR(i, k), "dragstart", k.event) } }, _drag: function (v1) { var v = this._draggingTarget; if (v) { var i = v1.offsetX; var v3 = v1.offsetY; var m = i - this._x; var k = v3 - this._y; this._x = i; this._y = v3; v.drift(m, k, v1); this.dispatchToElement(kR(v, v1), "drag", v1.event); var v2 = this.findHover(i, v3, v).target; var Z = this._dropTarget; this._dropTarget = v2; if (v !== v2) { if (Z && v2 !== Z) { this.dispatchToElement(kR(Z, v1), "dragleave", v1.event) } if (v2 && v2 !== Z) { this.dispatchToElement(kR(v2, v1), "dragenter", v1.event) } } } }, _dragEnd: function (k) { var i = this._draggingTarget; if (i) { i.dragging = false } this.dispatchToElement(kR(i, k), "dragend", k.event); if (this._dropTarget) { this.dispatchToElement(kR(this._dropTarget, k), "drop", k.event) } this._draggingTarget = null; this._dropTarget = null } }; function kR(k, i) {
    return { target: k, topTarget: i && i.topTarget }
  } var x2 = Array.prototype.slice; var Gc = function (e) { this._$handlers = {}; this._$eventProcessor = e }; Gc.prototype = { constructor: Gc, one: function (v, Z, m, k) { var v1 = this._$handlers; if (typeof Z === "function") { k = m; m = Z; Z = null } if (!m || !v) { return this } Z = Aj(this, Z); if (!v1[v]) { v1[v] = [] } for (var e = 0; e < v1[v].length; e++) { if (v1[v][e].h === m) { return this } } v1[v].push({ h: m, one: true, query: Z, ctx: k || this }); return this }, on: function (v, Z, m, k) { var v1 = this._$handlers; if (typeof Z === "function") { k = m; m = Z; Z = null } if (!m || !v) { return this } Z = Aj(this, Z); if (!v1[v]) { v1[v] = [] } for (var e = 0; e < v1[v].length; e++) { if (v1[v][e].h === m) { return this } } v1[v].push({ h: m, one: false, query: Z, ctx: k || this }); return this }, isSilent: function (e) { var i = this._$handlers; return i[e] && i[e].length }, off: function (Z, v) { var v1 = this._$handlers; if (!Z) { this._$handlers = {}; return this } if (v) { if (v1[Z]) { var m = []; for (var k = 0, e = v1[Z].length; k < e; k++) { if (v1[Z][k].h != v) { m.push(v1[Z][k]) } } v1[Z] = m } if (v1[Z] && v1[Z].length === 0) { delete v1[Z] } } else { delete v1[Z] } return this }, trigger: function (v1) { if (this._$handlers[v1]) { var v = arguments; var m = v.length; var v3 = this._$eventProcessor; if (m > 3) { v = x2.call(v, 1) } var v2 = this._$handlers[v1]; var k = v2.length; for (var Z = 0; Z < k;) { var e = v2[Z]; if (v3 && v3.filter && e.query != null && !v3.filter(v1, e.query)) { Z++; continue } switch (m) { case 1: e.h.call(e.ctx); break; case 2: e.h.call(e.ctx, v[1]); break; case 3: e.h.call(e.ctx, v[1], v[2]); break; default: e.h.apply(e.ctx, v); break }if (e.one) { v2.splice(Z, 1); k-- } else { Z++ } } } return this }, triggerWithContext: function (v3) { if (this._$handlers[v3]) { var v2 = arguments; var v1 = v2.length; var Z = this._$eventProcessor; if (v1 > 4) { v2 = x2.call(v2, 1, v2.length - 1) } var Ij = v2[v2.length - 1]; var k = this._$handlers[v3]; var v = k.length; for (var m = 0; m < v;) { var e = k[m]; if (Z && Z.filter && e.query != null && !Z.filter(v3, e.query)) { m++; continue } switch (v1) { case 1: e.h.call(Ij); break; case 2: e.h.call(Ij, v2[1]); break; case 3: e.h.call(Ij, v2[1], v2[2]); break; default: e.h.apply(Ij, v2); break }if (e.one) { k.splice(m, 1); v-- } else { m++ } } } return this } }; function Aj(e, i) { var k = e._$eventProcessor; if (i != null && k && k.normalizeQuery) { i = k.normalizeQuery(i) } return i } var ci = (typeof window !== "undefined") && !!window.addEventListener; var Ct = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; function hg(e) { return e.getBoundingClientRect ? e.getBoundingClientRect() : { left: 0, top: 0 } } function BV(m, v, i, k) { i = i || {}; if (k || !sW.canvasSupported) { th(m, v, i) } else { if (sW.browser.firefox && v.layerX != null && v.layerX !== v.offsetX) { i.zrX = v.layerX; i.zrY = v.layerY } else { if (v.offsetX != null) { i.zrX = v.offsetX; i.zrY = v.offsetY } else { th(m, v, i) } } } return i } function th(k, v, i) { var m = hg(k); i.zrX = v.clientX - m.left; i.zrY = v.clientY - m.top } function Bc(Z, v1, v) { v1 = v1 || window.event; if (v1.zrX != null) { return v1 } var m = v1.type; var i = m && m.indexOf("touch") >= 0; if (!i) { BV(Z, v1, v1, v); v1.zrDelta = (v1.wheelDelta) ? v1.wheelDelta / 120 : -(v1.detail || 0) / 3 } else { var v2 = m != "touchend" ? v1.targetTouches[0] : v1.changedTouches[0]; v2 && BV(Z, v2, v1, v) } var k = v1.button; if (v1.which == null && k !== undefined && Ct.test(v1.type)) { v1.which = (k & 1 ? 1 : (k & 2 ? 3 : (k & 4 ? 2 : 0))) } return v1 } function fr(k, e, i) { if (ci) { k.addEventListener(e, i) } else { k.attachEvent("on" + e, i) } } function qz(k, e, i) { if (ci) { k.removeEventListener(e, i) } else { k.detachEvent("on" + e, i) } } var GP = ci ? function (i) { i.preventDefault(); i.stopPropagation(); i.cancelBubble = true } : function (i) { i.returnValue = false; i.cancelBubble = true }; function dQ(i) { return i.which > 1 } var Ih = "silent"; function wF(i, k, e) { return { type: i, event: e, target: k.target, topTarget: k.topTarget, cancelBubble: false, offsetX: e.zrX, offsetY: e.zrY, gestureEvent: e.gestureEvent, pinchX: e.pinchX, pinchY: e.pinchY, pinchScale: e.pinchScale, wheelDelta: e.zrDelta, zrByTouch: e.zrByTouch, which: e.which, stop: AB } } function AB(e) { GP(this.event) } function If() { } If.prototype.dispose = function () { }; var rD = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"]; var ev = function (m, e, i, k) { Gc.call(this); this.storage = m; this.painter = e; this.painterRoot = k; i = i || new If(); this.proxy = null; this._hovered = {}; this._lastTouchMoment; this._lastX; this._lastY; ni.call(this); this.setHandlerProxy(i) }; ev.prototype = {
    constructor: ev, setHandlerProxy: function (e) { if (this.proxy) { this.proxy.dispose() } if (e) { o9(rD, function (i) { e.on && e.on(i, this[i], this) }, this); e.handler = this } this.proxy = e }, mousemove: function (v) { var i = v.zrX; var v2 = v.zrY; var v1 = this._hovered; var Z = v1.target; if (Z && !Z.__zr) { v1 = this.findHover(v1.x, v1.y); Z = v1.target } var m = this._hovered = this.findHover(i, v2); var e = m.target; var k = this.proxy; k.setCursor && k.setCursor(e ? e.cursor : "default"); if (Z && e !== Z) { this.dispatchToElement(v1, "mouseout", v) } this.dispatchToElement(m, "mousemove", v); if (e && e !== Z) { this.dispatchToElement(m, "mouseover", v) } }, mouseout: function (k) { this.dispatchToElement(this._hovered, "mouseout", k); var i = k.toElement || k.relatedTarget; var e; do { i = i && i.parentNode } while (i && i.nodeType != 9 && !(e = i === this.painterRoot)); !e && this.trigger("globalout", { event: k }) }, resize: function (e) { this._hovered = {} }, dispatch: function (i, e) { var k = this[i]; k && k.call(this, e) }, dispose: function () { this.proxy.dispose(); this.storage = this.proxy = this.painter = null }, setCursorStyle: function (e) {
      var i = this.proxy;
      i.setCursor && i.setCursor(e)
    }, dispatchToElement: function (Z, e, m) { Z = Z || {}; var k = Z.target; if (k && k.silent) { return } var i = "on" + e; var v = wF(e, Z, m); while (k) { k[i] && (v.cancelBubble = k[i].call(k, v)); k.trigger(e, v); k = k.parent; if (v.cancelBubble) { break } } if (!v.cancelBubble) { this.trigger(e, v); this.painter && this.painter.eachOtherLayer(function (v1) { if (typeof (v1[i]) == "function") { v1[i].call(v1, v) } if (v1.trigger) { v1.trigger(e, v) } }) } }, findHover: function (e, v2, k) { var Z = this.storage.getDisplayList(); var m = { x: e, y: v2 }; for (var v = Z.length - 1; v >= 0; v--) { var v1; if (Z[v] !== k && !Z[v].ignore && (v1 = xX(Z[v], e, v2))) { !m.topTarget && (m.topTarget = Z[v]); if (v1 !== Ih) { m.target = Z[v]; break } } } return m }
  }; o9(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (e) { ev.prototype[e] = function (m) { var k = this.findHover(m.zrX, m.zrY); var i = k.target; if (e === "mousedown") { this._downEl = i; this._downPoint = [m.zrX, m.zrY]; this._upEl = i } else { if (e === "mouseup") { this._upEl = i } else { if (e === "click") { if (this._downEl !== this._upEl || !this._downPoint || DV(this._downPoint, [m.zrX, m.zrY]) > 4) { return } this._downPoint = null } } } this.dispatchToElement(k, e, m) } }); function xX(i, e, v) { if (i[i.rectHover ? "rectContain" : "contain"](e, v)) { var k = i; var m; while (k) { if (k.clipPath && !k.clipPath.contain(e, v)) { return false } if (k.silent) { m = true } k = k.parent } return m ? Ih : true } return false } Gq(ev, Gc); Gq(ev, ni); var C0 = typeof Float32Array === "undefined" ? Array : Float32Array; function CB() { var e = new C0(6); lN(e); return e } function lN(e) { e[0] = 1; e[1] = 0; e[2] = 0; e[3] = 1; e[4] = 0; e[5] = 0; return e } function zt(i, e) { i[0] = e[0]; i[1] = e[1]; i[2] = e[2]; i[3] = e[3]; i[4] = e[4]; i[5] = e[5]; return i } function l(i, v2, Z) { var e = v2[0] * Z[0] + v2[2] * Z[1]; var v3 = v2[1] * Z[0] + v2[3] * Z[1]; var v1 = v2[0] * Z[2] + v2[2] * Z[3]; var v = v2[1] * Z[2] + v2[3] * Z[3]; var m = v2[0] * Z[4] + v2[2] * Z[5] + v2[4]; var k = v2[1] * Z[4] + v2[3] * Z[5] + v2[5]; i[0] = e; i[1] = v3; i[2] = v1; i[3] = v; i[4] = m; i[5] = k; return i } function vm(k, e, i) { k[0] = e[0]; k[1] = e[1]; k[2] = e[2]; k[3] = e[3]; k[4] = e[4] + i[0]; k[5] = e[5] + i[1]; return k } function ki(i, v1, Z) { var e = v1[0]; var Ij = v1[2]; var v = v1[4]; var Ik = v1[1]; var v2 = v1[3]; var k = v1[5]; var v3 = Math.sin(Z); var m = Math.cos(Z); i[0] = e * m + Ik * v3; i[1] = -e * v3 + Ik * m; i[2] = Ij * m + v2 * v3; i[3] = -Ij * v3 + m * v2; i[4] = m * v + v3 * k; i[5] = m * k - v3 * v; return i } function qX(k, e, i) { var Z = i[0]; var m = i[1]; k[0] = e[0] * Z; k[1] = e[1] * m; k[2] = e[2] * Z; k[3] = e[3] * m; k[4] = e[4] * Z; k[5] = e[5] * m; return k } function fG(i, Z) { var e = Z[0]; var v2 = Z[2]; var m = Z[4]; var v3 = Z[1]; var v1 = Z[3]; var k = Z[5]; var v = e * v1 - v3 * v2; if (!v) { return null } v = 1 / v; i[0] = v1 * v; i[1] = -v3 * v; i[2] = -v2 * v; i[3] = e * v; i[4] = (v2 * k - v1 * m) * v; i[5] = (v3 * m - e * k) * v; return i } function uP(i) { var e = CB(); zt(e, i); return e } var kC = (Object.freeze || Object)({ create: CB, identity: lN, copy: zt, mul: l, translate: vm, rotate: ki, scale: qX, invert: fG, clone: uP }); var tA = lN; var nP = 0.00005; function iD(e) { return e > nP || e < -nP } var bJ = function (e) { e = e || {}; if (!e.position) { this.position = [0, 0] } if (e.rotation == null) { this.rotation = 0 } if (!e.scale) { this.scale = [1, 1] } this.origin = this.origin || null }; var jX = bJ.prototype; jX.transform = null; jX.needLocalTransform = function () { return iD(this.rotation) || iD(this.position[0]) || iD(this.position[1]) || iD(this.scale[0] - 1) || iD(this.scale[1] - 1) }; var GK = []; jX.updateTransform = function () { var Ij = this.parent; var e = Ij && Ij.transform; var i = this.needLocalTransform(); var v = this.transform; if (!(i || e)) { v && tA(v); return } v = v || CB(); if (i) { this.getLocalTransform(v) } else { tA(v) } if (e) { if (i) { l(v, Ij.transform, v) } else { zt(v, Ij.transform) } } this.transform = v; var k = this.globalScaleRatio; if (k != null && k !== 1) { this.getGlobalScale(GK); var v3 = GK[0] < 0 ? -1 : 1; var v2 = GK[1] < 0 ? -1 : 1; var v1 = ((GK[0] - v3) * k + v3) / GK[0] || 0; var Z = ((GK[1] - v2) * k + v2) / GK[1] || 0; v[0] *= v1; v[1] *= v1; v[2] *= Z; v[3] *= Z } this.invTransform = this.invTransform || CB(); fG(this.invTransform, v) }; jX.getLocalTransform = function (e) { return bJ.getLocalTransform(this, e) }; jX.setTransform = function (i) { var e = this.transform; var k = i.dpr || 1; if (e) { i.setTransform(k * e[0], k * e[1], k * e[2], k * e[3], k * e[4], k * e[5]) } else { i.setTransform(k, 0, 0, k, 0, 0) } }; jX.restoreTransform = function (e) { var i = e.dpr || 1; e.setTransform(i, 0, 0, i, 0, 0) }; var hC = []; var Eh = CB(); jX.setLocalTransform = function (i) { if (!i) { return } var Z = i[0] * i[0] + i[1] * i[1]; var v = i[2] * i[2] + i[3] * i[3]; var e = this.position; var k = this.scale; if (iD(Z - 1)) { Z = Math.sqrt(Z) } if (iD(v - 1)) { v = Math.sqrt(v) } if (i[0] < 0) { Z = -Z } if (i[3] < 0) { v = -v } e[0] = i[4]; e[1] = i[5]; k[0] = Z; k[1] = v; this.rotation = Math.atan2(-i[1] / v, i[0] / Z) }; jX.decomposeTransform = function () { if (!this.transform) { return } var k = this.parent; var e = this.transform; if (k && k.transform) { l(hC, k.invTransform, e); e = hC } var i = this.origin; if (i && (i[0] || i[1])) { Eh[4] = i[0]; Eh[5] = i[1]; l(hC, e, Eh); hC[4] -= i[0]; hC[5] -= i[1]; e = hC } this.setLocalTransform(e) }; jX.getGlobalScale = function (i) { var e = this.transform; i = i || []; if (!e) { i[0] = 1; i[1] = 1; return i } i[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]); i[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]); if (e[0] < 0) { i[0] = -i[0] } if (e[3] < 0) { i[1] = -i[1] } return i }; jX.transformCoordToLocal = function (e, m) { var k = [e, m]; var i = this.invTransform; if (i) { aY(k, k, i) } return k }; jX.transformCoordToGlobal = function (e, m) { var k = [e, m]; var i = this.transform; if (i) { aY(k, k, i) } return k }; bJ.getLocalTransform = function (v1, i) {
    i = i || [];
    tA(i); var v = v1.origin; var k = v1.scale || [1, 1]; var Z = v1.rotation || 0; var e = v1.position || [0, 0]; if (v) { i[4] -= v[0]; i[5] -= v[1] } qX(i, i, k); if (Z) { ki(i, i, Z) } if (v) { i[4] += v[0]; i[5] += v[1] } i[4] += e[0]; i[5] += e[1]; return i
  }; var e6 = { linear: function (e) { return e }, quadraticIn: function (e) { return e * e }, quadraticOut: function (e) { return e * (2 - e) }, quadraticInOut: function (e) { if ((e *= 2) < 1) { return 0.5 * e * e } return -0.5 * (--e * (e - 2) - 1) }, cubicIn: function (e) { return e * e * e }, cubicOut: function (e) { return --e * e * e + 1 }, cubicInOut: function (e) { if ((e *= 2) < 1) { return 0.5 * e * e * e } return 0.5 * ((e -= 2) * e * e + 2) }, quarticIn: function (e) { return e * e * e * e }, quarticOut: function (e) { return 1 - (--e * e * e * e) }, quarticInOut: function (e) { if ((e *= 2) < 1) { return 0.5 * e * e * e * e } return -0.5 * ((e -= 2) * e * e * e - 2) }, quinticIn: function (e) { return e * e * e * e * e }, quinticOut: function (e) { return --e * e * e * e * e + 1 }, quinticInOut: function (e) { if ((e *= 2) < 1) { return 0.5 * e * e * e * e * e } return 0.5 * ((e -= 2) * e * e * e * e + 2) }, sinusoidalIn: function (e) { return 1 - Math.cos(e * Math.PI / 2) }, sinusoidalOut: function (e) { return Math.sin(e * Math.PI / 2) }, sinusoidalInOut: function (e) { return 0.5 * (1 - Math.cos(Math.PI * e)) }, exponentialIn: function (e) { return e === 0 ? 0 : Math.pow(1024, e - 1) }, exponentialOut: function (e) { return e === 1 ? 1 : 1 - Math.pow(2, -10 * e) }, exponentialInOut: function (e) { if (e === 0) { return 0 } if (e === 1) { return 1 } if ((e *= 2) < 1) { return 0.5 * Math.pow(1024, e - 1) } return 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2) }, circularIn: function (e) { return 1 - Math.sqrt(1 - e * e) }, circularOut: function (e) { return Math.sqrt(1 - (--e * e)) }, circularInOut: function (e) { if ((e *= 2) < 1) { return -0.5 * (Math.sqrt(1 - e * e) - 1) } return 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1) }, elasticIn: function (i) { var m; var e = 0.1; var v = 0.4; if (i === 0) { return 0 } if (i === 1) { return 1 } if (!e || e < 1) { e = 1; m = v / 4 } else { m = v * Math.asin(1 / e) / (2 * Math.PI) } return -(e * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - m) * (2 * Math.PI) / v)) }, elasticOut: function (i) { var m; var e = 0.1; var v = 0.4; if (i === 0) { return 0 } if (i === 1) { return 1 } if (!e || e < 1) { e = 1; m = v / 4 } else { m = v * Math.asin(1 / e) / (2 * Math.PI) } return (e * Math.pow(2, -10 * i) * Math.sin((i - m) * (2 * Math.PI) / v) + 1) }, elasticInOut: function (i) { var m; var e = 0.1; var v = 0.4; if (i === 0) { return 0 } if (i === 1) { return 1 } if (!e || e < 1) { e = 1; m = v / 4 } else { m = v * Math.asin(1 / e) / (2 * Math.PI) } if ((i *= 2) < 1) { return -0.5 * (e * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - m) * (2 * Math.PI) / v)) } return e * Math.pow(2, -10 * (i -= 1)) * Math.sin((i - m) * (2 * Math.PI) / v) * 0.5 + 1 }, backIn: function (e) { var i = 1.70158; return e * e * ((i + 1) * e - i) }, backOut: function (e) { var i = 1.70158; return --e * e * ((i + 1) * e + i) + 1 }, backInOut: function (e) { var i = 1.70158 * 1.525; if ((e *= 2) < 1) { return 0.5 * (e * e * ((i + 1) * e - i)) } return 0.5 * ((e -= 2) * e * ((i + 1) * e + i) + 2) }, bounceIn: function (e) { return 1 - e6.bounceOut(1 - e) }, bounceOut: function (e) { if (e < (1 / 2.75)) { return 7.5625 * e * e } else { if (e < (2 / 2.75)) { return 7.5625 * (e -= (1.5 / 2.75)) * e + 0.75 } else { if (e < (2.5 / 2.75)) { return 7.5625 * (e -= (2.25 / 2.75)) * e + 0.9375 } else { return 7.5625 * (e -= (2.625 / 2.75)) * e + 0.984375 } } } }, bounceInOut: function (e) { if (e < 0.5) { return e6.bounceIn(e * 2) * 0.5 } return e6.bounceOut(e * 2 - 1) * 0.5 + 0.5 } }; function eO(e) { this._target = e.target; this._life = e.life || 1000; this._delay = e.delay || 0; this._initialized = false; this.loop = e.loop == null ? false : e.loop; this.gap = e.gap || 0; this.easing = e.easing || "Linear"; this.onframe = e.onframe; this.ondestroy = e.ondestroy; this.onrestart = e.onrestart; this._pausedTime = 0; this._paused = false } eO.prototype = { constructor: eO, step: function (e, k) { if (!this._initialized) { this._startTime = e + this._delay; this._initialized = true } if (this._paused) { this._pausedTime += k; return } var v = (e - this._startTime - this._pausedTime) / this._life; if (v < 0) { return } v = Math.min(v, 1); var m = this.easing; var i = typeof m == "string" ? e6[m] : m; var Z = typeof i === "function" ? i(v) : v; this.fire("frame", Z); if (v == 1) { if (this.loop) { this.restart(e); return "restart" } this._needsRemove = true; return "destroy" } return null }, restart: function (e) { var i = (e - this._startTime - this._pausedTime) % this._life; this._startTime = e - i + this.gap; this._pausedTime = 0; this._needsRemove = false }, fire: function (i, e) { i = "on" + i; if (this[i]) { this[i](this._target, e) } }, pause: function () { this._paused = true }, resume: function () { this._paused = false } }; var dP = function () { this.head = null; this.tail = null; this._len = 0 }; var kz = dP.prototype; kz.insert = function (i) { var e = new rG(i); this.insertEntry(e); return e }; kz.insertEntry = function (e) { if (!this.head) { this.head = this.tail = e } else { this.tail.next = e; e.prev = this.tail; e.next = null; this.tail = e } this._len++ }; kz.remove = function (k) { var i = k.prev; var e = k.next; if (i) { i.next = e } else { this.head = e } if (e) { e.prev = i } else { this.tail = i } k.next = k.prev = null; this._len-- }; kz.len = function () { return this._len }; kz.clear = function () { this.head = this.tail = null; this._len = 0 }; var rG = function (e) { this.value = e; this.next; this.prev }; var lG = function (e) { this._list = new dP(); this._map = {}; this._maxSize = e || 10; this._lastRemovedEntry = null }; var zW = lG.prototype; zW.put = function (i, v) { var m = this._list; var v2 = this._map; var v1 = null; if (v2[i] == null) { var e = m.len(); var k = this._lastRemovedEntry; if (e >= this._maxSize && e > 0) { var Z = m.head; m.remove(Z); delete v2[Z.key]; v1 = Z.value; this._lastRemovedEntry = Z } if (k) { k.value = v } else { k = new rG(v) } k.key = i; m.insertEntry(k); v2[i] = k } return v1 }; zW.get = function (e) {
    var i = this._map[e]; var k = this._list;
    if (i != null) { if (i !== k.tail) { k.remove(i); k.insertEntry(i) } return i.value }
  }; zW.clear = function () { this._list.clear(); this._map = {} }; var iM = { "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1], "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1], "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1], "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1], "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1], "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1], "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1], "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1], "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1], "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1], "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1], "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1], "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1], "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1], "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1], "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1], "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1], "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1], "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1], "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1], "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1], "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1], "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1], "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1], "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1], "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1], "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1], "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1], "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1], "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1], "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1], "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1], "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1], "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1], "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1], "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1], "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1], "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1], "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1], "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1], "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1], "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1], "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1], "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1], "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1], "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1], "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1], "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1], "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1], "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1], "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1], "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1], "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1], "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1], "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1], "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1], "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1], "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1], "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1], "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1], "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1], "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1], "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1], "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1], "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1], "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1], "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1], "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1], "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1], "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1], "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1], "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1], "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1], "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1] }; function cp(e) { e = Math.round(e); return e < 0 ? 0 : e > 255 ? 255 : e } function mB(e) { e = Math.round(e); return e < 0 ? 0 : e > 360 ? 360 : e } function AJ(e) { return e < 0 ? 0 : e > 1 ? 1 : e } function jj(e) { if (e.length && e.charAt(e.length - 1) === "%") { return cp(parseFloat(e) / 100 * 255) } return cp(parseInt(e, 10)) } function vr(e) { if (e.length && e.charAt(e.length - 1) === "%") { return AJ(parseFloat(e) / 100) } return AJ(parseFloat(e)) } function CM(i, e, k) { if (k < 0) { k += 1 } else { if (k > 1) { k -= 1 } } if (k * 6 < 1) { return i + (e - i) * k * 6 } if (k * 2 < 1) { return e } if (k * 3 < 2) { return i + (e - i) * (2 / 3 - k) * 6 } return i } function zG(i, e, k) { return i + (e - i) * k } function Eg(k, v, m, e, i) { k[0] = v; k[1] = m; k[2] = e; k[3] = i; return k } function eF(i, e) { i[0] = e[0]; i[1] = e[1]; i[2] = e[2]; i[3] = e[3]; return i } var Gm = new lG(20); var hJ = null; function y0(e, i) { if (hJ) { eF(hJ, i) } hJ = Gm.put(e, hJ || (i.slice())) } function eW(v3, e) {
    if (!v3) { return } e = e || []; var k = Gm.get(v3); if (k) { return eF(e, k) } v3 = v3 + ""; var v2 = v3.replace(/ /g, "").toLowerCase();
    if (v2 in iM) { eF(e, iM[v2]); y0(v3, e); return e } if (v2.charAt(0) === "#") { if (v2.length === 4) { var Z = parseInt(v2.substr(1), 16); if (!(Z >= 0 && Z <= 4095)) { Eg(e, 0, 0, 0, 1); return } Eg(e, ((Z & 3840) >> 4) | ((Z & 3840) >> 8), (Z & 240) | ((Z & 240) >> 4), (Z & 15) | ((Z & 15) << 4), 1); y0(v3, e); return e } else { if (v2.length === 7) { var Z = parseInt(v2.substr(1), 16); if (!(Z >= 0 && Z <= 16777215)) { Eg(e, 0, 0, 0, 1); return } Eg(e, (Z & 16711680) >> 16, (Z & 65280) >> 8, Z & 255, 1); y0(v3, e); return e } } return } var v1 = v2.indexOf("("), Ij = v2.indexOf(")"); if (v1 !== -1 && Ij + 1 === v2.length) { var i = v2.substr(0, v1); var v = v2.substr(v1 + 1, Ij - (v1 + 1)).split(","); var m = 1; switch (i) { case "rgba": if (v.length !== 4) { Eg(e, 0, 0, 0, 1); return } m = vr(v.pop()); case "rgb": if (v.length !== 3) { Eg(e, 0, 0, 0, 1); return } Eg(e, jj(v[0]), jj(v[1]), jj(v[2]), m); y0(v3, e); return e; case "hsla": if (v.length !== 4) { Eg(e, 0, 0, 0, 1); return } v[3] = vr(v[3]); ws(v, e); y0(v3, e); return e; case "hsl": if (v.length !== 3) { Eg(e, 0, 0, 0, 1); return } ws(v, e); y0(v3, e); return e; default: return } } Eg(e, 0, 0, 0, 1); return
  } function ws(v1, m) { var Z = (((parseFloat(v1[0]) % 360) + 360) % 360) / 360; var v = vr(v1[1]); var e = vr(v1[2]); var i = e <= 0.5 ? e * (v + 1) : e + v - e * v; var k = e * 2 - i; m = m || []; Eg(m, cp(CM(k, i, Z + 1 / 3) * 255), cp(CM(k, i, Z) * 255), cp(CM(k, i, Z - 1 / 3) * 255), 1); if (v1.length === 4) { m[3] = v1[3] } return m } function BO(v) { if (!v) { return } var v1 = v[0] / 255; var Im = v[1] / 255; var k = v[2] / 255; var v3 = Math.min(v1, Im, k); var In = Math.max(v1, Im, k); var Il = In - v3; var Ij = (In + v3) / 2; var Ik; var Z; if (Il === 0) { Ik = 0; Z = 0 } else { if (Ij < 0.5) { Z = Il / (In + v3) } else { Z = Il / (2 - In - v3) } var v2 = (((In - v1) / 6) + (Il / 2)) / Il; var i = (((In - Im) / 6) + (Il / 2)) / Il; var m = (((In - k) / 6) + (Il / 2)) / Il; if (v1 === In) { Ik = m - i } else { if (Im === In) { Ik = (1 / 3) + v2 - m } else { if (k === In) { Ik = (2 / 3) + i - v2 } } } if (Ik < 0) { Ik += 1 } if (Ik > 1) { Ik -= 1 } } var e = [Ik * 360, Z, Ij]; if (v[3] != null) { e.push(v[3]) } return e } function mU(e, v) { var m = eW(e); if (m) { for (var k = 0; k < 3; k++) { if (v < 0) { m[k] = m[k] * (1 - v) | 0 } else { m[k] = ((255 - m[k]) * v + m[k]) | 0 } if (m[k] > 255) { m[k] = 255 } else { if (e[k] < 0) { m[k] = 0 } } } return wp(m, m.length === 4 ? "rgba" : "rgb") } } function zf(e) { var i = eW(e); if (i) { return ((1 << 24) + (i[0] << 16) + (i[1] << 8) + (+i[2])).toString(16).slice(1) } } function Q(Z, e, m) { if (!(e && e.length) || !(Z >= 0 && Z <= 1)) { return } m = m || []; var v2 = Z * (e.length - 1); var v1 = Math.floor(v2); var k = Math.ceil(v2); var v = e[v1]; var v3 = e[k]; var i = v2 - v1; m[0] = cp(zG(v[0], v3[0], i)); m[1] = cp(zG(v[1], v3[1], i)); m[2] = cp(zG(v[2], v3[2], i)); m[3] = AJ(zG(v[3], v3[3], i)); return m } var EO = Q; function uJ(v1, e, k) { if (!(e && e.length) || !(v1 >= 0 && v1 <= 1)) { return } var v3 = v1 * (e.length - 1); var v2 = Math.floor(v3); var m = Math.ceil(v3); var Z = eW(e[v2]); var Ij = eW(e[m]); var i = v3 - v2; var v = wp([cp(zG(Z[0], Ij[0], i)), cp(zG(Z[1], Ij[1], i)), cp(zG(Z[2], Ij[2], i)), AJ(zG(Z[3], Ij[3], i))], "rgba"); return k ? { color: v, leftIndex: v2, rightIndex: m, value: v3 } : v } var Bn = uJ; function lx(i, m, k, e) { i = eW(i); if (i) { i = BO(i); m != null && (i[0] = mB(m)); k != null && (i[1] = vr(k)); e != null && (i[2] = vr(e)); return wp(ws(i), "rgba") } } function ik(e, i) { e = eW(e); if (e && i != null) { e[3] = AJ(i); return wp(e, "rgba") } } function wp(k, i) { if (!k || !k.length) { return } var e = k[0] + "," + k[1] + "," + k[2]; if (i === "rgba" || i === "hsva" || i === "hsla") { e += "," + k[3] } return i + "(" + e + ")" } var wE = (Object.freeze || Object)({ parse: eW, lift: mU, toHex: zf, fastLerp: Q, fastMapToColor: EO, lerp: uJ, mapToColor: Bn, modifyHSL: lx, modifyAlpha: ik, stringify: wp }); var fT = Array.prototype.slice; function Am(i, e) { return i[e] } function y9(k, e, i) { k[e] = i } function GM(k, i, e) { return (i - k) * e + k } function BG(k, i, e) { return e > 0.5 ? i : k } function dI(Ij, v3, v1, m, v2) { var Z = Ij.length; if (v2 == 1) { for (var v = 0; v < Z; v++) { m[v] = GM(Ij[v], v3[v], v1) } } else { var e = Z && Ij[0].length; for (var v = 0; v < Z; v++) { for (var k = 0; k < e; k++) { m[v][k] = GM(Ij[v][k], v3[v][k], v1) } } } } function eT(v3, v1, Z) { var v2 = v3.length; var v = v1.length; if (v2 !== v) { var Ij = v2 > v; if (Ij) { v3.length = v } else { for (var m = v2; m < v; m++) { v3.push(Z === 1 ? v1[m] : fT.call(v1[m])) } } } var e = v3[0] && v3[0].length; for (var m = 0; m < v3.length; m++) { if (Z === 1) { if (isNaN(v3[m])) { v3[m] = v1[m] } } else { for (var k = 0; k < e; k++) { if (isNaN(v3[m][k])) { v3[m][k] = v1[m][k] } } } } } function el(v1, v, v2) { if (v1 === v) { return true } var e = v1.length; if (e !== v.length) { return false } if (v2 === 1) { for (var Z = 0; Z < e; Z++) { if (v1[Z] !== v[Z]) { return false } } } else { var k = v1[0].length; for (var Z = 0; Z < e; Z++) { for (var m = 0; m < k; m++) { if (v1[Z][m] !== v[Z][m]) { return false } } } } return true } function w9(Im, Il, Ik, Ij, In, v1, Z, m, v3) { var v2 = Im.length; if (v3 == 1) { for (var v = 0; v < v2; v++) { m[v] = kj(Im[v], Il[v], Ik[v], Ij[v], In, v1, Z) } } else { var e = Im[0].length; for (var v = 0; v < v2; v++) { for (var k = 0; k < e; k++) { m[v][k] = kj(Im[v][k], Il[v][k], Ik[v][k], Ij[v][k], In, v1, Z) } } } } function kj(v2, v1, v, m, v3, i, e) { var Z = (v - v2) * 0.5; var k = (m - v1) * 0.5; return (2 * (v1 - v) + Z + k) * e + (-3 * (v1 - v) - 2 * Z - k) * i + Z * v3 + v1 } function pK(v) { if (sP(v)) { var e = v.length; if (sP(v[0])) { var k = []; for (var m = 0; m < e; m++) { k.push(fT.call(v[m])) } return k } return fT.call(v) } return v } function nW(e) { e[0] = Math.floor(e[0]); e[1] = Math.floor(e[1]); e[2] = Math.floor(e[2]); return "rgba(" + e.join(",") + ")" } function aV(i) { var e = i[i.length - 1].value; return sP(e && e[0]) ? 2 : 1 } function sQ(IJ, Iv, Ir, It, Is, IG) {
    var Io = IJ._getter; var IH = IJ._setter; var ID = Iv === "spline"; var k = It.length; if (!k) { return } var Iy = It[0].value; var IA = sP(Iy); var v3 = false; var Z = false; var Ik = IA ? aV(It) : 0; var Ip; It.sort(function (IK, i) {
      return IK.time - i.time
    }); Ip = It[k - 1].time; var IC = []; var II = []; var Iz = It[0].value; var Iu = true; for (var IB = 0; IB < k; IB++) { IC.push(It[IB].time / Ip); var Ix = It[IB].value; if (!((IA && el(Ix, Iz, Ik)) || (!IA && Ix === Iz))) { Iu = false } Iz = Ix; if (typeof Ix == "string") { var In = eW(Ix); if (In) { Ix = In; v3 = true } else { Z = true } } II.push(Ix) } if (!IG && Iu) { return } var Ij = II[k - 1]; for (var IB = 0; IB < k - 1; IB++) { if (IA) { eT(II[IB], Ij, Ik) } else { if (isNaN(II[IB]) && !isNaN(Ij) && !Z && !v3) { II[IB] = Ij } } } IA && eT(Io(IJ._target, Is), Ij, Ik); var e = 0; var Iw = 0; var Il; var Iq; var v2; var v1; var v; var m; if (v3) { var Im = [0, 0, 0, 0] } var IF = function (IM, IK) { var IN; if (IK < 0) { IN = 0 } else { if (IK < Iw) { Il = Math.min(e + 1, k - 1); for (IN = Il; IN >= 0; IN--) { if (IC[IN] <= IK) { break } } IN = Math.min(IN, k - 2) } else { for (IN = e; IN < k; IN++) { if (IC[IN] > IK) { break } } IN = Math.min(IN - 1, k - 2) } } e = IN; Iw = IK; var i = (IC[IN + 1] - IC[IN]); if (i === 0) { return } else { Iq = (IK - IC[IN]) / i } if (ID) { v1 = II[IN]; v2 = II[IN === 0 ? IN : IN - 1]; v = II[IN > k - 2 ? k - 1 : IN + 1]; m = II[IN > k - 3 ? k - 1 : IN + 2]; if (IA) { w9(v2, v1, v, m, Iq, Iq * Iq, Iq * Iq * Iq, Io(IM, Is), Ik) } else { var IL; if (v3) { IL = w9(v2, v1, v, m, Iq, Iq * Iq, Iq * Iq * Iq, Im, 1); IL = nW(Im) } else { if (Z) { return BG(v1, v, Iq) } else { IL = kj(v2, v1, v, m, Iq, Iq * Iq, Iq * Iq * Iq) } } IH(IM, Is, IL) } } else { if (IA) { dI(II[IN], II[IN + 1], Iq, Io(IM, Is), Ik) } else { var IL; if (v3) { dI(II[IN], II[IN + 1], Iq, Im, 1); IL = nW(Im) } else { if (Z) { return BG(II[IN], II[IN + 1], Iq) } else { IL = GM(II[IN], II[IN + 1], Iq) } } IH(IM, Is, IL) } } }; var IE = new eO({ target: IJ._target, life: Ip, loop: IJ._loop, delay: IJ._delay, onframe: IF, ondestroy: Ir }); if (Iv && Iv !== "spline") { IE.easing = Iv } return IE
  } var gN = function (k, i, e, m) { this._tracks = {}; this._target = k; this._loop = i || false; this._getter = e || Am; this._setter = m || y9; this._clipCount = 0; this._delay = 0; this._doneList = []; this._onframeList = []; this._clipList = [] }; gN.prototype = { when: function (v, i) { var e = this._tracks; for (var m in i) { if (!i.hasOwnProperty(m)) { continue } if (!e[m]) { e[m] = []; var k = this._getter(this._target, m); if (k == null) { continue } if (v !== 0) { e[m].push({ time: 0, value: pK(k) }) } } e[m].push({ time: v, value: i[m] }) } return this }, during: function (e) { this._onframeList.push(e); return this }, pause: function () { for (var e = 0; e < this._clipList.length; e++) { this._clipList[e].pause() } this._paused = true }, resume: function () { for (var e = 0; e < this._clipList.length; e++) { this._clipList[e].resume() } this._paused = false }, isPaused: function () { return !!this._paused }, _doneCallback: function () { this._tracks = {}; this._clipList.length = 0; var m = this._doneList; var e = m.length; for (var k = 0; k < e; k++) { m[k].call(this) } }, start: function (v1, Z) { var v2 = this; var i = 0; var k = function () { i--; if (!i) { v2._doneCallback() } }; var e; for (var v in this._tracks) { if (!this._tracks.hasOwnProperty(v)) { continue } var m = sQ(this, v1, k, this._tracks[v], v, Z); if (m) { this._clipList.push(m); i++; if (this.animation) { this.animation.addClip(m) } e = m } } if (e) { var v3 = e.onframe; e.onframe = function (Il, Ik) { v3(Il, Ik); for (var Ij = 0; Ij < v2._onframeList.length; Ij++) { v2._onframeList[Ij](Il, Ik) } } } if (!i) { this._doneCallback() } return this }, stop: function (e) { var m = this._clipList; var Z = this.animation; for (var k = 0; k < m.length; k++) { var v = m[k]; if (e) { v.onframe(this._target, 1) } Z && Z.removeClip(v) } m.length = 0 }, delay: function (e) { this._delay = e; return this }, done: function (e) { if (e) { this._doneList.push(e) } return this }, getClips: function () { return this._clipList } }; var r6 = 1; if (typeof window !== "undefined") { r6 = Math.max(window.devicePixelRatio || 1, 1) } var ry = 0; var h3 = r6; var aU = function () { }; if (ry === 1) { aU = function () { for (var e in arguments) { throw new Error(arguments[e]) } } } else { if (ry > 1) { aU = function () { for (var e in arguments) { console.log(arguments[e]) } } } } var Gu = aU; var uy = function () { this.animators = [] }; uy.prototype = { constructor: uy, animate: function (Im, v2) { var v3; var Il = false; var k = this; var Ij = this.__zr; if (Im) { var Ik = Im.split("."); var e = k; Il = Ik[0] === "shape"; for (var v1 = 0, v = Ik.length; v1 < v; v1++) { if (!e) { continue } e = e[Ik[v1]] } if (e) { v3 = e } } else { v3 = k } if (!v3) { Gu('Property "' + Im + '" is not existed in element ' + k.id); return } var Z = k.animators; var m = new gN(v3, v2); m.during(function (i) { k.dirty(Il) }).done(function () { Z.splice(eP(Z, m), 1) }); Z.push(m); if (Ij) { Ij.animation.addAnimator(m) } return m }, stopAnimation: function (k) { var v = this.animators; var e = v.length; for (var m = 0; m < e; m++) { v[m].stop(k) } v.length = 0; return this }, animateTo: function (m, k, e, Z, v, i) { wL(this, m, k, e, Z, v, i) }, animateFrom: function (m, k, e, Z, v, i) { wL(this, m, k, e, Z, v, i, true) } }; function wL(v2, Ij, e, Z, Il, Im, v1, Ik) { if (wb(Z)) { Im = Il; Il = Z; Z = 0 } else { if (E5(Il)) { Im = Il; Il = "linear"; Z = 0 } else { if (E5(Z)) { Im = Z; Z = 0 } else { if (E5(e)) { Im = e; e = 500 } else { if (!e) { e = 500 } } } } } v2.stopAnimation(); i0(v2, "", v2, Ij, e, Z, Ik); var m = v2.animators.slice(); var v3 = m.length; function k() { v3--; if (!v3) { Im && Im() } } if (!v3) { Im && Im() } for (var v = 0; v < m.length; v++) { m[v].done(k).start(Il, v1) } } function i0(v1, Ij, e, v2, v, Z, v3) { var m = {}; var k = 0; for (var i in v2) { if (!v2.hasOwnProperty(i)) { continue } if (e[i] != null) { if (tJ(v2[i]) && !sP(v2[i])) { i0(v1, Ij ? Ij + "." + i : i, e[i], v2[i], v, Z, v3) } else { if (v3) { m[i] = e[i]; a9(v1, Ij, i, v2[i]) } else { m[i] = v2[i] } k++ } } else { if (v2[i] != null && !v3) { a9(v1, Ij, i, v2[i]) } } } if (k > 0) { v1.animate(Ij, false).when(v == null ? 500 : v, m).delay(Z || 0) } } function a9(k, v, e, m) { if (!v) { k.attr(e, m) } else { var i = {}; i[v] = {}; i[v][e] = m; k.attr(i) } } var s0 = function (e) {
    bJ.call(this, e);
    Gc.call(this, e); uy.call(this, e); this.id = e.id || dq()
  }; s0.prototype = { type: "element", name: "", __zr: null, ignore: false, clipPath: null, isGroup: false, drift: function (k, i) { switch (this.draggable) { case "horizontal": i = 0; break; case "vertical": k = 0; break }var e = this.transform; if (!e) { e = this.transform = [1, 0, 0, 1, 0, 0] } e[4] += k; e[5] += i; this.decomposeTransform(); this.dirty(false) }, beforeUpdate: function () { }, afterUpdate: function () { }, update: function () { this.updateTransform() }, traverse: function (e, i) { }, attrKV: function (e, i) { if (e === "position" || e === "scale" || e === "origin") { if (i) { var k = this[e]; if (!k) { k = this[e] = [] } k[0] = i[0]; k[1] = i[1] } } else { this[e] = i } }, hide: function () { this.ignore = true; this.__zr && this.__zr.refresh() }, show: function () { this.ignore = false; this.__zr && this.__zr.refresh() }, attr: function (i, k) { if (typeof i === "string") { this.attrKV(i, k) } else { if (tJ(i)) { for (var e in i) { if (i.hasOwnProperty(e)) { this.attrKV(e, i[e]) } } } } this.dirty(false); return this }, setClipPath: function (e) { var i = this.__zr; if (i) { e.addSelfToZr(i) } if (this.clipPath && this.clipPath !== e) { this.removeClipPath() } this.clipPath = e; e.__zr = i; e.__clipTarget = this; this.dirty(false) }, removeClipPath: function () { var e = this.clipPath; if (e) { if (e.__zr) { e.removeSelfFromZr(e.__zr) } e.__zr = null; e.__clipTarget = null; this.clipPath = null; this.dirty(false) } }, addSelfToZr: function (m) { this.__zr = m; var k = this.animators; if (k) { for (var e = 0; e < k.length; e++) { m.animation.addAnimator(k[e]) } } if (this.clipPath) { this.clipPath.addSelfToZr(m) } }, removeSelfFromZr: function (m) { this.__zr = null; var k = this.animators; if (k) { for (var e = 0; e < k.length; e++) { m.animation.removeAnimator(k[e]) } } if (this.clipPath) { this.clipPath.removeSelfFromZr(m) } } }; Gq(s0, uy); Gq(s0, bJ); Gq(s0, Gc); var G8 = aY; var w0 = Math.min; var z1 = Math.max; function CH(i, m, k, e) { if (k < 0) { i = i + k; k = -k } if (e < 0) { m = m + e; e = -e } this.x = i; this.y = m; this.width = k; this.height = e } CH.prototype = { constructor: CH, union: function (i) { var e = w0(i.x, this.x); var k = w0(i.y, this.y); this.width = z1(i.x + i.width, this.x + this.width) - e; this.height = z1(i.y + i.height, this.y + this.height) - k; this.x = e; this.y = k }, applyTransform: (function () { var e = []; var m = []; var k = []; var i = []; return function (v) { if (!v) { return } e[0] = k[0] = this.x; e[1] = i[1] = this.y; m[0] = i[0] = this.x + this.width; m[1] = k[1] = this.y + this.height; G8(e, e, v); G8(m, m, v); G8(k, k, v); G8(i, i, v); this.x = w0(e[0], m[0], k[0], i[0]); this.y = w0(e[1], m[1], k[1], i[1]); var v1 = z1(e[0], m[0], k[0], i[0]); var Z = z1(e[1], m[1], k[1], i[1]); this.width = v1 - this.x; this.height = Z - this.y } })(), calculateTransform: function (i) { var k = this; var Z = i.width / k.width; var v = i.height / k.height; var e = CB(); vm(e, e, [-k.x, -k.y]); qX(e, e, [Z, v]); vm(e, e, [i.x, i.y]); return e }, intersect: function (v1) { if (!v1) { return false } if (!(v1 instanceof CH)) { v1 = CH.create(v1) } var v2 = this; var m = v2.x; var k = v2.x + v2.width; var Ij = v2.y; var v3 = v2.y + v2.height; var Z = v1.x; var v = v1.x + v1.width; var i = v1.y; var e = v1.y + v1.height; return !(k < Z || v < m || v3 < i || e < Ij) }, contain: function (e, k) { var i = this; return e >= i.x && e <= (i.x + i.width) && k >= i.y && k <= (i.y + i.height) }, clone: function () { return new CH(this.x, this.y, this.width, this.height) }, copy: function (e) { this.x = e.x; this.y = e.y; this.width = e.width; this.height = e.height }, plain: function () { return { x: this.x, y: this.y, width: this.width, height: this.height } } }; CH.create = function (e) { return new CH(e.x, e.y, e.width, e.height) }; var B8 = function (i) { i = i || {}; s0.call(this, i); for (var e in i) { if (i.hasOwnProperty(e)) { this[e] = i[e] } } this._children = []; this.__storage = null; this.__dirty = true }; B8.prototype = {
    constructor: B8, isGroup: true, type: "group", silent: false, children: function () { return this._children.slice() }, childAt: function (e) { return this._children[e] }, childOfName: function (e) { var m = this._children; for (var k = 0; k < m.length; k++) { if (m[k].name === e) { return m[k] } } }, childCount: function () { return this._children.length }, add: function (e) { if (e && e !== this && e.parent !== this) { this._children.push(e); this._doAdd(e) } return this }, addBefore: function (m, k) { if (m && m !== this && m.parent !== this && k && k.parent === this) { var i = this._children; var e = i.indexOf(k); if (e >= 0) { i.splice(e, 0, m); this._doAdd(m) } } return this }, _doAdd: function (k) { if (k.parent) { k.parent.remove(k) } k.parent = this; var i = this.__storage; var e = this.__zr; if (i && i !== k.__storage) { i.addToStorage(k); if (k instanceof B8) { k.addChildrenToStorage(i) } } e && e.refresh() }, remove: function (v) { var k = this.__zr; var m = this.__storage; var i = this._children; var e = eP(i, v); if (e < 0) { return this } i.splice(e, 1); v.parent = null; if (m) { m.delFromStorage(v); if (v instanceof B8) { v.delChildrenFromStorage(m) } } k && k.refresh(); return this }, removeAll: function () { var k = this._children; var v = this.__storage; var m; var e; for (e = 0; e < k.length; e++) { m = k[e]; if (v) { v.delFromStorage(m); if (m instanceof B8) { m.delChildrenFromStorage(v) } } m.parent = null } k.length = 0; return this }, eachChild: function (e, v) { var m = this._children; for (var k = 0; k < m.length; k++) { var Z = m[k]; e.call(v, Z, k) } return this }, traverse: function (e, m) { for (var k = 0; k < this._children.length; k++) { var v = this._children[k]; e.call(m, v); if (v.type === "group") { v.traverse(e, m) } } return this }, addChildrenToStorage: function (m) {
      for (var e = 0; e < this._children.length; e++) {
        var k = this._children[e]; m.addToStorage(k); if (k instanceof B8) {
          k.addChildrenToStorage(m)
        }
      }
    }, delChildrenFromStorage: function (m) { for (var e = 0; e < this._children.length; e++) { var k = this._children[e]; m.delFromStorage(k); if (k instanceof B8) { k.delChildrenFromStorage(m) } } }, dirty: function () { this.__dirty = true; this.__zr && this.__zr.refresh(); return this }, getBoundingRect: function (v) { var v2 = null; var v3 = new CH(0, 0, 0, 0); var k = v || this._children; var Ij = []; for (var Z = 0; Z < k.length; Z++) { var e = k[Z]; if (e.ignore || e.invisible) { continue } var v1 = e.getBoundingRect(); var m = e.getLocalTransform(Ij); if (m) { v3.copy(v1); v3.applyTransform(m); v2 = v2 || v3.clone(); v2.union(v3) } else { v2 = v2 || v1.clone(); v2.union(v1) } } return v2 || v3 }
  }; mr(B8, s0); var hm = 32; var xx = 7; function tO(i) { var e = 0; while (i >= hm) { e |= i & 1; i >>= 1 } return i + e } function aK(v, i, e, k) { var m = i + 1; if (m === e) { return 1 } if (k(v[m++], v[i]) < 0) { while (m < e && k(v[m], v[m - 1]) < 0) { m++ } h6(v, i, m) } else { while (m < e && k(v[m], v[m - 1]) >= 0) { m++ } } return m - i } function h6(m, k, e) { e--; while (k < e) { var i = m[k]; m[k++] = m[e]; m[e--] = i } } function yK(Z, v1, v, e, i) { if (e === v1) { e++ } for (; e < v; e++) { var Ij = Z[e]; var m = v1; var v3 = e; var v2; while (m < v3) { v2 = m + v3 >>> 1; if (i(Ij, Z[v2]) < 0) { v3 = v2 } else { m = v2 + 1 } } var k = e - m; switch (k) { case 3: Z[m + 3] = Z[m + 2]; case 2: Z[m + 2] = Z[m + 1]; case 1: Z[m + 1] = Z[m]; break; default: while (k > 0) { Z[m + k] = Z[m + k - 1]; k-- } }Z[m] = Ij } } function wo(Il, Ik, i, v, v3, k) { var e = 0; var v1 = 0; var v2 = 1; if (k(Il, Ik[i + v3]) > 0) { v1 = v - v3; while (v2 < v1 && k(Il, Ik[i + v3 + v2]) > 0) { e = v2; v2 = (v2 << 1) + 1; if (v2 <= 0) { v2 = v1 } } if (v2 > v1) { v2 = v1 } e += v3; v2 += v3 } else { v1 = v3 + 1; while (v2 < v1 && k(Il, Ik[i + v3 - v2]) <= 0) { e = v2; v2 = (v2 << 1) + 1; if (v2 <= 0) { v2 = v1 } } if (v2 > v1) { v2 = v1 } var Ij = e; e = v3 - v2; v2 = v3 - Ij } e++; while (e < v2) { var Z = e + (v2 - e >>> 1); if (k(Il, Ik[i + Z]) > 0) { e = Z + 1 } else { v2 = Z } } return v2 } function Cs(Il, Ik, i, v, v3, k) { var e = 0; var v1 = 0; var v2 = 1; if (k(Il, Ik[i + v3]) < 0) { v1 = v3 + 1; while (v2 < v1 && k(Il, Ik[i + v3 - v2]) < 0) { e = v2; v2 = (v2 << 1) + 1; if (v2 <= 0) { v2 = v1 } } if (v2 > v1) { v2 = v1 } var Ij = e; e = v3 - v2; v2 = v3 - Ij } else { v1 = v - v3; while (v2 < v1 && k(Il, Ik[i + v3 + v2]) >= 0) { e = v2; v2 = (v2 << 1) + 1; if (v2 <= 0) { v2 = v1 } } if (v2 > v1) { v2 = v1 } e += v3; v2 += v3 } e++; while (e < v2) { var Z = e + (v2 - e >>> 1); if (k(Il, Ik[i + Z]) < 0) { v2 = Z } else { e = Z + 1 } } return v2 } function xG(v1, e) { var Im = xx; var v3; var k; var Il = 0; var v = []; v3 = []; k = []; function Ij(Io, In) { v3[Il] = Io; k[Il] = In; Il += 1 } function m() { while (Il > 1) { var In = Il - 2; if (In >= 1 && k[In - 1] <= k[In] + k[In + 1] || In >= 2 && k[In - 2] <= k[In] + k[In - 1]) { if (k[In - 1] < k[In + 1]) { In-- } } else { if (k[In] > k[In + 1]) { break } } v2(In) } } function Ik() { while (Il > 1) { var In = Il - 2; if (In > 0 && k[In - 1] < k[In + 1]) { In-- } v2(In) } } function v2(Io) { var Iq = v3[Io]; var Is = k[Io]; var Ip = v3[Io + 1]; var Ir = k[Io + 1]; k[Io] = Is + Ir; if (Io === Il - 3) { v3[Io + 1] = v3[Io + 2]; k[Io + 1] = k[Io + 2] } Il--; var In = Cs(v1[Ip], v1, Iq, Is, 0, e); Iq += In; Is -= In; if (Is === 0) { return } Ir = wo(v1[Iq + Is - 1], v1, Ip, Ir, Ir - 1, e); if (Ir === 0) { return } if (Is <= Ir) { Z(Iq, Is, Ip, Ir) } else { i(Iq, Is, Ip, Ir) } } function Z(Is, Ir, Ip, Io) { var Iu = 0; for (Iu = 0; Iu < Ir; Iu++) { v[Iu] = v1[Is + Iu] } var In = 0; var Iy = Ip; var Ix = Is; v1[Ix++] = v1[Iy++]; if (--Io === 0) { for (Iu = 0; Iu < Ir; Iu++) { v1[Ix + Iu] = v[In + Iu] } return } if (Ir === 1) { for (Iu = 0; Iu < Io; Iu++) { v1[Ix + Iu] = v1[Iy + Iu] } v1[Ix + Io] = v[In]; return } var It = Im; var Iw, Iv, Iq; while (1) { Iw = 0; Iv = 0; Iq = false; do { if (e(v1[Iy], v[In]) < 0) { v1[Ix++] = v1[Iy++]; Iv++; Iw = 0; if (--Io === 0) { Iq = true; break } } else { v1[Ix++] = v[In++]; Iw++; Iv = 0; if (--Ir === 1) { Iq = true; break } } } while ((Iw | Iv) < It); if (Iq) { break } do { Iw = Cs(v1[Iy], v, In, Ir, 0, e); if (Iw !== 0) { for (Iu = 0; Iu < Iw; Iu++) { v1[Ix + Iu] = v[In + Iu] } Ix += Iw; In += Iw; Ir -= Iw; if (Ir <= 1) { Iq = true; break } } v1[Ix++] = v1[Iy++]; if (--Io === 0) { Iq = true; break } Iv = wo(v[In], v1, Iy, Io, 0, e); if (Iv !== 0) { for (Iu = 0; Iu < Iv; Iu++) { v1[Ix + Iu] = v1[Iy + Iu] } Ix += Iv; Iy += Iv; Io -= Iv; if (Io === 0) { Iq = true; break } } v1[Ix++] = v[In++]; if (--Ir === 1) { Iq = true; break } It-- } while (Iw >= xx || Iv >= xx); if (Iq) { break } if (It < 0) { It = 0 } It += 2 } Im = It; Im < 1 && (Im = 1); if (Ir === 1) { for (Iu = 0; Iu < Io; Iu++) { v1[Ix + Iu] = v1[Iy + Iu] } v1[Ix + Io] = v[In] } else { if (Ir === 0) { throw new Error() } else { for (Iu = 0; Iu < Ir; Iu++) { v1[Ix + Iu] = v[In + Iu] } } } } function i(Is, Ir, Ip, Io) { var Iv = 0; for (Iv = 0; Iv < Io; Iv++) { v[Iv] = v1[Ip + Iv] } var In = Is + Ir - 1; var IA = Io - 1; var Iz = Ip + Io - 1; var Iw = 0; var Iu = 0; v1[Iz--] = v1[In--]; if (--Ir === 0) { Iw = Iz - (Io - 1); for (Iv = 0; Iv < Io; Iv++) { v1[Iw + Iv] = v[Iv] } return } if (Io === 1) { Iz -= Ir; In -= Ir; Iu = Iz + 1; Iw = In + 1; for (Iv = Ir - 1; Iv >= 0; Iv--) { v1[Iu + Iv] = v1[Iw + Iv] } v1[Iz] = v[IA]; return } var It = Im; while (true) { var Iy = 0; var Ix = 0; var Iq = false; do { if (e(v[IA], v1[In]) < 0) { v1[Iz--] = v1[In--]; Iy++; Ix = 0; if (--Ir === 0) { Iq = true; break } } else { v1[Iz--] = v[IA--]; Ix++; Iy = 0; if (--Io === 1) { Iq = true; break } } } while ((Iy | Ix) < It); if (Iq) { break } do { Iy = Ir - Cs(v[IA], v1, Is, Ir, Ir - 1, e); if (Iy !== 0) { Iz -= Iy; In -= Iy; Ir -= Iy; Iu = Iz + 1; Iw = In + 1; for (Iv = Iy - 1; Iv >= 0; Iv--) { v1[Iu + Iv] = v1[Iw + Iv] } if (Ir === 0) { Iq = true; break } } v1[Iz--] = v[IA--]; if (--Io === 1) { Iq = true; break } Ix = Io - wo(v1[In], v, 0, Io, Io - 1, e); if (Ix !== 0) { Iz -= Ix; IA -= Ix; Io -= Ix; Iu = Iz + 1; Iw = IA + 1; for (Iv = 0; Iv < Ix; Iv++) { v1[Iu + Iv] = v[Iw + Iv] } if (Io <= 1) { Iq = true; break } } v1[Iz--] = v1[In--]; if (--Ir === 0) { Iq = true; break } It-- } while (Iy >= xx || Ix >= xx); if (Iq) { break } if (It < 0) { It = 0 } It += 2 } Im = It; if (Im < 1) { Im = 1 } if (Io === 1) { Iz -= Ir; In -= Ir; Iu = Iz + 1; Iw = In + 1; for (Iv = Ir - 1; Iv >= 0; Iv--) { v1[Iu + Iv] = v1[Iw + Iv] } v1[Iz] = v[IA] } else { if (Io === 0) { throw new Error() } else { Iw = Iz - (Io - 1); for (Iv = 0; Iv < Io; Iv++) { v1[Iw + Iv] = v[Iv] } } } } this.mergeRuns = m; this.forceMergeRuns = Ik; this.pushRun = Ij } function qu(Z, i, v1, k) {
    if (!v1) { v1 = 0 } if (!k) {
      k = Z.length
    } var v = k - v1; if (v < 2) { return } var m = 0; if (v < hm) { m = aK(Z, v1, k, i); yK(Z, v1, k, v1 + m, i); return } var v2 = new xG(Z, i); var v3 = tO(v); do { m = aK(Z, v1, k, i); if (m < v3) { var e = v; if (e > v3) { e = v3 } yK(Z, v1, v1 + e, v1 + m, i); m = e } v2.pushRun(v1, m); v2.mergeRuns(); v -= m; v1 += m } while (v !== 0); v2.forceMergeRuns()
  } function Er(i, e) { if (i.zlevel === e.zlevel) { if (i.z === e.z) { return i.z2 - e.z2 } return i.z - e.z } return i.zlevel - e.zlevel } var dv = function () { this._roots = []; this._displayList = []; this._displayListLen = 0 }; dv.prototype = { constructor: dv, traverse: function (e, m) { for (var k = 0; k < this._roots.length; k++) { this._roots[k].traverse(e, m) } }, getDisplayList: function (i, e) { e = e || false; if (i) { this.updateDisplayList(e) } return this._displayList }, updateDisplayList: function (m) { this._displayListLen = 0; var k = this._roots; var Z = this._displayList; for (var v = 0, e = k.length; v < e; v++) { this._updateAndAddDisplayable(k[v], null, m) } Z.length = this._displayListLen; sW.canvasSupported && qu(Z, Er) }, _updateAndAddDisplayable: function (k, v2, Z) { if (k.ignore && !Z) { return } k.beforeUpdate(); if (k.__dirty) { k.update() } k.afterUpdate(); var v3 = k.clipPath; if (v3) { if (v2) { v2 = v2.slice() } else { v2 = [] } var v1 = v3; var Ij = k; while (v1) { v1.parent = Ij; v1.updateTransform(); v2.push(v1); Ij = v1; v1 = v1.clipPath } } if (k.isGroup) { var m = k._children; for (var v = 0; v < m.length; v++) { var e = m[v]; if (k.__dirty) { e.__dirty = true } this._updateAndAddDisplayable(e, v2, Z) } k.__dirty = false } else { k.__clipPaths = v2; this._displayList[this._displayListLen++] = k } }, addRoot: function (e) { if (e.__storage === this) { return } if (e instanceof B8) { e.addChildrenToStorage(this) } this.addToStorage(e); this._roots.push(e) }, delRoot: function (Z) { if (Z == null) { for (var v = 0; v < this._roots.length; v++) { var m = this._roots[v]; if (m instanceof B8) { m.delChildrenFromStorage(this) } } this._roots = []; this._displayList = []; this._displayListLen = 0; return } if (Z instanceof Array) { for (var v = 0, k = Z.length; v < k; v++) { this.delRoot(Z[v]) } return } var e = eP(this._roots, Z); if (e >= 0) { this.delFromStorage(Z); this._roots.splice(e, 1); if (Z instanceof B8) { Z.delChildrenFromStorage(this) } } }, addToStorage: function (e) { if (e) { e.__storage = this; e.dirty(false) } return this }, delFromStorage: function (e) { if (e) { e.__storage = null } return this }, dispose: function () { this._renderList = this._roots = null }, displayableSortFunc: Er }; var w2 = { "shadowBlur": 1, "shadowOffsetX": 1, "shadowOffsetY": 1, "textShadowBlur": 1, "textShadowOffsetX": 1, "textShadowOffsetY": 1, "textBoxShadowBlur": 1, "textBoxShadowOffsetX": 1, "textBoxShadowOffsetY": 1 }; var qB = function (e, k, i) { if (w2.hasOwnProperty(k)) { return i *= e.dpr } return i }; var lw = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]]; var xS = function (e) { this.extendFrom(e, false) }; function Fm(i, v1, v) { var e = v1.x == null ? 0 : v1.x; var k = v1.x2 == null ? 1 : v1.x2; var v2 = v1.y == null ? 0 : v1.y; var m = v1.y2 == null ? 0 : v1.y2; if (!v1.global) { e = e * v.width + v.x; k = k * v.width + v.x; v2 = v2 * v.height + v.y; m = m * v.height + v.y } e = isNaN(e) ? 0 : e; k = isNaN(k) ? 1 : k; v2 = isNaN(v2) ? 0 : v2; m = isNaN(m) ? 0 : m; var Z = i.createLinearGradient(e, v2, k, m); return Z } function a3(Ij, m, Z) { var i = Z.width; var v3 = Z.height; var k = Math.min(i, v3); var v2 = m.x == null ? 0.5 : m.x; var v = m.y == null ? 0.5 : m.y; var e = m.r == null ? 0.5 : m.r; if (!m.global) { v2 = v2 * i + Z.x; v = v * v3 + Z.y; e = e * k } var v1 = Ij.createRadialGradient(v2, v, 0, v2, v, e); return v1 } xS.prototype = {
    constructor: xS, fill: "#000", stroke: null, opacity: 1, fillOpacity: null, strokeOpacity: null, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: false, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: "#000", textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: "inside", textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: "transparent", textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: "transparent", textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: false, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind: function (Ik, v, e) { var m = this; var Ij = e && e.style; var v3 = !Ij; for (var v1 = 0; v1 < lw.length; v1++) { var k = lw[v1]; var Z = k[0]; if (v3 || m[Z] !== Ij[Z]) { Ik[Z] = qB(Ik, Z, m[Z] || k[1]) } } if ((v3 || m.fill !== Ij.fill)) { Ik.fillStyle = m.fill } if ((v3 || m.stroke !== Ij.stroke)) { Ik.strokeStyle = m.stroke } if ((v3 || m.opacity !== Ij.opacity)) { Ik.globalAlpha = m.opacity == null ? 1 : m.opacity } if ((v3 || m.blend !== Ij.blend)) { Ik.globalCompositeOperation = m.blend || "source-over" } if (this.hasStroke()) { var v2 = m.lineWidth; Ik.lineWidth = v2 / ((this.strokeNoScale && v && v.getLineScale) ? v.getLineScale() : 1) } }, hasFill: function () { var e = this.fill; return e != null && e !== "none" }, hasStroke: function () { var e = this.stroke; return e != null && e !== "none" && this.lineWidth > 0 }, extendFrom: function (e, k) { if (e) { for (var i in e) { if (e.hasOwnProperty(i) && (k === true || (k === false ? !this.hasOwnProperty(i) : e[i] != null))) { this[i] = e[i] } } } }, set: function (i, e) {
      if (typeof i === "string") { this[i] = e } else {
        this.extendFrom(i, true)
      }
    }, clone: function () { var e = new this.constructor(); e.extendFrom(this, true); return e }, getGradient: function (e, v1, v) { var v2 = v1.type === "radial" ? a3 : Fm; var Z = v2(e, v1, v); var k = v1.colorStops; for (var m = 0; m < k.length; m++) { Z.addColorStop(k[m].offset, k[m].color) } return Z }
  }; var mY = xS.prototype; for (var Hf = 0; Hf < lw.length; Hf++) { var xo = lw[Hf]; if (!(xo[0] in mY)) { mY[xo[0]] = xo[1] } } xS.getGradient = mY.getGradient; var oY = function (i, e) { this.image = i; this.repeat = e; this.type = "pattern" }; oY.prototype.getCanvasPattern = function (e) { return e.createPattern(this.image, this.repeat || "repeat") }; function ug() { return false } function xy(v1, i, v) { var k = Dc(); var m = i.getWidth(); var e = i.getHeight(); var Z = k.style; if (Z) { Z.position = "absolute"; Z.left = 0; Z.top = 0; Z.width = m + "px"; Z.height = e + "px"; k.setAttribute("data-zr-dom-id", v1) } k.width = m * v; k.height = e * v; return k } var ek = function (v, e, k) { var m; k = k || h3; if (typeof v === "string") { m = xy(v, e, k) } else { if (tJ(v)) { m = v; v = m.id } } this.id = v; this.dom = m; var i = m.style; if (i) { m.onselectstart = ug; i["-webkit-user-select"] = "none"; i["user-select"] = "none"; i["-webkit-touch-callout"] = "none"; i["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"; i["padding"] = 0; i["margin"] = 0; i["border-width"] = 0 } this.domBack = null; this.ctxBack = null; this.painter = e; this.config = null; this.clearColor = 0; this.motionBlur = false; this.lastFrameAlpha = 0.7; this.dpr = k }; ek.prototype = { constructor: ek, __dirty: true, __used: false, __drawIndex: 0, __startIndex: 0, __endIndex: 0, incremental: false, getElementCount: function () { return this.__endIndex - this.__startIndex }, initContext: function () { this.ctx = this.dom.getContext("2d"); this.ctx.dpr = this.dpr }, createBackBuffer: function () { var e = this.dpr; this.domBack = xy("back-" + this.id, this.painter, e); this.ctxBack = this.domBack.getContext("2d"); if (e != 1) { this.ctxBack.scale(e, e) } }, resize: function (m, e) { var v = this.dpr; var Z = this.dom; var k = Z.style; var i = this.domBack; if (k) { k.width = m + "px"; k.height = e + "px" } Z.width = m * v; Z.height = e * v; if (i) { i.width = m * v; i.height = e * v; if (v != 1) { this.ctxBack.scale(v, v) } } }, clear: function (v, Ij) { var k = this.dom; var Ik = this.ctx; var i = k.width; var v3 = k.height; var Ij = Ij || this.clearColor; var v2 = this.motionBlur && !v; var e = this.lastFrameAlpha; var v1 = this.dpr; if (v2) { if (!this.domBack) { this.createBackBuffer() } this.ctxBack.globalCompositeOperation = "copy"; this.ctxBack.drawImage(k, 0, 0, i / v1, v3 / v1) } Ik.clearRect(0, 0, i, v3); if (Ij && Ij !== "transparent") { var Z; if (Ij.colorStops) { Z = Ij.__canvasGradient || xS.getGradient(Ik, Ij, { x: 0, y: 0, width: i, height: v3 }); Ij.__canvasGradient = Z } else { if (Ij.image) { Z = oY.prototype.getCanvasPattern.call(Ij, Ik) } } Ik.save(); Ik.fillStyle = Z || Ij; Ik.fillRect(0, 0, i, v3); Ik.restore() } if (v2) { var m = this.domBack; Ik.save(); Ik.globalAlpha = e; Ik.drawImage(m, 0, 0, i, v3); Ik.restore() } } }; var nu = (typeof window !== "undefined" && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window)) || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window)) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame)) || function (e) { setTimeout(e, 16) }; var bh = new lG(50); function nn(e) { if (typeof e === "string") { var i = bh.get(e); return i && i.image } else { return e } } function pa(k, v1, m, i, e) { if (!k) { return v1 } else { if (typeof k === "string") { if ((v1 && v1.__zrImageSrc === k) || !m) { return v1 } var Z = bh.get(k); var v = { hostEl: m, cb: i, cbPayload: e }; if (Z) { v1 = Z.image; !GB(v1) && Z.pending.push(v) } else { !v1 && (v1 = new Image()); v1.onload = v1.onerror = gl; bh.put(k, v1.__cachedImgObj = { image: v1, pending: [v] }); v1.src = v1.__zrImageSrc = k } return v1 } else { return k } } } function gl() { var v = this.__cachedImgObj; this.onload = this.onerror = this.__cachedImgObj = null; for (var k = 0; k < v.pending.length; k++) { var m = v.pending[k]; var e = m.cb; e && e(this, m.cbPayload); m.hostEl.dirty() } v.pending.length = 0 } function GB(e) { return e && e.width && e.height } var pL = {}; var iC = 0; var xj = 5000; var wr = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; var EY = "12px sans-serif"; var jN = {}; function gY(e, i) { jN[e] = i } function i7(v2, k) { k = k || EY; var v = v2 + ":" + k; if (pL[v]) { return pL[v] } var v1 = (v2 + "").split("\n"); var Z = 0; for (var m = 0, e = v1.length; m < e; m++) { Z = Math.max(vu(v1[m], k).width, Z) } if (iC > xj) { iC = 0; pL = {} } iC++; pL[v] = Z; return Z } function Gr(v1, k, m, i, Z, e, v) { return e ? gP(v1, k, m, i, Z, e, v) : w6(v1, k, m, i, Z, v) } function w6(Ik, i, e, m, v1, v3) { var k = y(Ik, i, v1, v3); var Il = i7(Ik, i); if (v1) { Il += v1[1] + v1[3] } var Ij = k.outerHeight; var v2 = uz(0, Il, e); var Z = uv(0, Ij, m); var v = new CH(v2, Z, Il, Ij); v.lineHeight = k.lineHeight; return v } function gP(Ik, k, e, v, v1, i, v3) { var m = sq(Ik, { rich: i, truncate: v3, font: k, textAlign: e, textPadding: v1 }); var Il = m.outerWidth; var Ij = m.outerHeight; var v2 = uz(0, Il, e); var Z = uv(0, Ij, v); return new CH(v2, Z, Il, Ij) } function uz(e, k, i) { if (i === "right") { e -= k } else { if (i === "center") { e -= k / 2 } } return e } function uv(k, e, i) { if (i === "middle") { k -= e / 2 } else { if (i === "bottom") { k -= e } } return k } function FW(Ij, v1, e) {
    var v2 = v1.x; var Z = v1.y; var v3 = v1.height; var k = v1.width; var v = v3 / 2; var i = "left"; var m = "top"; switch (Ij) {
      case "left": v2 -= e; Z += v; i = "right"; m = "middle"; break; case "right": v2 += e + k; Z += v; m = "middle"; break; case "top": v2 += k / 2; Z -= e; i = "center"; m = "bottom"; break; case "bottom": v2 += k / 2; Z += v3 + e; i = "center"; break; case "inside": v2 += k / 2; Z += v; i = "center"; m = "middle";
        break; case "insideLeft": v2 += e; Z += v; m = "middle"; break; case "insideRight": v2 += k - e; Z += v; i = "right"; m = "middle"; break; case "insideTop": v2 += k / 2; Z += e; i = "center"; break; case "insideBottom": v2 += k / 2; Z += v3 - e; i = "center"; m = "bottom"; break; case "insideTopLeft": v2 += e; Z += e; break; case "insideTopRight": v2 += k - e; Z += e; i = "right"; break; case "insideBottomLeft": v2 += e; Z += v3 - e; m = "bottom"; break; case "insideBottomRight": v2 += k - e; Z += v3 - e; i = "right"; m = "bottom"; break
    }return { x: v2, y: Z, textAlign: i, textVerticalAlign: m }
  } function aW(v3, v2, m, k, v) { if (!v2) { return "" } var v1 = (v3 + "").split("\n"); v = z(v2, m, k, v); for (var Z = 0, e = v1.length; Z < e; Z++) { v1[Z] = ed(v1[Z], v) } return v1.join("\n") } function z(v2, v, v3, Ij) { Ij = b0({}, Ij); Ij.font = v; var v3 = kb(v3, "..."); Ij.maxIterations = kb(Ij.maxIterations, 2); var m = Ij.minChar = kb(Ij.minChar, 0); Ij.cnCharWidth = i7("", v); var Z = Ij.ascCharWidth = i7("a", v); Ij.placeholder = kb(Ij.placeholder, ""); var e = v2 = Math.max(0, v2 - 1); for (var v1 = 0; v1 < m && e >= Z; v1++) { e -= Z } var k = i7(v3); if (k > e) { v3 = ""; k = 0 } e = v2 - k; Ij.ellipsis = v3; Ij.ellipsisWidth = k; Ij.contentWidth = e; Ij.containerWidth = v2; return Ij } function ed(v1, v) { var v2 = v.containerWidth; var k = v.font; var i = v.contentWidth; if (!v2) { return "" } var e = i7(v1, k); if (e <= v2) { return v1 } for (var m = 0; ; m++) { if (e <= i || m >= v.maxIterations) { v1 += v.ellipsis; break } var Z = m === 0 ? kk(v1, i, v.ascCharWidth, v.cnCharWidth) : e > 0 ? Math.floor(v1.length * i / e) : 0; v1 = v1.substr(0, Z); e = i7(v1, k) } if (v1 === "") { v1 = v.placeholder } return v1 } function kk(v3, v, v2, m) { var v1 = 0; var Z = 0; for (var e = v3.length; Z < e && v1 < v; Z++) { var k = v3.charCodeAt(Z); v1 += (0 <= k && k <= 127) ? v2 : m } return Z } function n2(e) { return i7("", e) } function vu(i, e) { return jN.measureText(i, e) } jN.measureText = function (k, i) { var e = oH(); e.font = i || EY; return e.measureText(k) }; function y(Ik, e, Z, v1) { Ik != null && (Ik += ""); var v2 = n2(e); var In = Ik ? Ik.split("\n") : []; var Il = In.length * v2; var v3 = Il; if (Z) { v3 += Z[0] + Z[2] } if (Ik && v1) { var v = v1.outerHeight; var Ij = v1.outerWidth; if (v != null && v3 > v) { Ik = ""; In = [] } else { if (Ij != null) { var Im = z(Ij - (Z ? Z[1] + Z[3] : 0), e, v1.ellipsis, { minChar: v1.minChar, placeholder: v1.placeholder }); for (var k = 0, m = In.length; k < m; k++) { In[k] = ed(In[k], Im) } } } } return { lines: In, height: Il, outerHeight: v3, lineHeight: v2 } } function sq(Ir, ID) { var Ij = { lines: [], width: 0, height: 0 }; Ir != null && (Ir += ""); if (!Ir) { return Ij } var IE = wr.lastIndex = 0; var In; while ((In = wr.exec(Ir)) != null) { var Iy = In.index; if (Iy > IE) { fH(Ij, Ir.substring(IE, Iy)) } fH(Ij, In[2], In[1]); IE = wr.lastIndex } if (IE < Ir.length) { fH(Ij, Ir.substring(IE, Ir.length)) } var k = Ij.lines; var Ix = 0; var It = 0; var Iq = []; var Il = ID.textPadding; var m = ID.truncate; var Ik = m && m.outerWidth; var v2 = m && m.outerHeight; if (Il) { Ik != null && (Ik -= Il[1] + Il[3]); v2 != null && (v2 -= Il[0] + Il[2]) } for (var IB = 0; IB < k.length; IB++) { var Io = k[IB]; var Z = 0; var e = 0; for (var Iw = 0; Iw < Io.tokens.length; Iw++) { var v3 = Io.tokens[Iw]; var IA = v3.styleName && ID.rich[v3.styleName] || {}; var Iz = v3.textPadding = IA.textPadding; var Is = v3.font = IA.font || ID.font; var IF = v3.textHeight = kb(IA.textHeight, n2(Is)); Iz && (IF += Iz[0] + Iz[2]); v3.height = IF; v3.lineHeight = ka(IA.textLineHeight, ID.textLineHeight, IF); v3.textAlign = IA && IA.textAlign || ID.textAlign; v3.textVerticalAlign = IA && IA.textVerticalAlign || "middle"; if (v2 != null && Ix + v3.lineHeight > v2) { return { lines: [], width: 0, height: 0 } } v3.textWidth = i7(v3.text, Is); var Iv = IA.textWidth; var Iu = Iv == null || Iv === "auto"; if (typeof Iv === "string" && Iv.charAt(Iv.length - 1) === "%") { v3.percentWidth = Iv; Iq.push(v3); Iv = 0 } else { if (Iu) { Iv = v3.textWidth; var v1 = IA.textBackgroundColor; var v = v1 && v1.image; if (v) { v = nn(v); if (GB(v)) { Iv = Math.max(Iv, v.width * IF / v.height) } } } var IC = Iz ? Iz[1] + Iz[3] : 0; Iv += IC; var Ip = Ik != null ? Ik - e : null; if (Ip != null && Ip < Iv) { if (!Iu || Ip < IC) { v3.text = ""; v3.textWidth = Iv = 0 } else { v3.text = aW(v3.text, Ip - IC, Is, m.ellipsis, { minChar: m.minChar }); v3.textWidth = i7(v3.text, Is); Iv = v3.textWidth + IC } } } e += (v3.width = Iv); IA && (Z = Math.max(Z, v3.lineHeight)) } Io.width = e; Io.lineHeight = Z; Ix += Z; It = Math.max(It, e) } Ij.outerWidth = Ij.width = kb(ID.textWidth, It); Ij.outerHeight = Ij.height = kb(ID.textHeight, Ix); if (Il) { Ij.outerWidth += Il[1] + Il[3]; Ij.outerHeight += Il[0] + Il[2] } for (var IB = 0; IB < Iq.length; IB++) { var v3 = Iq[IB]; var Im = v3.percentWidth; v3.width = parseInt(Im, 10) / 100 * It } return Ij } function fH(v, Ij, k) { var e = Ij === ""; var v2 = Ij.split("\n"); var Il = v.lines; for (var v1 = 0; v1 < v2.length; v1++) { var Ik = v2[v1]; var m = { styleName: k, text: Ik, isLineHolder: !Ik && !e }; if (!v1) { var v3 = (Il[Il.length - 1] || (Il[0] = { tokens: [] })).tokens; var Z = v3.length; (Z === 1 && v3[0].isLineHolder) ? (v3[0] = m) : ((Ik || !Z || e) && v3.push(m)) } else { Il.push({ tokens: [m] }) } } } function py(i) { var e = (i.fontSize || i.fontFamily) && [i.fontStyle, i.fontWeight, (i.fontSize || 12) + "px", i.fontFamily || "sans-serif"].join(" "); return e && Gs(e) || i.textFont || i.font } function tf(Il, v1) {
    var Ij = v1.x; var v3 = v1.y; var m = v1.width; var Ik = v1.height; var e = v1.r; var Z; var v; var k; var i; if (m < 0) { Ij = Ij + m; m = -m } if (Ik < 0) { v3 = v3 + Ik; Ik = -Ik } if (typeof e === "number") { Z = v = k = i = e } else { if (e instanceof Array) { if (e.length === 1) { Z = v = k = i = e[0] } else { if (e.length === 2) { Z = k = e[0]; v = i = e[1] } else { if (e.length === 3) { Z = e[0]; v = i = e[1]; k = e[2] } else { Z = e[0]; v = e[1]; k = e[2]; i = e[3] } } } } else { Z = v = k = i = 0 } } var v2; if (Z + v > m) { v2 = Z + v; Z *= m / v2; v *= m / v2 } if (k + i > m) {
      v2 = k + i; k *= m / v2; i *= m / v2
    } if (v + k > Ik) { v2 = v + k; v *= Ik / v2; k *= Ik / v2 } if (Z + i > Ik) { v2 = Z + i; Z *= Ik / v2; i *= Ik / v2 } Il.moveTo(Ij + Z, v3); Il.lineTo(Ij + m - v, v3); v !== 0 && Il.arc(Ij + m - v, v3 + v, v, -Math.PI / 2, 0); Il.lineTo(Ij + m, v3 + Ik - k); k !== 0 && Il.arc(Ij + m - k, v3 + Ik - k, k, 0, Math.PI / 2); Il.lineTo(Ij + i, v3 + Ik); i !== 0 && Il.arc(Ij + i, v3 + Ik - i, i, Math.PI / 2, Math.PI); Il.lineTo(Ij, v3 + Z); Z !== 0 && Il.arc(Ij + Z, v3 + Z, Z, Math.PI, Math.PI * 1.5)
  } var zK = { left: 1, right: 1, center: 1 }; var Eq = { top: 1, bottom: 1, middle: 1 }; var CN = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]]; function pg(e) { CD(e); o9(e.rich, CD); return e } function CD(k) { if (k) { k.font = py(k); var i = k.textAlign; i === "middle" && (i = "center"); k.textAlign = (i == null || zK[i]) ? i : "left"; var e = k.textVerticalAlign || k.textBaseline; e === "center" && (e = "middle"); k.textVerticalAlign = (e == null || Eq[e]) ? e : "top"; var m = k.textPadding; if (m) { k.textPadding = Dv(k.textPadding) } } } function Az(k, e, Z, m, v, i) { m.rich ? ft(k, e, Z, m, v) : fs(k, e, Z, m, v, i) } function fs(Iq, Ir, Iu, IG, Iw, IB) { var Io = IB && IB.style; var m = Io && IB.type === "text"; var Ij = IG.font || EY; if (!m || Ij !== (Io.font || EY)) { Ir.font = Ij } var v3 = Iq.__computedFont; if (Iq.__styleFont !== Ij) { Iq.__styleFont = Ij; v3 = Iq.__computedFont = Ir.font } var Ix = IG.textPadding; var Z = Iq.__textCotentBlock; if (!Z || Iq.__dirtyText) { Z = Iq.__textCotentBlock = y(Iu, v3, Ix, IG.truncate) } var IK = Z.outerHeight; var IJ = Z.lines; var Iv = Z.lineHeight; var IC = yN(IK, IG, Iw); var IE = IC.baseX; var ID = IC.baseY; var v1 = IC.textAlign || "left"; var v2 = IC.textVerticalAlign; gD(Ir, IG, Iw, IE, ID); var Il = uv(ID, IK, v2); var k = IE; var e = Il; var In = i3(IG); if (In || Ix) { var Ik = i7(Iu, v3); var IF = Ik; Ix && (IF += Ix[1] + Ix[3]); var Im = uz(IE, IF, v1); In && pE(Iq, Ir, IG, Im, Il, IF, IK); if (Ix) { k = h4(IE, v1, Ix); e += Ix[0] } } Ir.textAlign = v1; Ir.textBaseline = "middle"; for (var II = 0; II < CN.length; II++) { var v = CN[II]; var Iz = v[0]; var Is = v[1]; var It = IG[Iz]; if (!m || It !== Io[Iz]) { Ir[Is] = qB(Ir, Is, It || v[2]) } } e += Iv / 2; var IM = IG.textStrokeWidth; var Ip = m ? Io.textStrokeWidth : null; var Iy = !m || IM !== Ip; var IL = !m || Iy || IG.textStroke !== Io.textStroke; var IH = wY(IG.textStroke, IM); var IA = gt(IG.textFill); if (IH) { if (Iy) { Ir.lineWidth = IM } if (IL) { Ir.strokeStyle = IH } } if (IA) { if (!m || IG.textFill !== Io.textFill) { Ir.fillStyle = IA } } if (IJ.length === 1) { IH && Ir.strokeText(IJ[0], k, e); IA && Ir.fillText(IJ[0], k, e) } else { for (var II = 0; II < IJ.length; II++) { IH && Ir.strokeText(IJ[II], k, e); IA && Ir.fillText(IJ[II], k, e); e += Iv } } } function ft(i, e, Z, m, v) { var k = i.__textCotentBlock; if (!k || i.__dirtyText) { k = i.__textCotentBlock = sq(Z, m) } xN(i, e, k, m, v) } function xN(Iw, Iv, Im, Iz, Z) { var Is = Im.width; var e = Im.outerWidth; var v = Im.outerHeight; var Iy = Iz.textPadding; var IC = yN(v, Iz, Z); var m = IC.baseX; var k = IC.baseY; var v3 = IC.textAlign; var Ir = IC.textVerticalAlign; gD(Iv, Iz, Z, m, k); var IE = uz(m, e, v3); var ID = uv(k, v, Ir); var Ip = IE; var v2 = ID; if (Iy) { Ip += Iy[3]; v2 += Iy[0] } var IB = Ip + Is; i3(Iz) && pE(Iw, Iv, Iz, IE, ID, e, v); for (var Ix = 0; Ix < Im.lines.length; Ix++) { var Io = Im.lines[Ix]; var Iq = Io.tokens; var Ij = Iq.length; var v1 = Io.lineHeight; var Il = Io.width; var It = 0; var IA = Ip; var In = IB; var Iu = Ij - 1; var Ik; while (It < Ij && (Ik = Iq[It], !Ik.textAlign || Ik.textAlign === "left")) { Ev(Iw, Iv, Ik, Iz, v1, v2, IA, "left"); Il -= Ik.width; IA += Ik.width; It++ } while (Iu >= 0 && (Ik = Iq[Iu], Ik.textAlign === "right")) { Ev(Iw, Iv, Ik, Iz, v1, v2, In, "right"); Il -= Ik.width; In -= Ik.width; Iu-- } IA += (Is - (IA - Ip) - (IB - In) - Il) / 2; while (It <= Iu) { Ik = Iq[It]; Ev(Iw, Iv, Ik, Iz, v1, v2, IA + Ik.width / 2, "center"); IA += Ik.width; It++ } v2 += v1 } } function gD(i, m, v, e, Z) { if (v && m.textRotation) { var k = m.textOrigin; if (k === "center") { e = v.width / 2 + v.x; Z = v.height / 2 + v.y } else { if (k) { e = k[0] + v.x; Z = k[1] + v.y } } i.translate(e, Z); i.rotate(-m.textRotation); i.translate(-e, -Z) } } function Ev(v3, Im, m, e, Il, Ij, Ik, i) { var Io = e.rich[m.styleName] || {}; Io.text = m.text; var v = m.textVerticalAlign; var v1 = Ij + Il / 2; if (v === "top") { v1 = Ij + m.height / 2 } else { if (v === "bottom") { v1 = Ij + Il - m.height / 2 } } !m.isLineHolder && i3(Io) && pE(v3, Im, Io, i === "right" ? Ik - m.width : i === "center" ? Ik - m.width / 2 : Ik, v1 - m.height / 2, m.width, m.height); var Z = m.textPadding; if (Z) { Ik = h4(Ik, i, Z); v1 -= m.height / 2 - Z[2] - m.textHeight / 2 } rr(Im, "shadowBlur", ka(Io.textShadowBlur, e.textShadowBlur, 0)); rr(Im, "shadowColor", Io.textShadowColor || e.textShadowColor || "transparent"); rr(Im, "shadowOffsetX", ka(Io.textShadowOffsetX, e.textShadowOffsetX, 0)); rr(Im, "shadowOffsetY", ka(Io.textShadowOffsetY, e.textShadowOffsetY, 0)); rr(Im, "textAlign", i); rr(Im, "textBaseline", "middle"); rr(Im, "font", m.font || EY); var v2 = wY(Io.textStroke || e.textStroke, k); var In = gt(Io.textFill || e.textFill); var k = kb(Io.textStrokeWidth, e.textStrokeWidth); if (v2) { rr(Im, "lineWidth", k); rr(Im, "strokeStyle", v2); Im.strokeText(m.text, Ik, v1) } if (In) { rr(Im, "fillStyle", In); Im.fillText(m.text, Ik, v1) } } function i3(e) { return e.textBackgroundColor || (e.textBorderWidth && e.textBorderColor) } function pE(v2, In, e, v3, v1, i, Il) {
    var Ij = e.textBackgroundColor; var m = e.textBorderWidth; var Z = e.textBorderColor; var Im = wb(Ij); rr(In, "shadowBlur", e.textBoxShadowBlur || 0); rr(In, "shadowColor", e.textBoxShadowColor || "transparent"); rr(In, "shadowOffsetX", e.textBoxShadowOffsetX || 0); rr(In, "shadowOffsetY", e.textBoxShadowOffsetY || 0); if (Im || (m && Z)) {
      In.beginPath();
      var v = e.textBorderRadius; if (!v) { In.rect(v3, v1, i, Il) } else { tf(In, { x: v3, y: v1, width: i, height: Il, r: v }) } In.closePath()
    } if (Im) { rr(In, "fillStyle", Ij); if (e.fillOpacity != null) { var Ik = In.globalAlpha; In.globalAlpha = e.fillOpacity * e.opacity; In.fill(); In.globalAlpha = Ik } else { In.fill() } } else { if (E5(Ij)) { rr(In, "fillStyle", Ij(e)); In.fill() } else { if (tJ(Ij)) { var k = Ij.image; k = pa(k, null, v2, w1, Ij); if (k && GB(k)) { In.drawImage(k, v3, v1, i, Il) } } } } if (m && Z) { rr(In, "lineWidth", m); rr(In, "strokeStyle", Z); if (e.strokeOpacity != null) { var Ik = In.globalAlpha; In.globalAlpha = e.strokeOpacity * e.opacity; In.stroke(); In.globalAlpha = Ik } else { In.stroke() } }
  } function w1(i, e) { e.image = i } function yN(v1, e, v3) { var v = e.x || 0; var k = e.y || 0; var i = e.textAlign; var Z = e.textVerticalAlign; if (v3) { var Ij = e.textPosition; if (Ij instanceof Array) { v = v3.x + B5(Ij[0], v3.width); k = v3.y + B5(Ij[1], v3.height) } else { var v2 = FW(Ij, v3, e.textDistance); v = v2.x; k = v2.y; i = i || v2.textAlign; Z = Z || v2.textVerticalAlign } var m = e.textOffset; if (m) { v += m[0]; k += m[1] } } return { baseX: v, baseY: k, textAlign: i, textVerticalAlign: Z } } function rr(e, k, i) { e[k] = qB(e, k, i); return e[k] } function wY(i, e) { return (i == null || e <= 0 || i === "transparent" || i === "none") ? null : (i.image || i.colorStops) ? "#000" : i } function gt(e) { return (e == null || e === "none") ? null : (e.image || e.colorStops) ? "#000" : e } function B5(e, i) { if (typeof e === "string") { if (e.lastIndexOf("%") >= 0) { return parseFloat(e) / 100 * i } return parseFloat(e) } return e } function h4(e, i, k) { return i === "right" ? (e - k[1]) : i === "center" ? (e + k[3] / 2 - k[1] / 2) : (e + k[3]) } function Et(i, e) { return i != null && (i || e.textBackgroundColor || (e.textBorderWidth && e.textBorderColor) || e.textPadding) } var et = new CH(); var y7 = function () { }; y7.prototype = { constructor: y7, drawRectText: function (e, m) { var k = this.style; m = k.textRect || m; this.__dirty && pg(k, true); var v = k.text; v != null && (v += ""); if (!Et(v, k)) { return } e.save(); var i = this.transform; if (!k.transformText) { if (i) { et.copy(m); et.applyTransform(i); m = et } } else { this.setTransform(e) } Az(this, e, v, k, m); e.restore() } }; function Ie(i) { i = i || {}; s0.call(this, i); for (var e in i) { if (i.hasOwnProperty(e) && e !== "style") { this[e] = i[e] } } this.style = new xS(i.style, this); this._rect = null; this.__clipPaths = [] } Ie.prototype = { constructor: Ie, type: "displayable", __dirty: true, invisible: false, z: 0, z2: 0, zlevel: 0, draggable: false, dragging: false, silent: false, culling: false, cursor: "pointer", rectHover: false, progressive: false, incremental: false, globalScaleRatio: 1, beforeBrush: function (e) { }, afterBrush: function (e) { }, brush: function (e, i) { }, getBoundingRect: function () { }, contain: function (e, i) { return this.rectContain(e, i) }, traverse: function (e, i) { e.call(i, this) }, rectContain: function (e, m) { var k = this.transformCoordToLocal(e, m); var i = this.getBoundingRect(); return i.contain(k[0], k[1]) }, dirty: function () { this.__dirty = this.__dirtyText = true; this._rect = null; this.__zr && this.__zr.refresh() }, animateStyle: function (e) { return this.animate("style", e) }, attrKV: function (e, i) { if (e !== "style") { s0.prototype.attrKV.call(this, e, i) } else { this.style.set(i) } }, setStyle: function (e, i) { this.style.set(e, i); this.dirty(false); return this }, useStyle: function (e) { this.style = new xS(e, this); this.dirty(false); return this } }; mr(Ie, s0); Gq(Ie, y7); function Ft(e) { Ie.call(this, e) } Ft.prototype = { constructor: Ft, type: "image", brush: function (In, k) { var m = this.style; var i = m.image; m.bind(In, this, k); var v1 = this._image = pa(i, this._image, this, this.onload); if (!v1 || !GB(v1)) { return } var Il = m.x || 0; var Ij = m.y || 0; var v = m.width; var Im = m.height; var e = v1.width / v1.height; if (v == null && Im != null) { v = Im * e } else { if (Im == null && v != null) { Im = v / e } else { if (v == null && Im == null) { v = v1.width; Im = v1.height } } } this.setTransform(In); if (m.sWidth && m.sHeight) { var Ik = m.sx || 0; var v3 = m.sy || 0; In.drawImage(v1, Ik, v3, m.sWidth, m.sHeight, Il, Ij, v, Im) } else { if (m.sx && m.sy) { var Ik = m.sx; var v3 = m.sy; var Z = v - Ik; var v2 = Im - v3; In.drawImage(v1, Ik, v3, Z, v2, Il, Ij, v, Im) } else { In.drawImage(v1, Il, Ij, v, Im) } } if (m.text != null) { this.restoreTransform(In); this.drawRectText(In, this.getBoundingRect()) } }, getBoundingRect: function () { var e = this.style; if (!this._rect) { this._rect = new CH(e.x || 0, e.y || 0, e.width || 0, e.height || 0) } return this._rect } }; mr(Ft, Ie); var DP = 100000; var s = 314159; var f4 = 0.01; var xp = 0.001; function Ee(e) { return parseInt(e, 10) } function S(e) { if (!e) { return false } if (e.__builtin__) { return true } if (typeof (e.resize) !== "function" || typeof (e.refresh) !== "function") { return false } return true } var jF = new CH(0, 0, 0, 0); var nd = new CH(0, 0, 0, 0); function op(k, i, e) { jF.copy(k.getBoundingRect()); if (k.transform) { jF.applyTransform(k.transform) } nd.width = i; nd.height = e; return !jF.intersect(nd) } function Bg(m, e) { if (m == e) { return false } if (!m || !e || (m.length !== e.length)) { return true } for (var k = 0; k < m.length; k++) { if (m[k] !== e[k]) { return true } } } function f7(v, e) { for (var k = 0; k < v.length; k++) { var m = v[k]; m.setTransform(e); e.beginPath(); m.buildPath(e, m.shape); e.clip(); m.restoreTransform(e) } } function D4(k, i) { var e = document.createElement("div"); e.style.cssText = ["position:relative", "overflow:hidden", "width:" + k + "px", "height:" + i + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";"; return e } var aQ = function (v3, Z, e) {
    this.type = "canvas"; var v2 = !v3.nodeName || v3.nodeName.toUpperCase() === "CANVAS";
    this._opts = e = b0({}, e || {}); this.dpr = e.devicePixelRatio || h3; this._singleCanvas = v2; this.root = v3; var i = v3.style; if (i) { i["-webkit-tap-highlight-color"] = "transparent"; i["-webkit-user-select"] = i["user-select"] = i["-webkit-touch-callout"] = "none"; v3.innerHTML = "" } this.storage = Z; var m = this._zlevelList = []; var v = this._layers = {}; this._layerConfig = {}; this._needsManuallyCompositing = false; if (!v2) { this._width = this._getSize(0); this._height = this._getSize(1); var Ij = this._domRoot = D4(this._width, this._height); v3.appendChild(Ij) } else { var k = v3.width; var Ik = v3.height; if (e.width != null) { k = e.width } if (e.height != null) { Ik = e.height } this.dpr = e.devicePixelRatio || 1; v3.width = k * this.dpr; v3.height = Ik * this.dpr; this._width = k; this._height = Ik; var v1 = new ek(v3, this, this.dpr); v1.__builtin__ = true; v1.initContext(); v[s] = v1; v1.zlevel = s; m.push(s); this._domRoot = v3 } this._hoverlayer = null; this._hoverElements = []
  }; aQ.prototype = {
    constructor: aQ, getType: function () { return "canvas" }, isSingleCanvas: function () { return this._singleCanvas }, getViewportRoot: function () { return this._domRoot }, getViewportRootOffset: function () { var e = this.getViewportRoot(); if (e) { return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 } } }, refresh: function (e) { var v1 = this.storage.getDisplayList(true); var v = this._zlevelList; this._redrawId = Math.random(); this._paintList(v1, e, this._redrawId); for (var m = 0; m < v.length; m++) { var v2 = v[m]; var k = this._layers[v2]; if (!k.__builtin__ && k.refresh) { var Z = m === 0 ? this._backgroundColor : null; k.refresh(Z) } } this.refreshHover(); return this }, addHover: function (e, i) { if (e.__hoverMir) { return } var k = new e.constructor({ style: e.style, shape: e.shape, z: e.z, z2: e.z2, silent: e.silent }); k.__from = e; e.__hoverMir = k; i && k.setStyle(i); this._hoverElements.push(k); return k }, removeHover: function (k) { var m = k.__hoverMir; var i = this._hoverElements; var e = eP(i, m); if (e >= 0) { i.splice(e, 1) } k.__hoverMir = null }, clearHover: function (m) { var e = this._hoverElements; for (var k = 0; k < e.length; k++) { var v = e[k].__from; if (v) { v.__hoverMir = null } } e.length = 0 }, refreshHover: function () { var k = this._hoverElements; var e = k.length; var v1 = this._hoverlayer; v1 && v1.clear(); if (!e) { return } qu(k, this.storage.displayableSortFunc); if (!v1) { v1 = this._hoverlayer = this.getLayer(DP) } var Z = {}; v1.ctx.save(); for (var m = 0; m < e;) { var v = k[m]; var v2 = v.__from; if (!(v2 && v2.__zr)) { k.splice(m, 1); v2.__hoverMir = null; e--; continue } m++; if (!v2.invisible) { v.transform = v2.transform; v.invTransform = v2.invTransform; v.__clipPaths = v2.__clipPaths; this._doPaintEl(v, v1, true, Z) } } v1.ctx.restore() }, getHoverLayer: function () { return this.getLayer(DP) }, _paintList: function (m, i, k) { if (this._redrawId !== k) { return } i = i || false; this._updateLayerStatus(m); var v = this._doPaintList(m, i); if (this._needsManuallyCompositing) { this._compositeManually() } if (!v) { var e = this; nu(function () { e._paintList(m, i, k) }) } }, _compositeManually: function () { var i = this.getLayer(s).ctx; var k = this._domRoot.width; var e = this._domRoot.height; i.clearRect(0, 0, k, e); this.eachBuiltinLayer(function (m) { if (m.virtual) { i.drawImage(m.dom, 0, 0, k, e) } }) }, _doPaintList: function (Is, Im) { var Ir = []; for (var Ij = 0; Ij < this._zlevelList.length; Ij++) { var e = this._zlevelList[Ij]; var It = this._layers[e]; if (It.__builtin__ && It !== this._hoverlayer && (It.__dirty || Im)) { Ir.push(It) } } var Ik = true; for (var Ip = 0; Ip < Ir.length; Ip++) { var It = Ir[Ip]; var Io = It.ctx; var m = {}; Io.save(); var v2 = Im ? It.__startIndex : It.__drawIndex; var In = !Im && It.incremental && Date.now; var Il = In && Date.now(); var Z = It.zlevel === this._zlevelList[0] ? this._backgroundColor : null; if (It.__startIndex === It.__endIndex) { It.clear(false, Z) } else { if (v2 === It.__startIndex) { var v1 = Is[v2]; if (!v1.incremental || !v1.notClear || Im) { It.clear(false, Z) } } } if (v2 === -1) { console.error("For some unknown reason. drawIndex is -1"); v2 = It.__startIndex } for (var Iq = v2; Iq < It.__endIndex; Iq++) { var v = Is[Iq]; this._doPaintEl(v, It, Im, m); v.__dirty = v.__dirtyText = false; if (In) { var v3 = Date.now() - Il; if (v3 > 15) { break } } } It.__drawIndex = Iq; if (It.__drawIndex < It.__endIndex) { Ik = false } if (m.prevElClipPaths) { Io.restore() } Io.restore() } if (sW.wxa) { o9(this._layers, function (i) { if (i && i.ctx && i.ctx.draw) { i.ctx.draw() } }) } return Ik }, _doPaintEl: function (Z, k, v2, v) { var i = k.ctx; var e = Z.transform; if ((k.__dirty || v2) && !Z.invisible && Z.style.opacity !== 0 && !(e && !e[0] && !e[3]) && !(Z.culling && op(Z, this._width, this._height))) { var v1 = Z.__clipPaths; if (!v.prevElClipPaths || Bg(v1, v.prevElClipPaths)) { if (v.prevElClipPaths) { k.ctx.restore(); v.prevElClipPaths = null; v.prevEl = null } if (v1) { i.save(); f7(v1, i); v.prevElClipPaths = v1 } } Z.beforeBrush && Z.beforeBrush(i); Z.brush(i, v.prevEl || null); v.prevEl = Z; Z.afterBrush && Z.afterBrush(i) } }, getLayer: function (e, k) { if (this._singleCanvas && !this._needsManuallyCompositing) { e = s } var i = this._layers[e]; if (!i) { i = new ek("zr_" + e, this, this.dpr); i.zlevel = e; i.__builtin__ = true; if (this._layerConfig[e]) { v4(i, this._layerConfig[e], true) } if (k) { i.virtual = k } this.insertLayer(e, i); i.initContext() } return i }, insertLayer: function (Z, v2) {
      var e = this._layers; var m = this._zlevelList; var v3 = m.length; var k = null; var v = -1; var Ij = this._domRoot; if (e[Z]) { Gu("ZLevel " + Z + " has been used already"); return } if (!S(v2)) {
        Gu("Layer of zlevel " + Z + " is not valid");
        return
      } if (v3 > 0 && Z > m[0]) { for (v = 0; v < v3 - 1; v++) { if (m[v] < Z && m[v + 1] > Z) { break } } k = e[m[v]] } m.splice(v + 1, 0, Z); e[Z] = v2; if (!v2.virtual) { if (k) { var v1 = k.dom; if (v1.nextSibling) { Ij.insertBefore(v2.dom, v1.nextSibling) } else { Ij.appendChild(v2.dom) } } else { if (Ij.firstChild) { Ij.insertBefore(v2.dom, Ij.firstChild) } else { Ij.appendChild(v2.dom) } } }
    }, eachLayer: function (e, m) { var v = this._zlevelList; var Z; var k; for (k = 0; k < v.length; k++) { Z = v[k]; e.call(m, this._layers[Z], Z) } }, eachBuiltinLayer: function (e, v) { var Z = this._zlevelList; var m; var v1; var k; for (k = 0; k < Z.length; k++) { v1 = Z[k]; m = this._layers[v1]; if (m.__builtin__) { e.call(v, m, v1) } } }, eachOtherLayer: function (e, v) { var Z = this._zlevelList; var m; var v1; var k; for (k = 0; k < Z.length; k++) { v1 = Z[k]; m = this._layers[v1]; if (!m.__builtin__) { e.call(v, m, v1) } } }, getLayers: function () { return this._layers }, _updateLayerStatus: function (v2) { this.eachBuiltinLayer(function (i, Ij) { i.__dirty = i.__used = false }); function v1(i) { if (v) { if (v.__endIndex !== i) { v.__dirty = true } v.__endIndex = i } } if (this._singleCanvas) { for (var m = 1; m < v2.length; m++) { var Z = v2[m]; if (Z.zlevel !== v2[m - 1].zlevel || Z.incremental) { this._needsManuallyCompositing = true; break } } } var v = null; var v3 = 0; for (var m = 0; m < v2.length; m++) { var Z = v2[m]; var e = Z.zlevel; var k; if (Z.incremental) { k = this.getLayer(e + xp, this._needsManuallyCompositing); k.incremental = true; v3 = 1 } else { k = this.getLayer(e + (v3 > 0 ? f4 : 0), this._needsManuallyCompositing) } if (!k.__builtin__) { Gu("ZLevel " + e + " has been used by unkown layer " + k.id) } if (k !== v) { k.__used = true; if (k.__startIndex !== m) { k.__dirty = true } k.__startIndex = m; if (!k.incremental) { k.__drawIndex = m } else { k.__drawIndex = -1 } v1(m); v = k } if (Z.__dirty) { k.__dirty = true; if (k.incremental && k.__drawIndex < 0) { k.__drawIndex = m } } } v1(m); this.eachBuiltinLayer(function (i, Ij) { if (!i.__used && i.getElementCount() > 0) { i.__dirty = true; i.__startIndex = i.__endIndex = i.__drawIndex = 0 } if (i.__dirty && i.__drawIndex < 0) { i.__drawIndex = i.__startIndex } }) }, clear: function () { this.eachBuiltinLayer(this._clearLayer); return this }, _clearLayer: function (e) { e.clear() }, setBackgroundColor: function (e) { this._backgroundColor = e }, configLayer: function (e, m) { if (m) { var k = this._layerConfig; if (!k[e]) { k[e] = m } else { v4(k[e], m, true) } for (var v1 = 0; v1 < this._zlevelList.length; v1++) { var Z = this._zlevelList[v1]; if (Z === e || Z === e + f4) { var v = this._layers[Z]; v4(v, k[e], true) } } } }, delLayer: function (e) { var m = this._layers; var k = this._zlevelList; var i = m[e]; if (!i) { return } i.dom.parentNode.removeChild(i.dom); delete m[e]; k.splice(eP(k, e), 1) }, resize: function (k, i) { if (!this._domRoot.style) { if (k == null || i == null) { return } this._width = k; this._height = i; this.getLayer(s).resize(k, i) } else { var e = this._domRoot; e.style.display = "none"; var m = this._opts; k != null && (m.width = k); i != null && (m.height = i); k = this._getSize(0); i = this._getSize(1); e.style.display = ""; if (this._width != k || i != this._height) { e.style.width = k + "px"; e.style.height = i + "px"; for (var v in this._layers) { if (this._layers.hasOwnProperty(v)) { this._layers[v].resize(k, i) } } o9(this._progressiveLayers, function (Z) { Z.resize(k, i) }); this.refresh(true) } this._width = k; this._height = i } return this }, clearLayer: function (e) { var i = this._layers[e]; if (i) { i.clear() } }, dispose: function () { this.root.innerHTML = ""; this.root = this.storage = this._domRoot = this._layers = null }, getRenderedCanvas: function (e) { e = e || {}; if (this._singleCanvas && !this._compositeManually) { return this._layers[s].dom } var k = new ek("image", this, e.pixelRatio || this.dpr); k.initContext(); k.clear(false, e.backgroundColor || this._backgroundColor); if (e.pixelRatio <= this.dpr) { this.refresh(); var m = k.dom.width; var v2 = k.dom.height; var Ij = k.ctx; this.eachLayer(function (i) { if (i.__builtin__) { Ij.drawImage(i.dom, 0, 0, m, v2) } else { if (i.renderToCanvas) { k.ctx.save(); i.renderToCanvas(k.ctx); k.ctx.restore() } } }) } else { var v3 = {}; var Z = this.storage.getDisplayList(true); for (var v1 = 0; v1 < Z.length; v1++) { var v = Z[v1]; this._doPaintEl(v, k, true, v3) } } return k.dom }, getWidth: function () { return this._width }, getHeight: function () { return this._height }, _getSize: function (v) { var v2 = this._opts; var m = ["width", "height"][v]; var k = ["clientWidth", "clientHeight"][v]; var Z = ["paddingLeft", "paddingTop"][v]; var e = ["paddingRight", "paddingBottom"][v]; if (v2[m] != null && v2[m] !== "auto") { return parseFloat(v2[m]) } var i = this.root; var v1 = document.defaultView.getComputedStyle(i); return ((i[k] || Ee(v1[m]) || Ee(i.style[m])) - (Ee(v1[Z]) || 0) - (Ee(v1[e]) || 0)) | 0 }, pathToImage: function (Ij, e) {
      e = e || this.dpr; var v = document.createElement("canvas"); var In = v.getContext("2d"); var m = Ij.getBoundingRect(); var Ip = Ij.style; var Ir = Ip.shadowBlur * e; var Il = Ip.shadowOffsetX * e; var Ik = Ip.shadowOffsetY * e; var i = Ip.hasStroke() ? Ip.lineWidth : 0; var Io = Math.max(i / 2, -Il + Ir); var Iq = Math.max(i / 2, Il + Ir); var k = Math.max(i / 2, -Ik + Ir); var v1 = Math.max(i / 2, Ik + Ir); var Im = m.width + Io + Iq; var v3 = m.height + k + v1; v.width = Im * e; v.height = v3 * e; In.scale(e, e); In.clearRect(0, 0, Im, v3); In.dpr = e; var v2 = { position: Ij.position, rotation: Ij.rotation, scale: Ij.scale }; Ij.position = [Io - m.x, k - m.y]; Ij.rotation = 0; Ij.scale = [1, 1]; Ij.updateTransform(); if (Ij) { Ij.brush(In) } var Z = Ft; var Is = new Z({ style: { x: 0, y: 0, image: v } }); if (v2.position != null) {
        Is.position = Ij.position = v2.position
      } if (v2.rotation != null) { Is.rotation = Ij.rotation = v2.rotation } if (v2.scale != null) { Is.scale = Ij.scale = v2.scale } return Is
    }
  }; var x1 = function (e) { e = e || {}; this.stage = e.stage || {}; this.onframe = e.onframe || function () { }; this._clips = []; this._running = false; this._time; this._pausedTime; this._pauseStart; this._paused = false; Gc.call(this) }; x1.prototype = { constructor: x1, addClip: function (e) { this._clips.push(e) }, addAnimator: function (e) { e.animation = this; var k = e.getClips(); for (var m = 0; m < k.length; m++) { this.addClip(k[m]) } }, removeClip: function (i) { var e = eP(this._clips, i); if (e >= 0) { this._clips.splice(e, 1) } }, removeAnimator: function (e) { var k = e.getClips(); for (var m = 0; m < k.length; m++) { this.removeClip(k[m]) } e.animation = null }, _update: function () { var v = new Date().getTime() - this._pausedTime; var Ik = v - this._time; var k = this._clips; var v2 = k.length; var m = []; var Ij = []; for (var v1 = 0; v1 < v2; v1++) { var Z = k[v1]; var v3 = Z.step(v, Ik); if (v3) { m.push(v3); Ij.push(Z) } } for (var v1 = 0; v1 < v2;) { if (k[v1]._needsRemove) { k[v1] = k[v2 - 1]; k.pop(); v2-- } else { v1++ } } v2 = m.length; for (var v1 = 0; v1 < v2; v1++) { Ij[v1].fire(m[v1]) } this._time = v; this.onframe(Ik); this.trigger("frame", Ik); if (this.stage.update) { this.stage.update() } }, _startLoop: function () { var e = this; this._running = true; function i() { if (e._running) { nu(i); !e._paused && e._update() } } nu(i) }, start: function () { this._time = new Date().getTime(); this._pausedTime = 0; this._startLoop() }, stop: function () { this._running = false }, pause: function () { if (!this._paused) { this._pauseStart = new Date().getTime(); this._paused = true } }, resume: function () { if (this._paused) { this._pausedTime += (new Date().getTime()) - this._pauseStart; this._paused = false } }, clear: function () { this._clips = [] }, isFinished: function () { return !this._clips.length }, animate: function (k, i) { i = i || {}; var e = new gN(k, i.loop, i.getter, i.setter); this.addAnimator(e); return e } }; Gq(x1, Gc); var an = function () { this._track = [] }; an.prototype = { constructor: an, recognize: function (i, k, e) { this._doTrack(i, k, e); return this._recognize(i) }, clear: function () { this._track.length = 0; return this }, _doTrack: function (e, v1, Ij) { var v = e.touches; if (!v) { return } var v3 = { points: [], touches: [], target: v1, event: e }; for (var m = 0, Z = v.length; m < Z; m++) { var k = v[m]; var v2 = BV(Ij, k, {}); v3.points.push([v2.zrX, v2.zrY]); v3.touches.push(k) } this._track.push(v3) }, _recognize: function (i) { for (var e in X) { if (X.hasOwnProperty(e)) { var k = X[e](this._track, i); if (k) { return k } } } } }; function dw(k) { var i = k[1][0] - k[0][0]; var e = k[1][1] - k[0][1]; return Math.sqrt(i * i + e * e) } function h5(e) { return [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2] } var X = { pinch: function (k, Z) { var i = k.length; if (!i) { return } var v1 = (k[i - 1] || {}).points; var m = (k[i - 2] || {}).points || v1; if (m && m.length > 1 && v1 && v1.length > 1) { var v = dw(v1) / dw(m); !isFinite(v) && (v = 1); Z.pinchScale = v; var e = h5(v1); Z.pinchX = e[0]; Z.pinchY = e[1]; return { type: "pinch", target: k[0].target, event: Z } } } }; var iS = 300; var iG = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"]; var n5 = ["touchstart", "touchend", "touchmove"]; var fW = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }; var mt = Ef(iG, function (i) { var e = i.replace("mouse", "pointer"); return fW[e] ? e : i }); function x4(e) { return (e === "mousewheel" && sW.browser.firefox) ? "DOMMouseScroll" : e } function r(i, m, e) { var v = i._gestureMgr; e === "start" && v.clear(); var Z = v.recognize(m, i.handler.findHover(m.zrX, m.zrY, null).target, i.dom); e === "end" && v.clear(); if (Z) { var k = Z.type; m.gestureEvent = k; i.handler.dispatchToElement({ target: Z.target }, k, Z.event) } } function qJ(e) { e._touching = true; clearTimeout(e._touchTimer); e._touchTimer = setTimeout(function () { e._touching = false }, 700) } var Dl = { mousemove: function (e) { e = Bc(this.dom, e); this.trigger("mousemove", e) }, mouseout: function (i) { i = Bc(this.dom, i); var e = i.toElement || i.relatedTarget; if (e != this.dom) { while (e && e.nodeType != 9) { if (e === this.dom) { return } e = e.parentNode } } this.trigger("mouseout", i) }, touchstart: function (e) { e = Bc(this.dom, e); e.zrByTouch = true; this._lastTouchMoment = new Date(); r(this, e, "start"); Dl.mousemove.call(this, e); Dl.mousedown.call(this, e); qJ(this) }, touchmove: function (e) { e = Bc(this.dom, e); e.zrByTouch = true; r(this, e, "change"); Dl.mousemove.call(this, e); qJ(this) }, touchend: function (e) { e = Bc(this.dom, e); e.zrByTouch = true; r(this, e, "end"); Dl.mouseup.call(this, e); if (+new Date() - this._lastTouchMoment < iS) { Dl.click.call(this, e) } qJ(this) }, pointerdown: function (e) { Dl.mousedown.call(this, e) }, pointermove: function (e) { if (!BY(e)) { Dl.mousemove.call(this, e) } }, pointerup: function (e) { Dl.mouseup.call(this, e) }, pointerout: function (e) { if (!BY(e)) { Dl.mouseout.call(this, e) } } }; function BY(i) { var e = i.pointerType; return e === "pen" || e === "touch" } o9(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (e) { Dl[e] = function (i) { i = Bc(this.dom, i); this.trigger(e, i) } }); function f3(e) { o9(n5, function (k) { e._handlers[k] = km(Dl[k], e) }); o9(mt, function (k) { e._handlers[k] = km(Dl[k], e) }); o9(iG, function (k) { e._handlers[k] = i(Dl[k], e) }); function i(m, k) { return function () { if (k._touching) { return } return m.apply(k, arguments) } } } function j8(i) {
    Gc.call(this); this.dom = i; this._touching = false; this._touchTimer; this._gestureMgr = new an();
    this._handlers = {}; f3(this); if (sW.pointerEventsSupported) { e(mt, this) } else { if (sW.touchEventsSupported) { e(n5, this) } e(iG, this) } function e(m, k) { o9(m, function (v) { fr(i, x4(v), k._handlers[v]) }, k) }
  } var kf = j8.prototype; kf.dispose = function () { var m = iG.concat(n5); for (var k = 0; k < m.length; k++) { var e = m[k]; qz(this.dom, x4(e), this._handlers[e]) } }; kf.setCursor = function (e) { this.dom.style && (this.dom.style.cursor = e || "default") }; Gq(j8, Gc);
  /*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  */
  var rN = !sW.canvasSupported; var vq = { canvas: aQ }; var gw = {}; var s5 = "4.0.4"; function nE(k, e) { var i = new jS(dq(), k, e); gw[i.id] = i; return i } function CF(i) { if (i) { i.dispose() } else { for (var e in gw) { if (gw.hasOwnProperty(e)) { gw[e].dispose() } } gw = {} } return this } function xJ(e) { return gw[e] } function w3(i, e) { vq[i] = e } function iv(e) { delete gw[e] } var jS = function (k, v, i) { i = i || {}; this.dom = v; this.id = k; var Ij = this; var Z = new dv(); var v1 = i.renderer; if (rN) { if (!vq.vml) { throw new Error("You need to require 'zrender/vml/vml' to support IE8") } v1 = "vml" } else { if (!v1 || !vq[v1]) { v1 = "canvas" } } var v2 = new vq[v1](v, Z, i, k); this.storage = Z; this.painter = v2; var m = (!sW.node && !sW.worker) ? new j8(v2.getViewportRoot()) : null; this.handler = new ev(Z, v2, m, v2.root); this.animation = new x1({ stage: { update: km(this.flush, this) } }); this.animation.start(); this._needsRefresh; var e = Z.delFromStorage; var v3 = Z.addToStorage; Z.delFromStorage = function (Ik) { e.call(Z, Ik); Ik && Ik.removeSelfFromZr(Ij) }; Z.addToStorage = function (Ik) { v3.call(Z, Ik); Ik.addSelfToZr(Ij) } }; jS.prototype = { constructor: jS, getId: function () { return this.id }, add: function (e) { this.storage.addRoot(e); this._needsRefresh = true }, remove: function (e) { this.storage.delRoot(e); this._needsRefresh = true }, configLayer: function (i, e) { if (this.painter.configLayer) { this.painter.configLayer(i, e) } this._needsRefresh = true }, setBackgroundColor: function (e) { if (this.painter.setBackgroundColor) { this.painter.setBackgroundColor(e) } this._needsRefresh = true }, refreshImmediately: function () { this._needsRefresh = false; this.painter.refresh(); this._needsRefresh = false }, refresh: function () { this._needsRefresh = true }, flush: function () { var e; if (this._needsRefresh) { e = true; this.refreshImmediately() } if (this._needsRefreshHover) { e = true; this.refreshHoverImmediately() } e && this.trigger("rendered") }, addHover: function (i, e) { if (this.painter.addHover) { var k = this.painter.addHover(i, e); this.refreshHover(); return k } }, removeHover: function (e) { if (this.painter.removeHover) { this.painter.removeHover(e); this.refreshHover() } }, clearHover: function () { if (this.painter.clearHover) { this.painter.clearHover(); this.refreshHover() } }, refreshHover: function () { this._needsRefreshHover = true }, refreshHoverImmediately: function () { this._needsRefreshHover = false; this.painter.refreshHover && this.painter.refreshHover() }, resize: function (e) { e = e || {}; this.painter.resize(e.width, e.height); this.handler.resize() }, clearAnimation: function () { this.animation.clear() }, getWidth: function () { return this.painter.getWidth() }, getHeight: function () { return this.painter.getHeight() }, pathToImage: function (k, i) { return this.painter.pathToImage(k, i) }, setCursorStyle: function (e) { this.handler.setCursorStyle(e) }, findHover: function (e, i) { return this.handler.findHover(e, i) }, on: function (e, k, i) { this.handler.on(e, k, i) }, off: function (e, i) { this.handler.off(e, i) }, trigger: function (e, i) { this.handler.trigger(e, i) }, clear: function () { this.storage.delRoot(); this.painter.clear() }, dispose: function () { this.animation.stop(); this.clear(); this.storage.dispose(); this.painter.dispose(); this.handler.dispose(); this.animation = this.storage = this.painter = this.handler = null; iv(this.id) } }; var lq = (Object.freeze || Object)({ version: s5, init: nE, dispose: CF, getInstance: xJ, registerPainter: w3 }); var o8 = o9; var tI = tJ; var Ii = GG; var uC = "series\0"; function mp(e) { return e instanceof Array ? e : e == null ? [] : [e] } function DA(v, m, v1) { if (v) { v[m] = v[m] || {}; v.emphasis = v.emphasis || {}; v.emphasis[m] = v.emphasis[m] || {}; for (var k = 0, e = v1.length; k < e; k++) { var Z = v1[k]; if (!v.emphasis[m].hasOwnProperty(Z) && v[m].hasOwnProperty(Z)) { v.emphasis[m][Z] = v[m][Z] } } } } var Bl = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"]; function xW(e) { return (tI(e) && !Ii(e) && !(e instanceof Date)) ? e.value : e } function oa(e) { return tI(e) && !(e instanceof Array) } function c9(k, i) {
    i = (i || []).slice(); var e = Ef(k || [], function (v, m) { return { exist: v } }); o8(i, function (m, v) {
      if (!tI(m)) { return } for (var Z = 0; Z < e.length; Z++) { if (!e[Z].option && m.id != null && e[Z].exist.id === m.id + "") { e[Z].option = m; i[v] = null; return } } for (var Z = 0; Z < e.length; Z++) {
        var v1 = e[Z].exist; if (!e[Z].option && (v1.id == null || m.id == null) && m.name != null && !HF(m) && !HF(v1) && v1.name === m.name + "") {
          e[Z].option = m; i[v] = null;
          return
        }
      }
    }); o8(i, function (m, v) { if (!tI(m)) { return } var Z = 0; for (; Z < e.length; Z++) { var v1 = e[Z].exist; if (!e[Z].option && !HF(v1) && m.id == null) { e[Z].option = m; break } } if (Z >= e.length) { e.push({ option: m }) } }); return e
  } function z3(i) { var e = CJ(); o8(i, function (v, k) { var m = v.exist; m && e.set(m.id, v) }); o8(i, function (v, k) { var m = v.option; bM(!m || m.id == null || !e.get(m.id) || e.get(m.id) === v, "id duplicates: " + (m && m.id)); m && m.id != null && e.set(m.id, v); !v.keyInfo && (v.keyInfo = {}) }); o8(i, function (Z, k) { var v = Z.exist; var m = Z.option; var v2 = Z.keyInfo; if (!tI(m)) { return } v2.name = m.name != null ? m.name + "" : v ? v.name : uC + k; if (v) { v2.id = v.id } else { if (m.id != null) { v2.id = m.id + "" } else { var v1 = 0; do { v2.id = "\0" + v2.name + "\0" + v1++ } while (e.get(v2.id)) } } e.set(v2.id, Z) }) } function qV(e) { var i = e.name; return !!(i && i.indexOf(uC)) } function HF(e) { return tI(e) && e.id && (e.id + "").indexOf("\0_ec_\0") === 0 } function co(v, m) { var k = {}; var e = {}; Z(v || [], k); Z(m || [], e, k); return [i(k), i(e)]; function Z(Ik, Iq, Il) { for (var Ij = 0, Im = Ik.length; Ij < Im; Ij++) { var Io = Ik[Ij].seriesId; var v2 = mp(Ik[Ij].dataIndex); var v1 = Il && Il[Io]; for (var v3 = 0, Ip = v2.length; v3 < Ip; v3++) { var In = v2[v3]; if (v1 && v1[In]) { v1[In] = null } else { (Iq[Io] || (Iq[Io] = {}))[In] = 1 } } } } function i(v3, Ik) { var v1 = []; for (var v2 in v3) { if (v3.hasOwnProperty(v2) && v3[v2] != null) { if (Ik) { v1.push(+v2) } else { var Ij = i(v3[v2], true); Ij.length && v1.push({ seriesId: v2, dataIndex: Ij }) } } } return v1 } } function xe(e, i) { if (i.dataIndexInside != null) { return i.dataIndexInside } else { if (i.dataIndex != null) { return GG(i.dataIndex) ? Ef(i.dataIndex, function (k) { return e.indexOfRawIndex(k) }) : e.indexOfRawIndex(i.dataIndex) } else { if (i.name != null) { return GG(i.name) ? Ef(i.name, function (k) { return e.indexOfName(k) }) : e.indexOfName(i.name) } } } } function fK() { var e = "__\0ec_inner_" + j++ + "_" + Math.random().toFixed(5); return function (i) { return i[e] || (i[e] = {}) } } var j = 0; function nF(i, v, k) { if (wb(v)) { var m = {}; m[v + "Index"] = 0; v = m } var Z = k && k.defaultMainType; if (Z && !oz(v, Z + "Index") && !oz(v, Z + "Id") && !oz(v, Z + "Name")) { v[Z + "Index"] = 0 } var e = {}; o8(v, function (Ik, v2) { var Ik = v[v2]; if (v2 === "dataIndex" || v2 === "dataIndexInside") { e[v2] = Ik; return } var Ij = v2.match(/^(\w+)(Index|Id|Name)$/) || []; var Im = Ij[1]; var v1 = (Ij[2] || "").toLowerCase(); if (!Im || !v1 || Ik == null || (v1 === "index" && Ik === "none") || (k && k.includeMainTypes && eP(k.includeMainTypes, Im) < 0)) { return } var v3 = { mainType: Im }; if (v1 !== "index" || Ik !== "all") { v3[v1] = Ik } var Il = i.queryComponents(v3); e[Im + "Models"] = Il; e[Im + "Model"] = Il[0] }); return e } function oz(e, i) { return e && e.hasOwnProperty(i) } function bU(k, e, i) { k.setAttribute ? k.setAttribute(e, i) : (k[e] = i) } function vN(i, e) { return i.getAttribute ? i.getAttribute(e) : i[e] } function wg(e) { if (e === "auto") { return sW.domSupported ? "html" : "richText" } else { return e || "html" } } var HT = "."; var i2 = "___EC__COMPONENT__CONTAINER___"; function pd(i) { var e = { main: "", sub: "" }; if (i) { i = i.split(HT); e.main = i[0] || ""; e.sub = i[1] || "" } return e } function uG(e) { bM(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal') } function AG(i, e) { i.$constructor = i; i.extend = function (m) { if (ok) { o9(e, function (Z) { if (!m[Z]) { console.warn("Method `" + Z + "` should be implemented" + (m.type ? " in " + m.type : "") + ".") } }) } var k = this; var v = function () { if (!m.$constructor) { k.apply(this, arguments) } else { m.$constructor.apply(this, arguments) } }; b0(v.prototype, m); v.extend = this.extend; v.superCall = kF; v.superApply = yy; mr(v, this); v.superClass = k; return v } } var cl = 0; function z6(e) { var i = ["__\0is_clz", cl++, Math.random().toFixed(3)].join("_"); e.prototype[i] = true; if (ok) { bM(!e.isInstance, 'The method "is" can not be defined.') } e.isInstance = function (k) { return !!(k && k[i]) } } function kF(k, e) { var i = h7(arguments, 2); return this.superClass.prototype[e].apply(k, i) } function yy(k, e, i) { return this.superClass.prototype[e].apply(k, i) } function yk(e, i) { i = i || {}; var v = {}; e.registerClass = function (v2, v1) { if (v1) { uG(v1); v1 = pd(v1); if (!v1.sub) { if (ok) { if (v[v1.main]) { console.warn(v1.main + " exists.") } } v[v1.main] = v2 } else { if (v1.sub !== i2) { var Z = m(v1); Z[v1.sub] = v2 } } } return v2 }; e.getClass = function (Z, v2, v3) { var v1 = v[Z]; if (v1 && v1[i2]) { v1 = v2 ? v1[v2] : null } if (v3 && !v1) { throw new Error(!v2 ? Z + "." + "type should be specified." : "Component " + Z + "." + (v2 || "") + " not exists. Load it first.") } return v1 }; e.getClassesByMainType = function (v1) { v1 = pd(v1); var Z = []; var v2 = v[v1.main]; if (v2 && v2[i2]) { o9(v2, function (Ij, v3) { v3 !== i2 && Z.push(Ij) }) } else { Z.push(v2) } return Z }; e.hasClass = function (Z) { Z = pd(Z); return !!v[Z.main] }; e.getAllClassMainTypes = function () { var Z = []; o9(v, function (v2, v1) { Z.push(v1) }); return Z }; e.hasSubTypes = function (Z) { Z = pd(Z); var v1 = v[Z.main]; return v1 && v1[i2] }; e.parseClassType = pd; function m(v1) { var Z = v[v1.main]; if (!Z || !Z[i2]) { Z = v[v1.main] = {}; Z[i2] = true } return Z } if (i.registerWhenExtend) { var k = e.extend; if (k) { e.extend = function (Z) { var v1 = k.call(this, Z); return e.registerClass(v1, Z.type) } } } return e } var yO = function (k) { for (var e = 0; e < k.length; e++) { if (!k[e][1]) { k[e][1] = k[e][0] } } return function (m, Ij, Z) { var v1 = {}; for (var v = 0; v < k.length; v++) { var v2 = k[v][1]; if ((Ij && eP(Ij, v2) >= 0) || (Z && eP(Z, v2) < 0)) { continue } var v3 = m.getShallow(v2); if (v3 != null) { v1[k[v][0]] = v3 } } return v1 } }; var kh = yO([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
  var df = { getLineStyle: function (k) { var i = kh(this, k); var e = this.getLineDash(i.lineWidth); e && (i.lineDash = e); return i }, getLineDash: function (i) { if (i == null) { i = 1 } var m = this.get("type"); var k = Math.max(i, 2); var e = i * 4; return (m === "solid" || m == null) ? null : (m === "dashed" ? [e, e] : [k, k]) } }; var T = yO([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]); var fX = { getAreaStyle: function (i, e) { return T(this, i, e) } }; var wU = Math.pow; var hk = Math.sqrt; var lp = 1e-8; var Cy = 0.0001; var bG = hk(3); var bP = 1 / 3; var bt = G7(); var bs = G7(); var bq = G7(); function Go(e) { return e > -lp && e < lp } function vF(e) { return e > lp || e < -lp } function aS(Z, v, m, k, e) { var i = 1 - e; return i * i * (i * Z + 3 * e * v) + e * e * (e * k + 3 * i * m) } function gV(Z, v, m, k, e) { var i = 1 - e; return 3 * (((v - Z) * i + 2 * (m - v) * e) * i + (k - m) * e * e) } function c3(Z, v, m, i, Iz, Ik) { var Iy = i + 3 * (v - m) - Z; var Ix = 3 * (m - v * 2 + Z); var Iw = 3 * (v - Z); var Iu = Z - Iz; var Is = Ix * Ix - 3 * Iy * Iw; var Ir = Ix * Iw - 9 * Iy * Iu; var Iq = Iw * Iw - 3 * Ix * Iu; var It = 0; if (Go(Is) && Go(Ir)) { if (Go(Ix)) { Ik[0] = 0 } else { var Ip = -Iw / Ix; if (Ip >= 0 && Ip <= 1) { Ik[It++] = Ip } } } else { var e = Ir * Ir - 4 * Is * Iq; if (Go(e)) { var In = Ir / Is; var Ip = -Ix / Iy + In; var Io = -In / 2; if (Ip >= 0 && Ip <= 1) { Ik[It++] = Ip } if (Io >= 0 && Io <= 1) { Ik[It++] = Io } } else { if (e > 0) { var k = hk(e); var v3 = Is * Ix + 1.5 * Iy * (-Ir + k); var v2 = Is * Ix + 1.5 * Iy * (-Ir - k); if (v3 < 0) { v3 = -wU(-v3, bP) } else { v3 = wU(v3, bP) } if (v2 < 0) { v2 = -wU(-v2, bP) } else { v2 = wU(v2, bP) } var Ip = (-Ix - (v3 + v2)) / (3 * Iy); if (Ip >= 0 && Ip <= 1) { Ik[It++] = Ip } } else { var v1 = (2 * Is * Ix - 3 * Iy * Ir) / (2 * hk(Is * Is * Is)); var Il = Math.acos(v1) / 3; var Ij = hk(Is); var Iv = Math.cos(Il); var Ip = (-Ix - 2 * Ij * Iv) / (3 * Iy); var Io = (-Ix + Ij * (Iv + bG * Math.sin(Il))) / (3 * Iy); var Im = (-Ix + Ij * (Iv - bG * Math.sin(Il))) / (3 * Iy); if (Ip >= 0 && Ip <= 1) { Ik[It++] = Ip } if (Io >= 0 && Io <= 1) { Ik[It++] = Io } if (Im >= 0 && Im <= 1) { Ik[It++] = Im } } } } return It } function Em(Il, Ik, Ij, v3, v) { var v1 = 6 * Ij - 12 * Ik + 6 * Il; var v2 = 9 * Ik + 3 * v3 - 3 * Il - 9 * Ij; var Z = 3 * Ik - 3 * Il; var e = 0; if (Go(v2)) { if (vF(v1)) { var m = -Z / v1; if (m >= 0 && m <= 1) { v[e++] = m } } } else { var i = v1 * v1 - 4 * v2 * Z; if (Go(i)) { v[0] = -v1 / (2 * v2) } else { if (i > 0) { var Im = hk(i); var m = (-v1 + Im) / (2 * v2); var k = (-v1 - Im) / (2 * v2); if (m >= 0 && m <= 1) { v[e++] = m } if (k >= 0 && k <= 1) { v[e++] = k } } } } return e } function gn(Ij, v3, v2, v1, Ik, i) { var k = (v3 - Ij) * Ik + Ij; var e = (v2 - v3) * Ik + v3; var m = (v1 - v2) * Ik + v2; var Il = (e - k) * Ik + k; var Z = (m - e) * Ik + e; var v = (Z - Il) * Ik + Il; i[0] = Ij; i[1] = k; i[2] = Il; i[3] = v; i[4] = v; i[5] = Z; i[6] = m; i[7] = v1 } function q3(Ip, v, Io, m, In, k, Im, e, v1, Z, Il) { var v2; var Is = 0.005; var Ir = Infinity; var v3; var Ij; var Iu; var It; bt[0] = v1; bt[1] = Z; for (var Iq = 0; Iq < 1; Iq += 0.05) { bs[0] = aS(Ip, Io, In, Im, Iq); bs[1] = aS(v, m, k, e, Iq); Iu = ck(bt, bs); if (Iu < Ir) { v2 = Iq; Ir = Iu } } Ir = Infinity; for (var Ik = 0; Ik < 32; Ik++) { if (Is < Cy) { break } v3 = v2 - Is; Ij = v2 + Is; bs[0] = aS(Ip, Io, In, Im, v3); bs[1] = aS(v, m, k, e, v3); Iu = ck(bs, bt); if (v3 >= 0 && Iu < Ir) { v2 = v3; Ir = Iu } else { bq[0] = aS(Ip, Io, In, Im, Ij); bq[1] = aS(v, m, k, e, Ij); It = ck(bq, bt); if (Ij <= 1 && It < Ir) { v2 = Ij; Ir = It } else { Is *= 0.5 } } } if (Il) { Il[0] = aS(Ip, Io, In, Im, v2); Il[1] = aS(v, m, k, e, v2) } return hk(Ir) } function kw(v, m, k, e) { var i = 1 - e; return i * (i * v + 2 * e * m) + e * e * k } function vw(m, k, i, e) { return 2 * ((1 - e) * (k - m) + e * (i - k)) } function sc(Il, Ij, v3, i, Ik) { var v2 = Il - 2 * Ij + v3; var v1 = 2 * (Ij - Il); var Z = Il - i; var e = 0; if (Go(v2)) { if (vF(v1)) { var v = -Z / v1; if (v >= 0 && v <= 1) { Ik[e++] = v } } } else { var k = v1 * v1 - 4 * v2 * Z; if (Go(k)) { var v = -v1 / (2 * v2); if (v >= 0 && v <= 1) { Ik[e++] = v } } else { if (k > 0) { var Im = hk(k); var v = (-v1 + Im) / (2 * v2); var m = (-v1 - Im) / (2 * v2); if (v >= 0 && v <= 1) { Ik[e++] = v } if (m >= 0 && m <= 1) { Ik[e++] = m } } } } return e } function wm(m, k, i) { var e = m + i - 2 * k; if (e === 0) { return 0.5 } else { return (m - k) / e } } function ED(v2, v1, Z, k, i) { var m = (v1 - v2) * k + v2; var v = (Z - v1) * k + v1; var e = (v - m) * k + m; i[0] = v2; i[1] = m; i[2] = e; i[3] = e; i[4] = v; i[5] = Z } function Fi(In, m, Im, k, Il, e, Z, v, Ik) { var v1; var Iq = 0.005; var Ip = Infinity; bt[0] = Z; bt[1] = v; for (var Io = 0; Io < 1; Io += 0.05) { bs[0] = kw(In, Im, Il, Io); bs[1] = kw(m, k, e, Io); var Is = ck(bt, bs); if (Is < Ip) { v1 = Io; Ip = Is } } Ip = Infinity; for (var Ij = 0; Ij < 32; Ij++) { if (Iq < Cy) { break } var v2 = v1 - Iq; var v3 = v1 + Iq; bs[0] = kw(In, Im, Il, v2); bs[1] = kw(m, k, e, v2); var Is = ck(bs, bt); if (v2 >= 0 && Is < Ip) { v1 = v2; Ip = Is } else { bq[0] = kw(In, Im, Il, v3); bq[1] = kw(m, k, e, v3); var Ir = ck(bq, bt); if (v3 <= 1 && Ir < Ip) { v1 = v3; Ip = Ir } else { Iq *= 0.5 } } } if (Ik) { Ik[0] = kw(In, Im, Il, v1); Ik[1] = kw(m, k, e, v1) } return hk(Ip) } var jv = Math.min; var AL = Math.max; var GW = Math.sin; var Ad = Math.cos; var gr = Math.PI * 2; var c = G7(); var hI = G7(); var eC = G7(); function oI(v2, v1, v3) { if (v2.length === 0) { return } var k = v2[0]; var m = k[0]; var Ij = k[0]; var Z = k[1]; var e = k[1]; var v; for (v = 1; v < v2.length; v++) { k = v2[v]; m = jv(m, k[0]); Ij = AL(Ij, k[0]); Z = jv(Z, k[1]); e = AL(e, k[1]) } v1[0] = m; v1[1] = Z; v3[0] = Ij; v3[1] = e } function ol(k, Z, e, v, m, i) { m[0] = jv(k, e); m[1] = jv(Z, v); i[0] = AL(k, e); i[1] = AL(Z, v) } var r2 = []; var CP = []; function ax(v, Ip, m, In, k, Ik, e, v3, Im, Iq) { var Io = Em; var v1 = aS; var v2; var Z = Io(v, m, k, e, r2); Im[0] = Infinity; Im[1] = Infinity; Iq[0] = -Infinity; Iq[1] = -Infinity; for (v2 = 0; v2 < Z; v2++) { var Il = v1(v, m, k, e, r2[v2]); Im[0] = jv(Il, Im[0]); Iq[0] = AL(Il, Iq[0]) } Z = Io(Ip, In, Ik, v3, CP); for (v2 = 0; v2 < Z; v2++) { var Ij = v1(Ip, In, Ik, v3, CP[v2]); Im[1] = jv(Ij, Im[1]); Iq[1] = AL(Ij, Iq[1]) } Im[0] = jv(v, Im[0]); Iq[0] = AL(v, Iq[0]); Im[0] = jv(e, Im[0]); Iq[0] = AL(e, Iq[0]); Im[1] = jv(Ip, Im[1]); Iq[1] = AL(Ip, Iq[1]); Im[1] = jv(v3, Im[1]); Iq[1] = AL(v3, Iq[1]) } function iZ(m, Im, k, Ik, e, v3, Il, In) {
    var i = wm; var v1 = kw; var Z = AL(jv(i(m, k, e), 1), 0);
    var v = AL(jv(i(Im, Ik, v3), 1), 0); var Ij = v1(m, k, e, Z); var v2 = v1(Im, Ik, v3, v); Il[0] = jv(m, e, Ij); Il[1] = jv(Im, v3, v2); In[0] = AL(m, e, Ij); In[1] = AL(Im, v3, v2)
  } function rg(Ik, v3, i, e, v2, m, v, Ij, In) { var Im = Bu; var k = D5; var Il = Math.abs(v2 - m); if (Il % gr < 0.0001 && Il > 0.0001) { Ij[0] = Ik - i; Ij[1] = v3 - e; In[0] = Ik + i; In[1] = v3 + e; return } c[0] = Ad(v2) * i + Ik; c[1] = GW(v2) * e + v3; hI[0] = Ad(m) * i + Ik; hI[1] = GW(m) * e + v3; Im(Ij, c, hI); k(In, c, hI); v2 = v2 % (gr); if (v2 < 0) { v2 = v2 + gr } m = m % (gr); if (m < 0) { m = m + gr } if (v2 > m && !v) { m += gr } else { if (v2 < m && v) { v2 += gr } } if (v) { var v1 = m; m = v2; v2 = v1 } for (var Z = 0; Z < m; Z += Math.PI / 2) { if (Z > v2) { eC[0] = Ad(Z) * i + Ik; eC[1] = GW(Z) * e + v3; Im(Ij, eC, Ij); k(In, eC, In) } } } var g7 = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }; var Bh = []; var io = []; var vB = []; var at = []; var jw = Math.min; var AM = Math.max; var Ag = Math.cos; var GY = Math.sin; var hl = Math.sqrt; var qP = Math.abs; var vL = typeof Float32Array != "undefined"; var j5 = function (e) { this._saveData = !(e || false); if (this._saveData) { this.data = [] } this._ctx = null }; j5.prototype = {
    constructor: j5, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function (i, e) { this._ux = qP(1 / h3 / i) || 0; this._uy = qP(1 / h3 / e) || 0 }, getContext: function () { return this._ctx }, beginPath: function (e) { this._ctx = e; e && e.beginPath(); e && (this.dpr = e.dpr); if (this._saveData) { this._len = 0 } if (this._lineDash) { this._lineDash = null; this._dashOffset = 0 } return this }, moveTo: function (e, i) { this.addData(g7.M, e, i); this._ctx && this._ctx.moveTo(e, i); this._x0 = e; this._y0 = i; this._xi = e; this._yi = i; return this }, lineTo: function (e, k) { var i = qP(e - this._xi) > this._ux || qP(k - this._yi) > this._uy || this._len < 5; this.addData(g7.L, e, k); if (this._ctx && i) { this._needsDash() ? this._dashedLineTo(e, k) : this._ctx.lineTo(e, k) } if (i) { this._xi = e; this._yi = k } return this }, bezierCurveTo: function (m, Z, i, v, e, k) { this.addData(g7.C, m, Z, i, v, e, k); if (this._ctx) { this._needsDash() ? this._dashedBezierTo(m, Z, i, v, e, k) : this._ctx.bezierCurveTo(m, Z, i, v, e, k) } this._xi = e; this._yi = k; return this }, quadraticCurveTo: function (i, m, e, k) { this.addData(g7.Q, i, m, e, k); if (this._ctx) { this._needsDash() ? this._dashedQuadraticTo(i, m, e, k) : this._ctx.quadraticCurveTo(i, m, e, k) } this._xi = e; this._yi = k; return this }, arc: function (e, Z, m, k, i, v) { this.addData(g7.A, e, Z, m, m, k, i - k, 0, v ? 0 : 1); this._ctx && this._ctx.arc(e, Z, m, k, i, v); this._xi = Ag(i) * m + e; this._yi = GY(i) * m + Z; return this }, arcTo: function (k, v, i, m, e) { if (this._ctx) { this._ctx.arcTo(k, v, i, m, e) } return this }, rect: function (e, m, i, k) { this._ctx && this._ctx.rect(e, m, i, k); this.addData(g7.R, e, m, i, k); return this }, closePath: function () { this.addData(g7.Z); var e = this._ctx; var i = this._x0; var k = this._y0; if (e) { this._needsDash() && this._dashedLineTo(i, k); e.closePath() } this._xi = i; this._yi = k; return this }, fill: function (e) { e && e.fill(); this.toStatic() }, stroke: function (e) { e && e.stroke(); this.toStatic() }, setLineDash: function (e) { if (e instanceof Array) { this._lineDash = e; this._dashIdx = 0; var m = 0; for (var k = 0; k < e.length; k++) { m += e[k] } this._dashSum = m } return this }, setLineDashOffset: function (e) { this._dashOffset = e; return this }, len: function () { return this._len }, setData: function (m) { var k = m.length; if (!(this.data && this.data.length == k) && vL) { this.data = new Float32Array(k) } for (var e = 0; e < k; e++) { this.data[e] = m[e] } this._len = k }, appendPath: function (v2) { if (!(v2 instanceof Array)) { v2 = [v2] } var Z = v2.length; var m = 0; var v3 = this._len; for (var v = 0; v < Z; v++) { m += v2[v].len() } if (vL && (this.data instanceof Float32Array)) { this.data = new Float32Array(v3 + m) } for (var v = 0; v < Z; v++) { var v1 = v2[v].data; for (var e = 0; e < v1.length; e++) { this.data[v3++] = v1[e] } } this._len = v3 }, addData: function (m) { if (!this._saveData) { return } var k = this.data; if (this._len + arguments.length > k.length) { this._expandData(); k = this.data } for (var e = 0; e < arguments.length; e++) { k[this._len++] = arguments[e] } this._prevCmd = m }, _expandData: function () { if (!(this.data instanceof Array)) { var k = []; for (var e = 0; e < this._len; e++) { k[e] = this.data[e] } this.data = k } }, _needsDash: function () { return this._lineDash }, _dashedLineTo: function (e, Ik) { var v1 = this._dashSum; var Z = this._dashOffset; var v = this._lineDash; var Io = this._ctx; var i = this._xi; var Im = this._yi; var Ip = e - i; var In = Ik - Im; var m = hl(Ip * Ip + In * In); var Ij = i; var v3 = Im; var v2; var k = v.length; var Il; Ip /= m; In /= m; if (Z < 0) { Z = v1 + Z } Z %= v1; Ij -= Z * Ip; v3 -= Z * In; while ((Ip > 0 && Ij <= e) || (Ip < 0 && Ij >= e) || (Ip == 0 && ((In > 0 && v3 <= Ik) || (In < 0 && v3 >= Ik)))) { Il = this._dashIdx; v2 = v[Il]; Ij += Ip * v2; v3 += In * v2; this._dashIdx = (Il + 1) % k; if ((Ip > 0 && Ij < i) || (Ip < 0 && Ij > i) || (In > 0 && v3 < Im) || (In < 0 && v3 > Im)) { continue } Io[Il % 2 ? "moveTo" : "lineTo"](Ip >= 0 ? jw(Ij, e) : AM(Ij, e), In >= 0 ? jw(v3, Ik) : AM(v3, Ik)) } Ip = Ij - e; In = v3 - Ik; this._dashOffset = -hl(Ip * Ip + In * In) }, _dashedBezierTo: function (Iu, k, It, i, Is, e) {
      var Ir = this._dashSum; var v1 = this._dashOffset; var v = this._lineDash; var Iq = this._ctx; var Iv = this._xi; var m = this._yi; var Im; var Il; var Ik; var In = aS; var v3 = 0; var Io = this._dashIdx; var Ip = v.length; var Ij; var v2; var Z = 0; if (v1 < 0) { v1 = Ir + v1 } v1 %= Ir; for (Im = 0; Im < 1; Im += 0.1) { Il = In(Iv, Iu, It, Is, Im + 0.1) - In(Iv, Iu, It, Is, Im); Ik = In(m, k, i, e, Im + 0.1) - In(m, k, i, e, Im); v3 += hl(Il * Il + Ik * Ik) } for (; Io < Ip; Io++) { Z += v[Io]; if (Z > v1) { break } } Im = (Z - v1) / v3; while (Im <= 1) {
        Ij = In(Iv, Iu, It, Is, Im); v2 = In(m, k, i, e, Im); Io % 2 ? Iq.moveTo(Ij, v2) : Iq.lineTo(Ij, v2);
        Im += v[Io] / v3; Io = (Io + 1) % Ip
      } (Io % 2 !== 0) && Iq.lineTo(Is, e); Il = Is - Ij; Ik = e - v2; this._dashOffset = -hl(Il * Il + Ik * Ik)
    }, _dashedQuadraticTo: function (m, Z, i, v) { var e = i; var k = v; i = (i + 2 * m) / 3; v = (v + 2 * Z) / 3; m = (this._xi + 2 * m) / 3; Z = (this._yi + 2 * Z) / 3; this._dashedBezierTo(m, Z, i, v, e, k) }, toStatic: function () { var e = this.data; if (e instanceof Array) { e.length = this._len; if (vL) { this.data = new Float32Array(e) } } }, getBoundingRect: function () { Bh[0] = Bh[1] = vB[0] = vB[1] = Number.MAX_VALUE; io[0] = io[1] = at[0] = at[1] = -Number.MAX_VALUE; var Il = this.data; var Io = 0; var Ij = 0; var v = 0; var Iq = 0; for (var Im = 0; Im < Il.length;) { var v2 = Il[Im++]; if (Im == 1) { Io = Il[Im]; Ij = Il[Im + 1]; v = Io; Iq = Ij } switch (v2) { case g7.M: v = Il[Im++]; Iq = Il[Im++]; Io = v; Ij = Iq; vB[0] = v; vB[1] = Iq; at[0] = v; at[1] = Iq; break; case g7.L: ol(Io, Ij, Il[Im], Il[Im + 1], vB, at); Io = Il[Im++]; Ij = Il[Im++]; break; case g7.C: ax(Io, Ij, Il[Im++], Il[Im++], Il[Im++], Il[Im++], Il[Im], Il[Im + 1], vB, at); Io = Il[Im++]; Ij = Il[Im++]; break; case g7.Q: iZ(Io, Ij, Il[Im++], Il[Im++], Il[Im], Il[Im + 1], vB, at); Io = Il[Im++]; Ij = Il[Im++]; break; case g7.A: var Ik = Il[Im++]; var v3 = Il[Im++]; var m = Il[Im++]; var e = Il[Im++]; var In = Il[Im++]; var Z = Il[Im++] + In; var Ip = Il[Im++]; var v1 = 1 - Il[Im++]; if (Im == 1) { v = Ag(In) * m + Ik; Iq = GY(In) * e + v3 } rg(Ik, v3, m, e, In, Z, v1, vB, at); Io = Ag(Z) * m + Ik; Ij = GY(Z) * e + v3; break; case g7.R: v = Io = Il[Im++]; Iq = Ij = Il[Im++]; var k = Il[Im++]; var Ir = Il[Im++]; ol(v, Iq, v + k, Iq + Ir, vB, at); break; case g7.Z: Io = v; Ij = Iq; break }Bu(Bh, Bh, vB); D5(io, io, at) } if (Im === 0) { Bh[0] = Bh[1] = io[0] = io[1] = 0 } return new CH(Bh[0], Bh[1], io[0] - Bh[0], io[1] - Bh[1]) }, rebuildPath: function (Ir) { var Ix = this.data; var Iv, v; var Ip, IA; var Im, Il; var Ij = this._ux; var v2 = this._uy; var e = this._len; for (var It = 0; It < e;) { var Is = Ix[It++]; if (It == 1) { Ip = Ix[It]; IA = Ix[It + 1]; Iv = Ip; v = IA } switch (Is) { case g7.M: Iv = Ip = Ix[It++]; v = IA = Ix[It++]; Ir.moveTo(Ip, IA); break; case g7.L: Im = Ix[It++]; Il = Ix[It++]; if (qP(Im - Ip) > Ij || qP(Il - IA) > v2 || It === e - 1) { Ir.lineTo(Im, Il); Ip = Im; IA = Il } break; case g7.C: Ir.bezierCurveTo(Ix[It++], Ix[It++], Ix[It++], Ix[It++], Ix[It++], Ix[It++]); Ip = Ix[It - 2]; IA = Ix[It - 1]; break; case g7.Q: Ir.quadraticCurveTo(Ix[It++], Ix[It++], Ix[It++], Ix[It++]); Ip = Ix[It - 2]; IA = Ix[It - 1]; break; case g7.A: var m = Ix[It++]; var k = Ix[It++]; var v1 = Ix[It++]; var Z = Ix[It++]; var Ik = Ix[It++]; var Iu = Ix[It++]; var Iw = Ix[It++]; var v3 = Ix[It++]; var Io = (v1 > Z) ? v1 : Z; var Iz = (v1 > Z) ? 1 : v1 / Z; var Iy = (v1 > Z) ? Z / v1 : 1; var In = Math.abs(v1 - Z) > 0.001; var Iq = Ik + Iu; if (In) { Ir.translate(m, k); Ir.rotate(Iw); Ir.scale(Iz, Iy); Ir.arc(0, 0, Io, Ik, Iq, 1 - v3); Ir.scale(1 / Iz, 1 / Iy); Ir.rotate(-Iw); Ir.translate(-m, -k) } else { Ir.arc(m, k, Io, Ik, Iq, 1 - v3) } if (It == 1) { Iv = Ag(Ik) * v1 + m; v = GY(Ik) * Z + k } Ip = Ag(Iq) * v1 + m; IA = GY(Iq) * Z + k; break; case g7.R: Iv = Ip = Ix[It]; v = IA = Ix[It + 1]; Ir.rect(Ix[It++], Ix[It++], Ix[It++], Ix[It++]); break; case g7.Z: Ir.closePath(); Ip = Iv; IA = v } } }
  }; j5.CMD = g7; function qU(i, Ik, e, v3, v, Ij, v2) { if (v === 0) { return false } var k = v; var v1 = 0; var Z = i; if ((v2 > Ik + k && v2 > v3 + k) || (v2 < Ik - k && v2 < v3 - k) || (Ij > i + k && Ij > e + k) || (Ij < i - k && Ij < e - k)) { return false } if (i !== e) { v1 = (Ik - v3) / (i - e); Z = (i * v3 - e * Ik) / (i - e) } else { return Math.abs(Ij - i) <= k / 2 } var m = v1 * Ij - v2 + Z; var Il = m * m / (v1 * v1 + 1); return Il <= k / 2 * k / 2 } function qT(m, Im, k, Il, i, Ij, e, v2, Z, Ik, v3) { if (Z === 0) { return false } var v = Z; if ((v3 > Im + v && v3 > Il + v && v3 > Ij + v && v3 > v2 + v) || (v3 < Im - v && v3 < Il - v && v3 < Ij - v && v3 < v2 - v) || (Ik > m + v && Ik > k + v && Ik > i + v && Ik > e + v) || (Ik < m - v && Ik < k - v && Ik < i - v && Ik < e - v)) { return false } var v1 = q3(m, Im, k, Il, i, Ij, e, v2, Ik, v3, null); return v1 <= v / 2 } function qS(k, Ik, i, v3, e, v2, v, Ij, v1) { if (v === 0) { return false } var m = v; if ((v1 > Ik + m && v1 > v3 + m && v1 > v2 + m) || (v1 < Ik - m && v1 < v3 - m && v1 < v2 - m) || (Ij > k + m && Ij > i + m && Ij > e + m) || (Ij < k - m && Ij < i - m && Ij < e - m)) { return false } var Z = Fi(k, Ik, i, v3, e, v2, Ij, v1, null); return Z <= m / 2 } var G3 = Math.PI * 2; function Fv(e) { e %= G3; if (e < 0) { e += G3 } return e } var G4 = Math.PI * 2; function qQ(v1, Z, e, Ij, i, m, v3, Im, Il) { if (v3 === 0) { return false } var k = v3; Im -= v1; Il -= Z; var Ik = Math.sqrt(Im * Im + Il * Il); if ((Ik - k > e) || (Ik + k < e)) { return false } if (Math.abs(Ij - i) % G4 < 0.0001) { return true } if (m) { var v2 = Ij; Ij = Fv(i); i = Fv(v2) } else { Ij = Fv(Ij); i = Fv(i) } if (Ij > i) { i += G4 } var v = Math.atan2(Il, Im); if (v < 0) { v += G4 } return (v >= Ij && v <= i) || (v + G4 >= Ij && v + G4 <= i) } function mq(k, v2, i, Z, v1, v) { if ((v > v2 && v > Z) || (v < v2 && v < Z)) { return 0 } if (Z === v2) { return 0 } var m = Z < v2 ? 1 : -1; var v3 = (v - v2) / (Z - v2); if (v3 === 1 || v3 === 0) { m = Z < v2 ? 0.5 : -0.5 } var e = v3 * (i - k) + k; return e === v1 ? Infinity : e > v1 ? m : 0 } var FU = j5.CMD; var G5 = Math.PI * 2; var ln = 0.0001; function kg(i, e) { return Math.abs(i - e) < ln } var Cv = [-1, -1, -1]; var wO = [-1, -1]; function pU() { var e = wO[0]; wO[0] = wO[1]; wO[1] = e } function i9(It, Z, Ir, v, Iq, m, Ip, k, v3, v2) { if ((v2 > Z && v2 > v && v2 > m && v2 > k) || (v2 < Z && v2 < v && v2 < m && v2 < k)) { return 0 } var e = c3(Z, v, m, k, v2, Cv); if (e === 0) { return 0 } else { var Ij = 0; var In = -1; var v1, Im; for (var Io = 0; Io < e; Io++) { var Ik = Cv[Io]; var Il = (Ik === 0 || Ik === 1) ? 0.5 : 1; var Is = aS(It, Ir, Iq, Ip, Ik); if (Is < v3) { continue } if (In < 0) { In = Em(Z, v, m, k, wO); if (wO[1] < wO[0] && In > 1) { pU() } v1 = aS(Z, v, m, k, wO[0]); if (In > 1) { Im = aS(Z, v, m, k, wO[1]) } } if (In == 2) { if (Ik < wO[0]) { Ij += v1 < Z ? Il : -Il } else { if (Ik < wO[1]) { Ij += Im < v1 ? Il : -Il } else { Ij += k < Im ? Il : -Il } } } else { if (Ik < wO[0]) { Ij += v1 < Z ? Il : -Il } else { Ij += k < v1 ? Il : -Il } } } return Ij } } function q7(v, Io, m, Ik, e, v3, Il, v2) {
    if ((v2 > Io && v2 > Ik && v2 > v3) || (v2 < Io && v2 < Ik && v2 < v3)) { return 0 } var v1 = sc(Io, Ik, v3, v2, Cv); if (v1 === 0) {
      return 0
    } else { var Ip = wm(Io, Ik, v3); if (Ip >= 0 && Ip <= 1) { var In = 0; var Ij = kw(Io, Ik, v3, Ip); for (var Z = 0; Z < v1; Z++) { var Im = (Cv[Z] === 0 || Cv[Z] === 1) ? 0.5 : 1; var k = kw(v, m, e, Cv[Z]); if (k < Il) { continue } if (Cv[Z] < Ip) { In += Ij < Io ? Im : -Im } else { In += v3 < Ij ? Im : -Im } } return In } else { var Im = (Cv[0] === 0 || Cv[0] === 1) ? 0.5 : 1; var k = kw(v, m, e, Cv[0]); if (k < Il) { return 0 } return v3 < Io ? Im : -Im } }
  } function Di(v3, v2, e, Il, m, Z, In, Im) { Im -= v2; if (Im > e || Im < -e) { return 0 } var Ik = Math.sqrt(e * e - Im * Im); Cv[0] = -Ik; Cv[1] = Ik; var Ip = Math.abs(Il - m); if (Ip < 0.0001) { return 0 } if (Ip % G5 < 0.0001) { Il = 0; m = G5; var v = Z ? 1 : -1; if (In >= Cv[0] + v3 && In <= Cv[1] + v3) { return v } else { return 0 } } if (Z) { var Ik = Il; Il = Fv(m); m = Fv(Ik) } else { Il = Fv(Il); m = Fv(m) } if (Il > m) { m += G5 } var Io = 0; for (var Ij = 0; Ij < 2; Ij++) { var k = Cv[Ij]; if (k + v3 > In) { var v1 = Math.atan2(Im, k); var v = Z ? 1 : -1; if (v1 < 0) { v1 = G5 + v1 } if ((v1 >= Il && v1 <= m) || (v1 + G5 >= Il && v1 + G5 <= m)) { if (v1 > Math.PI / 2 && v1 < Math.PI * 1.5) { v = -v } Io += v } } } return Io } function BP(Iz, e, Iv, Il, Ik) { var Im = 0; var Io = 0; var Iy = 0; var Iw = 0; var v1 = 0; for (var Ir = 0; Ir < Iz.length;) { var Iq = Iz[Ir++]; if (Iq === FU.M && Ir > 1) { if (!Iv) { Im += mq(Io, Iy, Iw, v1, Il, Ik) } } if (Ir == 1) { Io = Iz[Ir]; Iy = Iz[Ir + 1]; Iw = Io; v1 = Iy } switch (Iq) { case FU.M: Iw = Iz[Ir++]; v1 = Iz[Ir++]; Io = Iw; Iy = v1; break; case FU.L: if (Iv) { if (qU(Io, Iy, Iz[Ir], Iz[Ir + 1], e, Il, Ik)) { return true } } else { Im += mq(Io, Iy, Iz[Ir], Iz[Ir + 1], Il, Ik) || 0 } Io = Iz[Ir++]; Iy = Iz[Ir++]; break; case FU.C: if (Iv) { if (qT(Io, Iy, Iz[Ir++], Iz[Ir++], Iz[Ir++], Iz[Ir++], Iz[Ir], Iz[Ir + 1], e, Il, Ik)) { return true } } else { Im += i9(Io, Iy, Iz[Ir++], Iz[Ir++], Iz[Ir++], Iz[Ir++], Iz[Ir], Iz[Ir + 1], Il, Ik) || 0 } Io = Iz[Ir++]; Iy = Iz[Ir++]; break; case FU.Q: if (Iv) { if (qS(Io, Iy, Iz[Ir++], Iz[Ir++], Iz[Ir], Iz[Ir + 1], e, Il, Ik)) { return true } } else { Im += q7(Io, Iy, Iz[Ir++], Iz[Ir++], Iz[Ir], Iz[Ir + 1], Il, Ik) || 0 } Io = Iz[Ir++]; Iy = Iz[Ir++]; break; case FU.A: var Z = Iz[Ir++]; var m = Iz[Ir++]; var v3 = Iz[Ir++]; var v2 = Iz[Ir++]; var Ij = Iz[Ir++]; var Iu = Iz[Ir++]; var Ix = Iz[Ir++]; var k = 1 - Iz[Ir++]; var It = Math.cos(Ij) * v3 + Z; var v = Math.sin(Ij) * v2 + m; if (Ir > 1) { Im += mq(Io, Iy, It, v, Il, Ik) } else { Iw = It; v1 = v } var Is = (Il - Z) * v2 / v3 + Z; if (Iv) { if (qQ(Z, m, v2, Ij, Ij + Iu, k, e, Is, Ik)) { return true } } else { Im += Di(Z, m, v2, Ij, Ij + Iu, k, Is, Ik) } Io = Math.cos(Ij + Iu) * v3 + Z; Iy = Math.sin(Ij + Iu) * v2 + m; break; case FU.R: Iw = Io = Iz[Ir++]; v1 = Iy = Iz[Ir++]; var Ip = Iz[Ir++]; var In = Iz[Ir++]; var It = Iw + Ip; var v = v1 + In; if (Iv) { if (qU(Iw, v1, It, v1, e, Il, Ik) || qU(It, v1, It, v, e, Il, Ik) || qU(It, v, Iw, v, e, Il, Ik) || qU(Iw, v, Iw, v1, e, Il, Ik)) { return true } } else { Im += mq(It, v1, It, v, Il, Ik); Im += mq(Iw, v, Iw, v1, Il, Ik) } break; case FU.Z: if (Iv) { if (qU(Io, Iy, Iw, v1, e, Il, Ik)) { return true } } else { Im += mq(Io, Iy, Iw, v1, Il, Ik) } Io = Iw; Iy = v1; break } } if (!Iv && !kg(Iy, v1)) { Im += mq(Io, Iy, Iw, v1, Il, Ik) || 0 } return Im !== 0 } function nf(i, e, k) { return BP(i, 0, false, e, k) } function e0(k, i, e, m) { return BP(k, i, true, e, m) } var qs = oY.prototype.getCanvasPattern; var u6 = Math.abs; var Hu = new j5(true); function mm(e) { Ie.call(this, e); this.path = null } mm.prototype = {
    constructor: mm, type: "path", __dirtyPath: true, strokeContainThreshold: 5, brush: function (Ij, v2) { var Il = this.style; var v3 = this.path || Hu; var Io = Il.hasStroke(); var v = Il.hasFill(); var Ik = Il.fill; var k = Il.stroke; var Im = v && !!(Ik.colorStops); var Iq = Io && !!(k.colorStops); var v1 = v && !!(Ik.image); var In = Io && !!(k.image); Il.bind(Ij, this, v2); this.setTransform(Ij); if (this.__dirty) { var e; if (Im) { e = e || this.getBoundingRect(); this._fillGradient = Il.getGradient(Ij, Ik, e) } if (Iq) { e = e || this.getBoundingRect(); this._strokeGradient = Il.getGradient(Ij, k, e) } } if (Im) { Ij.fillStyle = this._fillGradient } else { if (v1) { Ij.fillStyle = qs.call(Ik, Ij) } } if (Iq) { Ij.strokeStyle = this._strokeGradient } else { if (In) { Ij.strokeStyle = qs.call(k, Ij) } } var i = Il.lineDash; var Z = Il.lineDashOffset; var Ip = !!Ij.setLineDash; var Ir = this.getGlobalScale(); v3.setScale(Ir[0], Ir[1]); if (this.__dirtyPath || (i && !Ip && Io)) { v3.beginPath(Ij); if (i && !Ip) { v3.setLineDash(i); v3.setLineDashOffset(Z) } this.buildPath(v3, this.shape, false); if (this.path) { this.__dirtyPath = false } } else { Ij.beginPath(); this.path.rebuildPath(Ij) } if (v) { if (Il.fillOpacity != null) { var m = Ij.globalAlpha; Ij.globalAlpha = Il.fillOpacity * Il.opacity; v3.fill(Ij); Ij.globalAlpha = m } else { v3.fill(Ij) } } if (i && Ip) { Ij.setLineDash(i); Ij.lineDashOffset = Z } if (Io) { if (Il.strokeOpacity != null) { var m = Ij.globalAlpha; Ij.globalAlpha = Il.strokeOpacity * Il.opacity; v3.stroke(Ij); Ij.globalAlpha = m } else { v3.stroke(Ij) } } if (i && Ip) { Ij.setLineDash([]) } if (Il.text != null) { this.restoreTransform(Ij); this.drawRectText(Ij, this.getBoundingRect()) } }, buildPath: function (e, i, k) { }, createPathProxy: function () { this.path = new j5() }, getBoundingRect: function () { var v = this._rect; var m = this.style; var Z = !v; if (Z) { var v1 = this.path; if (!v1) { v1 = this.path = new j5() } if (this.__dirtyPath) { v1.beginPath(); this.buildPath(v1, this.shape, false) } v = v1.getBoundingRect() } this._rect = v; if (m.hasStroke()) { var k = this._rectWithStroke || (this._rectWithStroke = v.clone()); if (this.__dirty || Z) { k.copy(v); var e = m.lineWidth; var i = m.strokeNoScale ? this.getLineScale() : 1; if (!m.hasFill()) { e = Math.max(e, this.strokeContainThreshold || 4) } if (i > 1e-10) { k.width += e / i; k.height += e / i; k.x -= e / i / 2; k.y -= e / i / 2 } } return k } return v }, contain: function (i, v2) {
      var v1 = this.transformCoordToLocal(i, v2); var v = this.getBoundingRect(); var m = this.style; i = v1[0]; v2 = v1[1];
      if (v.contain(i, v2)) { var Z = this.path.data; if (m.hasStroke()) { var e = m.lineWidth; var k = m.strokeNoScale ? this.getLineScale() : 1; if (k > 1e-10) { if (!m.hasFill()) { e = Math.max(e, this.strokeContainThreshold) } if (e0(Z, e / k, i, v2)) { return true } } } if (m.hasFill()) { return nf(Z, i, v2) } } return false
    }, dirty: function (e) { if (e == null) { e = true } if (e) { this.__dirtyPath = e; this._rect = null } this.__dirty = this.__dirtyText = true; this.__zr && this.__zr.refresh(); if (this.__clipTarget) { this.__clipTarget.dirty() } }, animateShape: function (e) { return this.animate("shape", e) }, attrKV: function (e, i) { if (e === "shape") { this.setShape(i); this.__dirtyPath = true; this._rect = null } else { Ie.prototype.attrKV.call(this, e, i) } }, setShape: function (k, m) { var e = this.shape; if (e) { if (tJ(k)) { for (var i in k) { if (k.hasOwnProperty(i)) { e[i] = k[i] } } } else { e[k] = m } this.dirty(true) } return this }, getLineScale: function () { var e = this.transform; return e && u6(e[0] - 1) > 1e-10 && u6(e[3] - 1) > 1e-10 ? Math.sqrt(u6(e[0] * e[3] - e[2] * e[1])) : 1 }
  }; mm.extend = function (k) { var e = function (v) { mm.call(this, v); if (k.style) { this.style.extendFrom(k.style, false) } var v1 = k.shape; if (v1) { this.shape = this.shape || {}; var Z = this.shape; for (var m in v1) { if (!Z.hasOwnProperty(m) && v1.hasOwnProperty(m)) { Z[m] = v1[m] } } } k.init && k.init.call(this, v) }; mr(e, mm); for (var i in k) { if (i !== "style" && i !== "shape") { e.prototype[i] = k[i] } } return e }; mr(mm, Ie); var FS = j5.CMD; var BM = [[], [], []]; var hj = Math.sqrt; var t2 = Math.atan2; var sK = function (In, Iq) { var Iw = In.data; var It; var Ij; var Iu; var Is; var Ir; var Ip; var Z = FS.M; var Il = FS.C; var v1 = FS.L; var e = FS.R; var Io = FS.A; var v = FS.Q; for (Iu = 0, Is = 0; Iu < Iw.length;) { It = Iw[Iu++]; Is = Iu; Ij = 0; switch (It) { case Z: Ij = 1; break; case v1: Ij = 1; break; case Il: Ij = 3; break; case v: Ij = 2; break; case Io: var v3 = Iq[4]; var v2 = Iq[5]; var Im = hj(Iq[0] * Iq[0] + Iq[1] * Iq[1]); var Ik = hj(Iq[2] * Iq[2] + Iq[3] * Iq[3]); var Iv = t2(-Iq[1] / Ik, Iq[0] / Im); Iw[Iu] *= Im; Iw[Iu++] += v3; Iw[Iu] *= Ik; Iw[Iu++] += v2; Iw[Iu++] *= Im; Iw[Iu++] *= Ik; Iw[Iu++] += Iv; Iw[Iu++] += Iv; Iu += 2; Is = Iu; break; case e: Ip[0] = Iw[Iu++]; Ip[1] = Iw[Iu++]; aY(Ip, Ip, Iq); Iw[Is++] = Ip[0]; Iw[Is++] = Ip[1]; Ip[0] += Iw[Iu++]; Ip[1] += Iw[Iu++]; aY(Ip, Ip, Iq); Iw[Is++] = Ip[0]; Iw[Is++] = Ip[1] }for (Ir = 0; Ir < Ij; Ir++) { var Ip = BM[Ir]; Ip[0] = Iw[Iu++]; Ip[1] = Iw[Iu++]; aY(Ip, Ip, Iq); Iw[Is++] = Ip[0]; Iw[Is++] = Ip[1] } } }; var zM = Math.sqrt; var BH = Math.sin; var zF = Math.cos; var fc = Math.PI; var f9 = function (e) { return Math.sqrt(e[0] * e[0] + e[1] * e[1]) }; var cC = function (i, e) { return (i[0] * e[0] + i[1] * e[1]) / (f9(i) * f9(e)) }; var ke = function (i, e) { return (i[0] * e[1] < i[1] * e[0] ? -1 : 1) * Math.acos(cC(i, e)) }; function pB(Iu, m, It, i, Ir, Ij, v3, v2, Z, Is, Iq) { var Iy = Z * (fc / 180); var Il = zF(Iy) * (Iu - It) / 2 + BH(Iy) * (m - i) / 2; var Iv = -1 * BH(Iy) * (Iu - It) / 2 + zF(Iy) * (m - i) / 2; var Io = (Il * Il) / (v3 * v3) + (Iv * Iv) / (v2 * v2); if (Io > 1) { v3 *= zM(Io); v2 *= zM(Io) } var Ix = (Ir === Ij ? -1 : 1) * zM((((v3 * v3) * (v2 * v2)) - ((v3 * v3) * (Iv * Iv)) - ((v2 * v2) * (Il * Il))) / ((v3 * v3) * (Iv * Iv) + (v2 * v2) * (Il * Il))) || 0; var v1 = Ix * v3 * Iv / v2; var Ip = Ix * -v2 * Il / v3; var k = (Iu + It) / 2 + zF(Iy) * v1 - BH(Iy) * Ip; var e = (m + i) / 2 + BH(Iy) * v1 + zF(Iy) * Ip; var Ik = ke([1, 0], [(Il - v1) / v3, (Iv - Ip) / v2]); var In = [(Il - v1) / v3, (Iv - Ip) / v2]; var Im = [(-1 * Il - v1) / v3, (-1 * Iv - Ip) / v2]; var Iw = ke(In, Im); if (cC(In, Im) <= -1) { Iw = fc } if (cC(In, Im) >= 1) { Iw = 0 } if (Ij === 0 && Iw > 0) { Iw = Iw - 2 * fc } if (Ij === 1 && Iw < 0) { Iw = Iw + 2 * fc } Iq.addData(Is, k, e, v3, v2, Ik, Iw, Iy, Ij) } var oD = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; var m3 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; function lt(IC) {
    if (!IC) { return new j5() } var v3 = 0; var v2 = 0; var Ik = v3; var Ij = v2; var Ip; var Il = new j5(); var Iw = j5.CMD; var Z = IC.match(oD); for (var Io = 0; Io < Z.length; Io++) {
      var IA = Z[Io]; var k = IA.charAt(0); var Iq; var Im = IA.match(m3) || []; var Is = Im.length; for (var Ir = 0; Ir < Is; Ir++) { Im[Ir] = parseFloat(Im[Ir]) } var IB = 0; while (IB < Is) {
        var Iz; var Iy; var v; var m; var Ix; var In; var v1; var Iv = v3; var e = v2; switch (k) {
          case "l": v3 += Im[IB++]; v2 += Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "L": v3 = Im[IB++]; v2 = Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "m": v3 += Im[IB++]; v2 += Im[IB++]; Iq = Iw.M; Il.addData(Iq, v3, v2); Ik = v3; Ij = v2; k = "l"; break; case "M": v3 = Im[IB++]; v2 = Im[IB++]; Iq = Iw.M; Il.addData(Iq, v3, v2); Ik = v3; Ij = v2; k = "L"; break; case "h": v3 += Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "H": v3 = Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "v": v2 += Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "V": v2 = Im[IB++]; Iq = Iw.L; Il.addData(Iq, v3, v2); break; case "C": Iq = Iw.C; Il.addData(Iq, Im[IB++], Im[IB++], Im[IB++], Im[IB++], Im[IB++], Im[IB++]); v3 = Im[IB - 2]; v2 = Im[IB - 1]; break; case "c": Iq = Iw.C; Il.addData(Iq, Im[IB++] + v3, Im[IB++] + v2, Im[IB++] + v3, Im[IB++] + v2, Im[IB++] + v3, Im[IB++] + v2); v3 += Im[IB - 2]; v2 += Im[IB - 1]; break; case "S": Iz = v3; Iy = v2; var It = Il.len(); var Iu = Il.data; if (Ip === Iw.C) { Iz += v3 - Iu[It - 4]; Iy += v2 - Iu[It - 3] } Iq = Iw.C; Iv = Im[IB++]; e = Im[IB++]; v3 = Im[IB++]; v2 = Im[IB++]; Il.addData(Iq, Iz, Iy, Iv, e, v3, v2); break; case "s": Iz = v3; Iy = v2; var It = Il.len(); var Iu = Il.data; if (Ip === Iw.C) { Iz += v3 - Iu[It - 4]; Iy += v2 - Iu[It - 3] } Iq = Iw.C; Iv = v3 + Im[IB++]; e = v2 + Im[IB++]; v3 += Im[IB++]; v2 += Im[IB++]; Il.addData(Iq, Iz, Iy, Iv, e, v3, v2); break; case "Q": Iv = Im[IB++]; e = Im[IB++]; v3 = Im[IB++]; v2 = Im[IB++]; Iq = Iw.Q; Il.addData(Iq, Iv, e, v3, v2); break; case "q": Iv = Im[IB++] + v3; e = Im[IB++] + v2; v3 += Im[IB++]; v2 += Im[IB++]; Iq = Iw.Q; Il.addData(Iq, Iv, e, v3, v2); break; case "T": Iz = v3;
            Iy = v2; var It = Il.len(); var Iu = Il.data; if (Ip === Iw.Q) { Iz += v3 - Iu[It - 4]; Iy += v2 - Iu[It - 3] } v3 = Im[IB++]; v2 = Im[IB++]; Iq = Iw.Q; Il.addData(Iq, Iz, Iy, v3, v2); break; case "t": Iz = v3; Iy = v2; var It = Il.len(); var Iu = Il.data; if (Ip === Iw.Q) { Iz += v3 - Iu[It - 4]; Iy += v2 - Iu[It - 3] } v3 += Im[IB++]; v2 += Im[IB++]; Iq = Iw.Q; Il.addData(Iq, Iz, Iy, v3, v2); break; case "A": v = Im[IB++]; m = Im[IB++]; Ix = Im[IB++]; In = Im[IB++]; v1 = Im[IB++]; Iv = v3, e = v2; v3 = Im[IB++]; v2 = Im[IB++]; Iq = Iw.A; pB(Iv, e, v3, v2, In, v1, v, m, Ix, Iq, Il); break; case "a": v = Im[IB++]; m = Im[IB++]; Ix = Im[IB++]; In = Im[IB++]; v1 = Im[IB++]; Iv = v3, e = v2; v3 += Im[IB++]; v2 += Im[IB++]; Iq = Iw.A; pB(Iv, e, v3, v2, In, v1, v, m, Ix, Iq, Il); break
        }
      } if (k === "z" || k === "Z") { Iq = Iw.Z; Il.addData(Iq); v3 = Ik; v2 = Ij } Ip = Iq
    } Il.toStatic(); return Il
  } function G0(k, i) { var e = lt(k); i = i || {}; i.buildPath = function (v) { if (v.setData) { v.setData(e.data); var m = v.getContext(); if (m) { v.rebuildPath(m) } } else { var m = v; e.rebuildPath(m) } }; i.applyTransform = function (v) { sK(e, v); this.dirty(true) }; return i } function fo(i, e) { return new mm(G0(i, e)) } function b5(i, e) { return mm.extend(G0(i, e)) } function my(m, v1) { var v2 = []; var k = m.length; for (var Z = 0; Z < k; Z++) { var v = m[Z]; if (!v.path) { v.createPathProxy() } if (v.__dirtyPath) { v.buildPath(v.path, v.shape, true) } v2.push(v.path) } var e = new mm(v1); e.createPathProxy(); e.buildPath = function (v3) { v3.appendPath(v2); var i = v3.getContext(); if (i) { v3.rebuildPath(i) } }; return e } var iR = function (e) { Ie.call(this, e) }; iR.prototype = { constructor: iR, type: "text", brush: function (e, i) { var k = this.style; this.__dirty && pg(k, true); k.fill = k.stroke = k.shadowBlur = k.shadowColor = k.shadowOffsetX = k.shadowOffsetY = null; var m = k.text; m != null && (m += ""); if (!Et(m, k)) { return } this.setTransform(e); Az(this, e, m, k, null, i); this.restoreTransform(e) }, getBoundingRect: function () { var i = this.style; this.__dirty && pg(i, true); if (!this._rect) { var m = i.text; m != null ? (m += "") : (m = ""); var k = Gr(i.text + "", i.font, i.textAlign, i.textVerticalAlign, i.textPadding, i.rich); k.x += i.x || 0; k.y += i.y || 0; if (wY(i.textStroke, i.textStrokeWidth)) { var e = i.textStrokeWidth; k.x -= e / 2; k.y -= e / 2; k.width += e; k.height += e } this._rect = k } return this._rect } }; mr(iR, Ie); var GI = mm.extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function (e, i, k) { if (k) { e.moveTo(i.cx + i.r, i.cy) } e.arc(i.cx, i.cy, i.r, 0, Math.PI * 2, true) } }); var BC = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]]; var nk = function (e) { return (sW.browser.ie && sW.browser.version >= 11) ? function () { var Ij = this.__clipPaths; var v2 = this.style; var v; if (Ij) { for (var Z = 0; Z < Ij.length; Z++) { var v3 = Ij[Z]; var k = v3 && v3.shape; var v1 = v3 && v3.type; if (k && ((v1 === "sector" && k.startAngle === k.endAngle) || (v1 === "rect" && (!k.width || !k.height)))) { for (var m = 0; m < BC.length; m++) { BC[m][2] = v2[BC[m][0]]; v2[BC[m][0]] = BC[m][1] } v = true; break } } } e.apply(this, arguments); if (v) { for (var m = 0; m < BC.length; m++) { v2[BC[m][0]] = BC[m][2] } } } : e }; var tx = mm.extend({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true }, brush: nk(mm.prototype.brush), buildPath: function (Ik, Z) { var Ij = Z.cx; var v2 = Z.cy; var m = Math.max(Z.r0 || 0, 0); var e = Math.max(Z.r, 0); var v = Z.startAngle; var k = Z.endAngle; var i = Z.clockwise; var v3 = Math.cos(v); var v1 = Math.sin(v); Ik.moveTo(v3 * m + Ij, v1 * m + v2); Ik.lineTo(v3 * e + Ij, v1 * e + v2); Ik.arc(Ij, v2, e, v, k, !i); Ik.lineTo(Math.cos(k) * m + Ij, Math.sin(k) * m + v2); if (m !== 0) { Ik.arc(Ij, v2, m, k, v, i) } Ik.closePath() } }); var r3 = mm.extend({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function (i, k) { var e = k.cx; var v = k.cy; var m = Math.PI * 2; i.moveTo(e + k.r, v); i.arc(e, v, k.r, 0, m, false); i.moveTo(e + k.r0, v); i.arc(e, v, k.r0, 0, m, true) } }); function nj(v2, v1, v, m, v3, i, e) { var Z = (v - v2) * 0.5; var k = (m - v1) * 0.5; return (2 * (v1 - v) + Z + k) * e + (-3 * (v1 - v) - 2 * Z - k) * i + Z * v3 + v1 } var hZ = function (Io, e) { var Im = Io.length; var v2 = []; var Z = 0; for (var v1 = 1; v1 < Im; v1++) { Z += z8(Io[v1 - 1], Io[v1]) } var k = Z / 2; k = k < Im ? Im : k; for (var v1 = 0; v1 < k; v1++) { var v3 = v1 / (k - 1) * (e ? Im : Im - 1); var Il = Math.floor(v3); var Ik = v3 - Il; var Iq; var Ip = Io[Il % Im]; var In; var Ij; if (!e) { Iq = Io[Il === 0 ? Il : Il - 1]; In = Io[Il > Im - 2 ? Im - 1 : Il + 1]; Ij = Io[Il > Im - 3 ? Im - 1 : Il + 2] } else { Iq = Io[(Il - 1 + Im) % Im]; In = Io[(Il + 1) % Im]; Ij = Io[(Il + 2) % Im] } var v = Ik * Ik; var m = Ik * v; v2.push([nj(Iq[0], Ip[0], In[0], Ij[0], Ik, v, m), nj(Iq[1], Ip[1], In[1], Ij[1], Ik, v, m)]) } return v2 }; var vk = function (Iq, Im, Iv, e) { var Ik = []; var Il = []; var v3 = []; var Z = []; var Ip; var Is; var In, Ij; if (e) { In = [Infinity, Infinity]; Ij = [-Infinity, -Infinity]; for (var Ir = 0, m = Iq.length; Ir < m; Ir++) { Bu(In, In, Iq[Ir]); D5(Ij, Ij, Iq[Ir]) } Bu(In, In, e[0]); D5(Ij, Ij, e[1]) } for (var Ir = 0, m = Iq.length; Ir < m; Ir++) { var Io = Iq[Ir]; if (Iv) { Ip = Iq[Ir ? Ir - 1 : m - 1]; Is = Iq[(Ir + 1) % m] } else { if (Ir === 0 || Ir === m - 1) { Ik.push(uS(Iq[Ir])); continue } else { Ip = Iq[Ir - 1]; Is = Iq[Ir + 1] } } BN(Il, Is, Ip); HG(Il, Il, Im); var k = z8(Io, Ip); var Iw = z8(Io, Is); var v2 = k + Iw; if (v2 !== 0) { k /= v2; Iw /= v2 } HG(v3, Il, -k); HG(Z, Il, Iw); var Iu = uA([], Io, v3); var It = uA([], Io, Z); if (e) { D5(Iu, Iu, In); Bu(Iu, Iu, Ij); D5(It, It, In); Bu(It, It, Ij) } Ik.push(Iu); Ik.push(It) } if (Iv) { Ik.push(Ik.shift()) } return Ik }; function yQ(Il, Ij, v1) {
    var Ik = Ij.points; var e = Ij.smooth; if (Ik && Ik.length >= 2) {
      if (e && e !== "spline") {
        var Im = vk(Ik, e, v1, Ij.smoothConstraint); Il.moveTo(Ik[0][0], Ik[0][1]); var v3 = Ik.length; for (var v2 = 0; v2 < (v1 ? v3 : v3 - 1); v2++) {
          var Z = Im[v2 * 2];
          var v = Im[v2 * 2 + 1]; var k = Ik[(v2 + 1) % v3]; Il.bezierCurveTo(Z[0], Z[1], v[0], v[1], k[0], k[1])
        }
      } else { if (e === "spline") { Ik = hZ(Ik, v1) } Il.moveTo(Ik[0][0], Ik[0][1]); for (var v2 = 1, m = Ik.length; v2 < m; v2++) { Il.lineTo(Ik[v2][0], Ik[v2][1]) } } v1 && Il.closePath()
    }
  } var ia = mm.extend({ type: "polygon", shape: { points: null, smooth: false, smoothConstraint: null }, buildPath: function (e, i) { yQ(e, i, true) } }); var z7 = mm.extend({ type: "polyline", shape: { points: null, smooth: false, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function (e, i) { yQ(e, i, false) } }); var EH = mm.extend({ type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function (k, m) { var i = m.x; var Z = m.y; var v = m.width; var e = m.height; if (!m.r) { k.rect(i, Z, v, e) } else { tf(k, m) } k.closePath(); return } }); var zB = mm.extend({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function (e, k) { var m = k.x1; var Z = k.y1; var i = k.x2; var v = k.y2; var v1 = k.percent; if (v1 === 0) { return } e.moveTo(m, Z); if (v1 < 1) { i = m * (1 - v1) + i * v1; v = Z * (1 - v1) + v * v1 } e.lineTo(i, v) }, pointAt: function (i) { var e = this.shape; return [e.x1 * (1 - i) + e.x2 * i, e.y1 * (1 - i) + e.y2 * i] } }); var aO = []; function dK(i, k, e) { var m = i.cpx2; var v = i.cpy2; if (m === null || v === null) { return [(e ? gV : aS)(i.x1, i.cpx1, i.cpx2, i.x2, k), (e ? gV : aS)(i.y1, i.cpy1, i.cpy2, i.y2, k)] } else { return [(e ? vw : kw)(i.x1, i.cpx1, i.x2, k), (e ? vw : kw)(i.y1, i.cpy1, i.y2, k)] } } var gX = mm.extend({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function (Ik, v1) { var i = v1.x1; var Ij = v1.y1; var e = v1.x2; var v3 = v1.y2; var v2 = v1.cpx1; var m = v1.cpy1; var Z = v1.cpx2; var k = v1.cpy2; var v = v1.percent; if (v === 0) { return } Ik.moveTo(i, Ij); if (Z == null || k == null) { if (v < 1) { ED(i, v2, e, v, aO); v2 = aO[1]; e = aO[2]; ED(Ij, m, v3, v, aO); m = aO[1]; v3 = aO[2] } Ik.quadraticCurveTo(v2, m, e, v3) } else { if (v < 1) { gn(i, v2, Z, e, v, aO); v2 = aO[1]; Z = aO[2]; e = aO[3]; gn(Ij, m, k, v3, v, aO); m = aO[1]; k = aO[2]; v3 = aO[3] } Ik.bezierCurveTo(v2, m, Z, k, e, v3) } }, pointAt: function (e) { return dK(this.shape, e, false) }, tangentAt: function (e) { var i = dK(this.shape, e, true); return wH(i, i) } }); var pS = mm.extend({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true }, style: { stroke: "#000", fill: null }, buildPath: function (Ij, v) { var v3 = v.cx; var v1 = v.cy; var e = Math.max(v.r, 0); var m = v.startAngle; var k = v.endAngle; var i = v.clockwise; var v2 = Math.cos(m); var Z = Math.sin(m); Ij.moveTo(v2 * e + v3, Z * e + v1); Ij.arc(v3, v1, e, m, k, !i) } }); var jr = mm.extend({ type: "compound", shape: { paths: null }, _updatePathDirty: function () { var k = this.__dirtyPath; var m = this.shape.paths; for (var e = 0; e < m.length; e++) { k = k || m[e].__dirtyPath } this.__dirtyPath = k; this.__dirty = this.__dirty || k }, beforeBrush: function () { this._updatePathDirty(); var m = this.shape.paths || []; var k = this.getGlobalScale(); for (var e = 0; e < m.length; e++) { if (!m[e].path) { m[e].createPathProxy() } m[e].path.setScale(k[0], k[1]) } }, buildPath: function (e, k) { var v = k.paths || []; for (var m = 0; m < v.length; m++) { v[m].buildPath(e, v[m].shape, true) } }, afterBrush: function () { var k = this.shape.paths || []; for (var e = 0; e < k.length; e++) { k[e].__dirtyPath = false } }, getBoundingRect: function () { this._updatePathDirty(); return mm.prototype.getBoundingRect.call(this) } }); var lV = function (e) { this.colorStops = e || [] }; lV.prototype = { constructor: lV, addColorStop: function (i, e) { this.colorStops.push({ offset: i, color: e }) } }; var uD = function (e, Z, k, m, i, v) { this.x = e == null ? 0 : e; this.y = Z == null ? 0 : Z; this.x2 = k == null ? 1 : k; this.y2 = m == null ? 0 : m; this.type = "linear"; this.global = v || false; lV.call(this, i) }; uD.prototype = { constructor: uD }; mr(uD, lV); var oU = function (e, v, k, i, m) { this.x = e == null ? 0.5 : e; this.y = v == null ? 0.5 : v; this.r = k == null ? 0.5 : k; this.type = "radial"; this.global = m || false; lV.call(this, i) }; oU.prototype = { constructor: oU }; mr(oU, lV); function zL(e) { Ie.call(this, e); this._displayables = []; this._temporaryDisplayables = []; this._cursor = 0; this.notClear = true } zL.prototype.incremental = true; zL.prototype.clearDisplaybles = function () { this._displayables = []; this._temporaryDisplayables = []; this._cursor = 0; this.dirty(); this.notClear = false }; zL.prototype.addDisplayable = function (e, i) { if (i) { this._temporaryDisplayables.push(e) } else { this._displayables.push(e) } this.dirty() }; zL.prototype.addDisplayables = function (m, k) { k = k || false; for (var e = 0; e < m.length; e++) { this.addDisplayable(m[e], k) } }; zL.prototype.eachPendingDisplayable = function (e) { for (var k = this._cursor; k < this._displayables.length; k++) { e && e(this._displayables[k]) } for (var k = 0; k < this._temporaryDisplayables.length; k++) { e && e(this._temporaryDisplayables[k]) } }; zL.prototype.update = function () { this.updateTransform(); for (var k = this._cursor; k < this._displayables.length; k++) { var e = this._displayables[k]; e.parent = this; e.update(); e.parent = null } for (var k = 0; k < this._temporaryDisplayables.length; k++) { var e = this._temporaryDisplayables[k]; e.parent = this; e.update(); e.parent = null } }; zL.prototype.brush = function (e, v) {
    for (var m = this._cursor; m < this._displayables.length; m++) { var k = this._displayables[m]; k.beforeBrush && k.beforeBrush(e); k.brush(e, m === this._cursor ? null : this._displayables[m - 1]); k.afterBrush && k.afterBrush(e) } this._cursor = m; for (var m = 0; m < this._temporaryDisplayables.length; m++) {
      var k = this._temporaryDisplayables[m];
      k.beforeBrush && k.beforeBrush(e); k.brush(e, m === 0 ? null : this._temporaryDisplayables[m - 1]); k.afterBrush && k.afterBrush(e)
    } this._temporaryDisplayables = []; this.notClear = true
  }; var Ha = []; zL.prototype.getBoundingRect = function () { if (!this._rect) { var v = new CH(Infinity, Infinity, -Infinity, -Infinity); for (var m = 0; m < this._displayables.length; m++) { var k = this._displayables[m]; var e = k.getBoundingRect().clone(); if (k.needLocalTransform()) { e.applyTransform(k.getLocalTransform(Ha)) } v.union(e) } this._rect = v } return this._rect }; zL.prototype.contain = function (e, v1) { var Z = this.transformCoordToLocal(e, v1); var v = this.getBoundingRect(); if (v.contain(Z[0], Z[1])) { for (var m = 0; m < this._displayables.length; m++) { var k = this._displayables[m]; if (k.contain(e, v1)) { return true } } } return false }; mr(zL, Ie); var D = Math.round; var AO = Math.max; var jy = Math.min; var AC = {}; function Hw(e) { return mm.extend(e) } function rn(i, e) { return b5(i, e) } function Bd(Z, m, k, i) { var v = fo(Z, m); var e = v.getBoundingRect(); if (k) { if (i === "center") { k = Bb(k, e) } ec(v, k) } return v } function Gt(e, k, i) { var m = new Ft({ style: { image: e, x: k.x, y: k.y, width: k.width, height: k.height }, onload: function (v) { if (i === "center") { var Z = { width: v.width, height: v.height }; m.setStyle(Bb(k, Z)) } } }); return m } function Bb(Z, m) { var k = m.width / m.height; var v = Z.height * k; var i; if (v <= Z.width) { i = Z.height } else { v = Z.width; i = v / k } var e = Z.x + Z.width / 2; var v1 = Z.y + Z.height / 2; return { x: e - v / 2, y: v1 - i / 2, width: v, height: i } } var q8 = my; function ec(v, i) { if (!v.applyTransform) { return } var k = v.getBoundingRect(); var e = k.calculateTransform(i); v.applyTransform(e) } function dn(k) { var i = k.shape; var e = k.style.lineWidth; if (D(i.x1 * 2) === D(i.x2 * 2)) { i.x1 = i.x2 = Gw(i.x1, e, true) } if (D(i.y1 * 2) === D(i.y2 * 2)) { i.y1 = i.y2 = Gw(i.y1, e, true) } return k } function iA(Z) { var m = Z.shape; var e = Z.style.lineWidth; var v = m.x; var k = m.y; var i = m.width; var v1 = m.height; m.x = Gw(m.x, e, true); m.y = Gw(m.y, e, true); m.width = Math.max(Gw(v + i, e, false) - m.x, i === 0 ? 0 : 1); m.height = Math.max(Gw(k + v1, e, false) - m.y, v1 === 0 ? 0 : 1); return Z } function Gw(i, e, k) { var m = D(i * 2); return (m + D(e)) % 2 === 0 ? m / 2 : (m + (k ? 1 : -1)) / 2 } function im(e) { return e != null && e != "none" } var FQ = CJ(); var zj = 0; function Ah(e) { if (typeof e !== "string") { return e } var i = FQ.get(e); if (!i) { i = mU(e, -0.1); if (zj < 10000) { FQ.set(e, i); zj++ } } return i } function Fz(k) { if (!k.__hoverStlDirty) { return } k.__hoverStlDirty = false; var m = k.__hoverStl; if (!m) { k.__normalStl = null; return } var v = k.__normalStl = {}; var i = k.style; for (var e in m) { if (m[e] != null) { v[e] = i[e] } } v.fill = i.fill; v.stroke = i.stroke } function w5(m) { var k = m.__hoverStl; if (!k || m.__highlighted) { return } var e = m.useHoverLayer; m.__highlighted = e ? "layer" : "plain"; var v = m.__zr; if (!v && e) { return } var Z = m; var i = m.style; if (e) { Z = v.addHover(m); i = Z.style } Fq(i); if (!e) { Fz(Z) } i.extendFrom(k); ff(i, k, "fill"); ff(i, k, "stroke"); sD(i); if (!e) { m.dirty(false); m.z2 += 1 } } function ff(e, i, k) { if (!im(i[k]) && im(e[k])) { e[k] = Ah(e[k]) } } function eu(e) { if (e.__highlighted) { jU(e); e.__highlighted = false } } function jU(k) { var m = k.__highlighted; if (m === "layer") { k.__zr && k.__zr.removeHover(k) } else { if (m) { var i = k.style; var e = k.__normalStl; if (e) { Fq(i); k.setStyle(e); sD(i); k.z2 -= 1 } } } } function cs(e, i) { e.isGroup ? e.traverse(function (k) { !k.isGroup && i(k) }) : i(e) } function li(i, e) { e = i.__hoverStl = e !== false && (e || {}); i.__hoverStlDirty = true; if (i.__highlighted) { eu(i); w5(i) } } function rW(e) { return e && e.__isEmphasis } function hY(i) { if (this.__hoverSilentOnTouch && i.zrByTouch) { return } !this.__isEmphasis && cs(this, w5) } function gm(i) { if (this.__hoverSilentOnTouch && i.zrByTouch) { return } !this.__isEmphasis && cs(this, eu) } function Ex() { this.__isEmphasis = true; cs(this, w5) } function u4() { this.__isEmphasis = false; cs(this, eu) } function yn(i, k, e) { i.isGroup ? i.traverse(function (m) { !m.isGroup && li(m, m.hoverStyle || k) }) : li(i, i.hoverStyle || k); yJ(i, e) } function yJ(k, i) { var e = i === false; k.__hoverSilentOnTouch = i != null && i.hoverSilentOnTouch; if (!e || k.__hoverStyleTrigger) { var m = e ? "off" : "on"; k[m]("mouseover", hY)[m]("mouseout", gm); k[m]("emphasis", Ex)[m]("normal", u4); k.__hoverStyleTrigger = !e } } function BD(e, k, Z, v3, i, In, Il) { i = i || AC; var v = i.labelFetcher; var v2 = i.labelDataIndex; var Ij = i.labelDimIndex; var Ik = Z.getShallow("show"); var Io = v3.getShallow("show"); var Im; if (Ik || Io) { if (v) { Im = v.getFormattedLabel(v2, "normal", null, Ij) } if (Im == null) { Im = E5(i.defaultText) ? i.defaultText(v2, i) : i.defaultText } } var v1 = Ik ? Im : null; var m = Io ? kb(v ? v.getFormattedLabel(v2, "emphasis", null, Ij) : null, Im) : null; if (v1 != null || m != null) { pe(e, Z, In, i); pe(k, v3, Il, i, true) } e.text = v1; k.text = m } function pe(v, e, m, k, i) { CL(v, e, k, i); m && b0(v, m); return v } function D2(v, m, k) { var i = { isRectText: true }; var e; if (k === false) { e = true } else { i.autoColor = k } CL(v, m, i, e) } function CL(v2, Ij, k, v) {
    k = k || AC; if (k.isRectText) { var Il = Ij.getShallow("position") || (v ? null : "inside"); Il === "outside" && (Il = "top"); v2.textPosition = Il; v2.textOffset = Ij.getShallow("offset"); var m = Ij.getShallow("rotate"); m != null && (m *= Math.PI / 180); v2.textRotation = m; v2.textDistance = kb(Ij.getShallow("distance"), v ? null : 5) } var v1 = Ij.ecModel; var Z = v1 && v1.option.textStyle; var v3 = ww(Ij); var e; if (v3) {
      e = {}; for (var i in v3) {
        if (v3.hasOwnProperty(i)) {
          var Ik = Ij.getModel(["rich", i]); zA(e[i] = {}, Ik, Z, k, v)
        }
      }
    } v2.rich = e; zA(v2, Ij, Z, k, v, true); if (k.forceRich && !k.textStyle) { k.textStyle = {} } return v2
  } function ww(m) { var e; while (m && m !== m.ecModel) { var i = (m.option || AC).rich; if (i) { e = e || {}; for (var k in i) { if (i.hasOwnProperty(k)) { e[k] = 1 } } } m = m.parentModel } return e } function zA(Z, i, v, m, k, e) { v = !k && v || AC; Z.textFill = kl(i.getShallow("color"), m) || v.color; Z.textStroke = kl(i.getShallow("textBorderColor"), m) || v.textBorderColor; Z.textStrokeWidth = kb(i.getShallow("textBorderWidth"), v.textBorderWidth); Z.insideRawTextPosition = Z.textPosition; if (!k) { if (e) { Z.insideRollbackOpt = m; sD(Z) } if (Z.textFill == null) { Z.textFill = m.autoColor } } Z.fontStyle = i.getShallow("fontStyle") || v.fontStyle; Z.fontWeight = i.getShallow("fontWeight") || v.fontWeight; Z.fontSize = i.getShallow("fontSize") || v.fontSize; Z.fontFamily = i.getShallow("fontFamily") || v.fontFamily; Z.textAlign = i.getShallow("align"); Z.textVerticalAlign = i.getShallow("verticalAlign") || i.getShallow("baseline"); Z.textLineHeight = i.getShallow("lineHeight"); Z.textWidth = i.getShallow("width"); Z.textHeight = i.getShallow("height"); Z.textTag = i.getShallow("tag"); if (!e || !m.disableBox) { Z.textBackgroundColor = kl(i.getShallow("backgroundColor"), m); Z.textPadding = i.getShallow("padding"); Z.textBorderColor = kl(i.getShallow("borderColor"), m); Z.textBorderWidth = i.getShallow("borderWidth"); Z.textBorderRadius = i.getShallow("borderRadius"); Z.textBoxShadowColor = i.getShallow("shadowColor"); Z.textBoxShadowBlur = i.getShallow("shadowBlur"); Z.textBoxShadowOffsetX = i.getShallow("shadowOffsetX"); Z.textBoxShadowOffsetY = i.getShallow("shadowOffsetY") } Z.textShadowColor = i.getShallow("textShadowColor") || v.textShadowColor; Z.textShadowBlur = i.getShallow("textShadowBlur") || v.textShadowBlur; Z.textShadowOffsetX = i.getShallow("textShadowOffsetX") || v.textShadowOffsetX; Z.textShadowOffsetY = i.getShallow("textShadowOffsetY") || v.textShadowOffsetY } function kl(e, i) { return e !== "auto" ? e : (i && i.autoColor) ? i.autoColor : null } function sD(Z) { if (Z.textFill != null) { return } var k = Z.insideRollbackOpt; var i = k.useInsideStyle; var v = Z.insideRawTextPosition; var e; var m = k.autoColor; if (i !== false && (i === true || (k.isRectText && v && typeof v === "string" && v.indexOf("inside") >= 0))) { e = { textFill: null, textStroke: Z.textStroke, textStrokeWidth: Z.textStrokeWidth }; Z.textFill = "#fff"; if (Z.textStroke == null) { Z.textStroke = m; Z.textStrokeWidth == null && (Z.textStrokeWidth = 2) } } else { if (m != null) { e = { textFill: null }; Z.textFill = m } } if (e) { Z.insideRollback = e } } function Fq(i) { var e = i.insideRollback; if (e) { i.textFill = e.textFill; i.textStroke = e.textStroke; i.textStrokeWidth = e.textStrokeWidth; i.insideRollback = null } } function jZ(i, e) { var k = e || e.getModel("textStyle"); return Gs([i.fontStyle || k && k.getShallow("fontStyle") || "", i.fontWeight || k && k.getShallow("fontWeight") || "", (i.fontSize || k && k.getShallow("fontSize") || 12) + "px", i.fontFamily || k && k.getShallow("fontFamily") || "sans-serif"].join(" ")) } function hX(Ik, i, v1, v, v2, k) { if (typeof v2 === "function") { k = v2; v2 = null } var Ij = v && v.isAnimationEnabled(); if (Ij) { var v3 = Ik ? "Update" : ""; var m = v.getShallow("animationDuration" + v3); var e = v.getShallow("animationEasing" + v3); var Z = v.getShallow("animationDelay" + v3); if (typeof Z === "function") { Z = Z(v2, v.getAnimationDelayParams ? v.getAnimationDelayParams(i, v2) : null) } if (typeof m === "function") { m = m(v2) } m > 0 ? i.animateTo(v1, m, Z || 0, e, k, !!k) : (i.stopAnimation(), i.attr(v1), k && k()) } else { i.stopAnimation(); i.attr(v1); k && k() } } function oS(m, k, v, i, e) { hX(true, m, k, v, i, e) } function jC(m, k, v, i, e) { hX(false, m, k, v, i, e) } function aI(k, i) { var e = lN([]); while (k && k !== i) { l(e, k.getLocalTransform(), e); k = k.parent } return e } function v7(k, e, i) { if (e && !sP(e)) { e = bJ.getLocalTransform(e) } if (i) { e = fG([], e) } return aY([], k, e) } function n0(Z, i, k) { var e = (i[4] === 0 || i[5] === 0 || i[0] === 0) ? 1 : Math.abs(2 * i[4] / i[0]); var v = (i[4] === 0 || i[5] === 0 || i[2] === 0) ? 1 : Math.abs(2 * i[4] / i[2]); var m = [Z === "left" ? -e : Z === "right" ? e : 0, Z === "top" ? -v : Z === "bottom" ? v : 0]; m = v7(m, i, k); return Math.abs(m[0]) > Math.abs(m[1]) ? (m[0] > 0 ? "right" : "left") : (m[1] > 0 ? "bottom" : "top") } function E(k, i, Z, e) { if (!k || !i) { return } function v(v3) { var v2 = {}; v3.traverse(function (Ij) { if (!Ij.isGroup && Ij.anid) { v2[Ij.anid] = Ij } }); return v2 } function v1(v2) { var v3 = { position: uS(v2.position), rotation: v2.rotation }; if (v2.shape) { v3.shape = b0({}, v2.shape) } return v3 } var m = v(k); i.traverse(function (v3) { if (!v3.isGroup && v3.anid) { var v2 = m[v3.anid]; if (v2) { var Ij = v1(v3); v3.attr(v1(v2)); oS(v3, Ij, Z, v3.dataIndex) } } }) } function oF(e, i) { return Ef(e, function (m) { var k = m[0]; k = AO(k, i.x); k = jy(k, i.x + i.width); var v = m[1]; v = AO(v, i.y); v = jy(v, i.y + i.height); return [k, v] }) } function vl(v, m) { var e = AO(v.x, m.x); var i = jy(v.x + v.width, m.x + m.width); var Z = AO(v.y, m.y); var k = jy(v.y + v.height, m.y + m.height); if (i >= e && k >= Z) { return { x: e, y: Z, width: i - e, height: k - Z } } } function Gb(e, i, m) { i = b0({ rectHover: true }, i); var k = i.style = { strokeNoScale: true }; m = m || { x: -1, y: -1, width: 2, height: 2 }; if (e) { return e.indexOf("image://") === 0 ? (k.image = e.slice(8), De(k, m), new Ft(i)) : (Bd(e.replace("path://", ""), i, m, "center")) } } var yf = (Object.freeze || Object)({ extendShape: Hw, extendPath: rn, makePath: Bd, makeImage: Gt, mergePath: q8, resizePath: ec, subPixelOptimizeLine: dn, subPixelOptimizeRect: iA, subPixelOptimize: Gw, setElementHoverStyle: li, isInEmphasis: rW, setHoverStyle: yn, setAsHoverStyleTrigger: yJ, setLabelStyle: BD, setTextStyle: pe, setText: D2, getFont: jZ, updateProps: oS, initProps: jC, getTransform: aI, applyTransform: v7, transformDirection: n0, groupTransition: E, clipPointsByRect: oF, clipRectByRect: vl, createIcon: Gb, Group: B8, Image: Ft, Text: iR, Circle: GI, Sector: tx, Ring: r3, Polygon: ia, Polyline: z7, Rect: EH, Line: zB, BezierCurve: gX, Arc: pS, IncrementalDisplayable: zL, CompoundPath: jr, LinearGradient: uD, RadialGradient: oU, BoundingRect: CH });
  var eA = ["textStyle", "color"]; var L = { getTextColor: function (i) { var e = this.ecModel; return this.getShallow("color") || ((!i && e) ? e.get(eA) : null) }, getFont: function () { return jZ({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel) }, getTextRect: function (e) { return Gr(e, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("rich"), this.getShallow("truncateText")) } }; var hO = yO([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]); var HO = { getItemStyle: function (m, i) { var k = hO(this, m, i); var e = this.getBorderLineDash(); e && (k.lineDash = e); return k }, getBorderLineDash: function () { var e = this.get("borderType"); return (e === "solid" || e == null) ? null : (e === "dashed" ? [5, 5] : [1, 1]) } }; var dk = Gq; var qR = fK(); function fv(k, i, e) { this.parentModel = i; this.ecModel = e; this.option = k } fv.prototype = { constructor: fv, init: null, mergeOption: function (e) { v4(this.option, e, true) }, get: function (i, e) { if (i == null) { return this.option } return u7(this.option, this.parsePath(i), !e && At(this, i)) }, getShallow: function (k, e) { var m = this.option; var v = m == null ? m : m[k]; var i = !e && At(this, k); if (v == null && i) { v = i.getShallow(k) } return v }, getModel: function (m, e) { var k = m == null ? this.option : u7(this.option, m = this.parsePath(m)); var i; e = e || ((i = At(this, m)) && i.getModel(m)); return new fv(k, e, this.ecModel) }, isEmpty: function () { return this.option == null }, restoreData: function () { }, clone: function () { var e = this.constructor; return new e(C5(this.option)) }, setReadOnly: function (e) { }, parsePath: function (e) { if (typeof e === "string") { e = e.split(".") } return e }, customizeGetParent: function (e) { qR(this).getParent = e }, isAnimationEnabled: function () { if (!sW.node) { if (this.option.animation != null) { return !!this.option.animation } else { if (this.parentModel) { return this.parentModel.isAnimationEnabled() } } } } }; function u7(v, m, e) { for (var k = 0; k < m.length; k++) { if (!m[k]) { continue } v = (v && typeof v === "object") ? v[m[k]] : null; if (v == null) { break } } if (v == null && e) { v = e.get(m) } return v } function At(i, k) { var e = qR(i).getParent; return e ? e.call(i, k) : i.parentModel } AG(fv); z6(fv); dk(fv, df); dk(fv, fX); dk(fv, L); dk(fv, HO); var AU = 0; function l8(e) { return [(e || ""), AU++, Math.random().toFixed(5)].join("_") } function yT(e) { var i = {}; e.registerSubTypeDefaulter = function (m, k) { m = pd(m); i[m.main] = k }; e.determineSubType = function (k, v) { var m = v.type; if (!m) { var Z = pd(k).main; if (e.hasSubTypes(k) && i[Z]) { m = i[Z](v) } } return m }; return e } function Eo(m, k) { m.topologicalTravel = function (Il, Z, Io, v2) { if (!Il.length) { return } var Ir = i(Z); var Ip = Ir.graph; var Im = Ir.noEntryList; var Ik = {}; o9(Il, function (Is) { Ik[Is] = true }); while (Im.length) { var Iq = Im.pop(); var v3 = Ip[Iq]; var Ij = !!Ik[Iq]; if (Ij) { Io.call(v2, Iq, v3.originalDeps.slice()); delete Ik[Iq] } o9(v3.successor, Ij ? In : v1) } o9(Ik, function () { throw new Error("Circle dependency may exists") }); function v1(Is) { Ip[Is].entryCount--; if (Ip[Is].entryCount === 0) { Im.push(Is) } } function In(Is) { Ik[Is] = true; v1(Is) } }; function i(v2) { var v1 = {}; var Z = []; o9(v2, function (v3) { var Ij = e(v1, v3); var Il = Ij.originalDeps = k(v3); var Ik = v(Il, v2); Ij.entryCount = Ik.length; if (Ij.entryCount === 0) { Z.push(v3) } o9(Ik, function (Im) { if (eP(Ij.predecessor, Im) < 0) { Ij.predecessor.push(Im) } var In = e(v1, Im); if (eP(In.successor, Im) < 0) { In.successor.push(v3) } }) }); return { graph: v1, noEntryList: Z } } function e(v1, Z) { if (!v1[Z]) { v1[Z] = { predecessor: [], successor: [] } } return v1[Z] } function v(v1, v2) { var Z = []; o9(v1, function (v3) { eP(v2, v3) >= 0 && Z.push(v3) }); return Z } } var FF = 0.0001; function ha(e) { return e.replace(/^\s+/, "").replace(/\s+$/, "") } function EQ(Z, m, i, v) { var k = m[1] - m[0]; var e = i[1] - i[0]; if (k === 0) { return e === 0 ? i[0] : (i[0] + i[1]) / 2 } if (v) { if (k > 0) { if (Z <= m[0]) { return i[0] } else { if (Z >= m[1]) { return i[1] } } } else { if (Z >= m[0]) { return i[0] } else { if (Z <= m[1]) { return i[1] } } } } else { if (Z === m[0]) { return i[0] } if (Z === m[1]) { return i[1] } } return (Z - m[0]) / k * e + i[0] } function zN(i, e) { switch (i) { case "center": case "middle": i = "50%"; break; case "left": case "top": i = "0%"; break; case "right": case "bottom": i = "100%"; break }if (typeof i === "string") { if (ha(i).match(/%$/)) { return parseFloat(i) / 100 * e } return parseFloat(i) } return i == null ? NaN : +i } function FM(e, i, k) { if (i == null) { i = 10 } i = Math.min(Math.max(0, i), 20); e = (+e).toFixed(i); return k ? e : +e } function o7(e) { e.sort(function (k, i) { return k - i }); return e } function oK(m) { m = +m; if (isNaN(m)) { return 0 } var k = 1; var i = 0; while (Math.round(m * k) / k !== m) { k *= 10; i++ } return i } function t4(v) { var m = v.toString(); var k = m.indexOf("e"); if (k > 0) { var e = +m.slice(k + 1); return e < 0 ? -e : 0 } else { var i = m.indexOf("."); return i < 0 ? 0 : m.length - 1 - i } } function ya(Z, v1) { var v = Math.log; var k = Math.LN10; var i = Math.floor(v(Z[1] - Z[0]) / k); var m = Math.round(v(Math.abs(v1[1] - v1[0])) / k); var e = Math.min(Math.max(-i + m, 0), 20); return !isFinite(e) ? 20 : e } function au(k, Im, v1) {
    if (!k[Im]) { return 0 } var Ij = xc(k, function (i, Ip) { return i + (isNaN(Ip) ? 0 : Ip) }, 0); if (Ij === 0) { return 0 } var e = Math.pow(10, v1); var Il = Ef(k, function (i) {
      return (isNaN(i) ? 0 : i) / Ij * e * 100
    }); var Io = e * 100; var m = Ef(Il, function (i) { return Math.floor(i) }); var Z = xc(m, function (i, Ip) { return i + Ip }, 0); var In = Ef(Il, function (Ip, i) { return Ip - m[i] }); while (Z < Io) { var Ik = Number.NEGATIVE_INFINITY; var v3 = null; for (var v = 0, v2 = In.length; v < v2; ++v) { if (In[v] > Ik) { Ik = In[v]; v3 = v } } ++m[v3]; In[v3] = 0; ++Z } return m[Im] / e
  } var yX = 9007199254740991; function ru(i) { var e = Math.PI * 2; return (i % e + e) % e } function uM(e) { return e > -FF && e < FF } var pJ = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; function vS(k) { if (k instanceof Date) { return k } else { if (typeof k === "string") { var i = pJ.exec(k); if (!i) { return new Date(NaN) } if (!i[8]) { return new Date(+i[1], +(i[2] || 1) - 1, +i[3] || 1, +i[4] || 0, +(i[5] || 0), +i[6] || 0, +i[7] || 0) } else { var e = +i[4] || 0; if (i[8].toUpperCase() !== "Z") { e -= i[8].slice(0, 3) } return new Date(Date.UTC(+i[1], +(i[2] || 1) - 1, +i[3] || 1, e, +(i[5] || 0), +i[6] || 0, +i[7] || 0)) } } else { if (k == null) { return new Date(NaN) } } } return new Date(Math.round(k)) } function rY(e) { return Math.pow(10, g5(e)) } function g5(e) { return Math.floor(Math.log(e) / Math.LN10) } function Y(Z, i) { var v = g5(Z); var e = Math.pow(10, v); var m = Z / e; var k; if (i) { if (m < 1.5) { k = 1 } else { if (m < 2.5) { k = 2 } else { if (m < 4) { k = 3 } else { if (m < 7) { k = 5 } else { k = 10 } } } } } else { if (m < 1) { k = 1 } else { if (m < 2) { k = 2 } else { if (m < 3) { k = 3 } else { if (m < 5) { k = 5 } else { k = 10 } } } } } Z = k * e; return v >= -20 ? +Z.toFixed(v < 0 ? -v : 0) : Z } function u9(v2, v1) { var k = (v2.length - 1) * v1 + 1; var m = Math.floor(k); var i = +v2[m - 1]; var Z = k - m; return Z ? i + Z * (v2[m] - i) : i } function W(v1) { v1.sort(function (Ij, i) { return Z(Ij, i, 0) ? -1 : 1 }); var v2 = -Infinity; var v = 1; for (var m = 0; m < v1.length;) { var k = v1[m].interval; var v3 = v1[m].close; for (var e = 0; e < 2; e++) { if (k[e] <= v2) { k[e] = v2; v3[e] = !e ? 1 - v : 1 } v2 = k[e]; v = v3[e] } if (k[0] === k[1] && v3[0] * v3[1] !== 1) { v1.splice(m, 1) } else { m++ } } return v1; function Z(Ij, i, Ik) { return Ij.interval[Ik] < i.interval[Ik] || (Ij.interval[Ik] === i.interval[Ik] && ((Ij.close[Ik] - i.close[Ik] === (!Ik ? 1 : -1)) || (!Ik && Z(Ij, i, 1)))) } } function lC(e) { return e - parseFloat(e) >= 0 } var ng = (Object.freeze || Object)({ linearMap: EQ, parsePercent: zN, round: FM, asc: o7, getPrecision: oK, getPrecisionSafe: t4, getPixelPrecision: ya, getPercentWithPrecision: au, MAX_SAFE_INTEGER: yX, remRadian: ru, isRadianAroundZero: uM, parseDate: vS, quantity: rY, nice: Y, quantile: u9, reformIntervals: W, isNumeric: lC }); function j7(e) { if (isNaN(e)) { return "-" } e = (e + "").split("."); return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? ("." + e[1]) : "") } function re(e, i) { e = (e || "").toLowerCase().replace(/-(.)/g, function (m, k) { return k.toUpperCase() }); if (i && e) { e = e.charAt(0).toUpperCase() + e.slice(1) } return e } var Bj = Dv; var jz = /([&<>"'])/g; var E0 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }; function mv(e) { return e == null ? "" : (e + "").replace(jz, function (i, k) { return E0[k] }) } var hz = ["a", "b", "c", "d", "e", "f", "g"]; var n = function (i, e) { return "{" + i + (e == null ? "" : e) + "}" }; function ew(Ij, Ik, v3) { if (!GG(Ik)) { Ik = [Ik] } var v = Ik.length; if (!v) { return "" } var v2 = Ik[0].$vars || []; for (var Z = 0; Z < v2.length; Z++) { var v1 = hz[Z]; Ij = Ij.replace(n(v1), n(v1, 0)) } for (var Il = 0; Il < v; Il++) { for (var m = 0; m < v2.length; m++) { var e = Ik[Il][v2[m]]; Ij = Ij.replace(n(hz[m], Il), v3 ? mv(e) : e) } } return Ij } function Fy(e, k, i) { o9(k, function (v, m) { e = e.replace("{" + m + "}", i ? mv(v) : v) }); return e } function zu(i, v) { i = wb(i) ? { color: i, extraCssText: v } : (i || {}); var e = i.color; var k = i.type; var v = i.extraCssText; var Z = i.renderMode || "html"; var m = i.markerId || "X"; if (!e) { return "" } if (Z === "html") { return k === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + "border-radius:4px;width:4px;height:4px;background-color:" + mv(e) + ";" + (v || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;' + "border-radius:10px;width:10px;height:10px;background-color:" + mv(e) + ";" + (v || "") + '"></span>' } else { return { renderMode: Z, content: "{marker" + m + "|}  ", style: { color: e } } } } function Gj(i, e) { i += ""; return "0000".substr(0, e - i.length) + i } function mT(v1, Il, e) { if (v1 === "week" || v1 === "month" || v1 === "quarter" || v1 === "half-year" || v1 === "year") { v1 = "MM-dd\nyyyy" } var k = vS(Il); var Ik = e ? "UTC" : ""; var Ij = k["get" + Ik + "FullYear"](); var v2 = k["get" + Ik + "Month"]() + 1; var v3 = k["get" + Ik + "Date"](); var Z = k["get" + Ik + "Hours"](); var i = k["get" + Ik + "Minutes"](); var Im = k["get" + Ik + "Seconds"](); var v = k["get" + Ik + "Milliseconds"](); v1 = v1.replace("MM", Gj(v2, 2)).replace("M", v2).replace("yyyy", Ij).replace("yy", Ij % 100).replace("dd", Gj(v3, 2)).replace("d", v3).replace("hh", Gj(Z, 2)).replace("h", Z).replace("mm", Gj(i, 2)).replace("m", i).replace("ss", Gj(Im, 2)).replace("s", Im).replace("SSS", Gj(v, 3)); return v1 } function tg(e) { return e ? e.charAt(0).toUpperCase() + e.substr(1) : e } var hc = aW; var vh = Gr; var fP = (Object.freeze || Object)({ addCommas: j7, toCamelCase: re, normalizeCssArray: Bj, encodeHTML: mv, formatTpl: ew, formatTplSimple: Fy, getTooltipMarker: zu, formatTime: mT, capitalFirst: tg, truncateText: hc, getTextRect: vh }); var o6 = o9; var rq = ["left", "right", "top", "bottom", "width", "height"]; var kZ = [["width", "left", "right"], ["height", "top", "bottom"]]; function M(k, Z, v2, v, m) {
    var e = 0; var v1 = 0; if (v == null) { v = Infinity } if (m == null) { m = Infinity } var i = 0;
    Z.eachChild(function (Ik, Ip) { var In = Ik.position; var Io = Ik.getBoundingRect(); var Ij = Z.childAt(Ip + 1); var v3 = Ij && Ij.getBoundingRect(); var Ir; var Iq; if (k === "horizontal") { var Im = Io.width + (v3 ? (-v3.x + Io.x) : 0); Ir = e + Im; if (Ir > v || Ik.newline) { e = 0; Ir = Im; v1 += i + v2; i = Io.height } else { i = Math.max(i, Io.height) } } else { var Il = Io.height + (v3 ? (-v3.y + Io.y) : 0); Iq = v1 + Il; if (Iq > m || Ik.newline) { e += i + v2; v1 = 0; Iq = Il; i = Io.width } else { i = Math.max(i, Io.width) } } if (Ik.newline) { return } In[0] = e; In[1] = v1; k === "horizontal" ? (e = Ir + v2) : (v1 = Iq + v2) })
  } var fl = M; var qd = sv(M, "vertical"); var jn = sv(M, "horizontal"); function mA(e, v1, k) { var Z = v1.width; var v3 = v1.height; var v2 = zN(e.x, Z); var v = zN(e.y, v3); var i = zN(e.x2, Z); var m = zN(e.y2, v3); (isNaN(v2) || isNaN(parseFloat(e.x))) && (v2 = 0); (isNaN(i) || isNaN(parseFloat(e.x2))) && (i = Z); (isNaN(v) || isNaN(parseFloat(e.y))) && (v = 0); (isNaN(m) || isNaN(parseFloat(e.y2))) && (m = v3); k = Bj(k || 0); return { width: Math.max(i - v2 - k[1] - k[3], 0), height: Math.max(m - v - k[0] - k[2], 0) } } function kV(k, Ik, Z) { Z = Bj(Z || 0); var Ij = Ik.width; var Io = Ik.height; var v = zN(k.left, Ij); var v3 = zN(k.top, Io); var Il = zN(k.right, Ij); var i = zN(k.bottom, Io); var m = zN(k.width, Ij); var Im = zN(k.height, Io); var In = Z[2] + Z[0]; var v1 = Z[1] + Z[3]; var e = k.aspect; if (isNaN(m)) { m = Ij - Il - v1 - v } if (isNaN(Im)) { Im = Io - i - In - v3 } if (e != null) { if (isNaN(m) && isNaN(Im)) { if (e > Ij / Io) { m = Ij * 0.8 } else { Im = Io * 0.8 } } if (isNaN(m)) { m = e * Im } if (isNaN(Im)) { Im = m / e } } if (isNaN(v)) { v = Ij - Il - m - v1 } if (isNaN(v3)) { v3 = Io - i - Im - In } switch (k.left || k.right) { case "center": v = Ij / 2 - m / 2 - Z[3]; break; case "right": v = Ij - m - v1; break }switch (k.top || k.bottom) { case "middle": case "center": v3 = Io / 2 - Im / 2 - Z[0]; break; case "bottom": v3 = Io - Im - In; break }v = v || 0; v3 = v3 || 0; if (isNaN(m)) { m = Ij - v1 - v - (Il || 0) } if (isNaN(Im)) { Im = Io - In - v3 - (i || 0) } var v2 = new CH(v + Z[3], v3 + Z[0], m, Im); v2.margin = Z; return v2 } function Ax(k, e, v3, Z, i) { var v1 = !i || !i.hv || i.hv[0]; var Ik = !i || !i.hv || i.hv[1]; var Im = i && i.boundingMode || "all"; if (!v1 && !Ik) { return } var v2; if (Im === "raw") { v2 = k.type === "group" ? new CH(0, 0, +e.width || 0, +e.height || 0) : k.getBoundingRect() } else { v2 = k.getBoundingRect(); if (k.needLocalTransform()) { var m = k.getLocalTransform(); v2 = v2.clone(); v2.applyTransform(m) } } e = kV(De({ width: v2.width, height: v2.height }, e), v3, Z); var Ij = k.position; var In = v1 ? e.x - v2.x : 0; var Il = Ik ? e.y - v2.y : 0; k.attr("position", Im === "raw" ? [In, Il] : [Ij[0] + In, Ij[1] + Il]) } function mW(i, e) { return i[kZ[e][0]] != null || (i[kZ[e][1]] != null && i[kZ[e][2]] != null) } function he(i, v, m) { !tJ(m) && (m = {}); var v2 = m.ignoreSize; !GG(v2) && (v2 = [v2, v2]); var v1 = Ij(kZ[0], 0); var k = Ij(kZ[1], 1); e(kZ[0], i, v1); e(kZ[1], i, k); function Ij(Iq, Ik) { var Io = {}; var Ip = 0; var Ir = {}; var Im = 0; var Is = 2; o6(Iq, function (It) { Ir[It] = i[It] }); o6(Iq, function (It) { Z(v, It) && (Io[It] = Ir[It] = v[It]); v3(Io, It) && Ip++; v3(Ir, It) && Im++ }); if (v2[Ik]) { if (v3(v, Iq[1])) { Ir[Iq[2]] = null } else { if (v3(v, Iq[2])) { Ir[Iq[1]] = null } } return Ir } if (Im === Is || !Ip) { return Ir } else { if (Ip >= Is) { return Io } else { for (var In = 0; In < Iq.length; In++) { var Il = Iq[In]; if (!Z(Io, Il) && Z(i, Il)) { Io[Il] = i[Il]; break } } return Io } } } function Z(Il, Ik) { return Il.hasOwnProperty(Ik) } function v3(Il, Ik) { return Il[Ik] != null && Il[Ik] !== "auto" } function e(Im, Il, Ik) { o6(Im, function (In) { Il[In] = Ik[In] }) } } function g2(e) { return FJ({}, e) } function FJ(i, e) { e && i && o6(rq, function (k) { e.hasOwnProperty(k) && (i[k] = e[k]) }); return i } var mj = { getBoxLayoutParams: function () { return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height") } } }; var hV = fK(); var aH = fv.extend({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor: function (k, i, e, m) { fv.call(this, k, i, e, m); this.uid = l8("ec_cpt_model") }, init: function (k, i, e, m) { this.mergeDefaultAndTheme(k, e) }, mergeDefaultAndTheme: function (i, e) { var m = this.layoutMode; var v = m ? g2(i) : {}; var k = e.getTheme(); v4(i, k.get(this.mainType)); v4(i, this.getDefaultOption()); if (m) { he(i, v, m) } }, mergeOption: function (e, k) { v4(this.option, e, true); var i = this.layoutMode; if (i) { he(this.option, e, i) } }, optionUpdated: function (e, i) { }, getDefaultOption: function () { var e = hV(this); if (!e.defaultOption) { var v = []; var m = this.constructor; while (m) { var v1 = m.prototype.defaultOption; v1 && v.push(v1); m = m.superClass } var k = {}; for (var Z = v.length - 1; Z >= 0; Z--) { k = v4(k, v[Z], true) } e.defaultOption = k } return e.defaultOption }, getReferringComponents: function (e) { return this.ecModel.queryComponents({ mainType: e, index: this.get(e + "Index", true), id: this.get(e + "Id", true) }) } }); yk(aH, { registerWhenExtend: true }); yT(aH); Eo(aH, gS); function gS(e) { var i = []; o9(aH.getClassesByMainType(e), function (k) { i = i.concat(k.prototype.dependencies || []) }); i = Ef(i, function (k) { return pd(k).main }); if (e !== "dataset" && eP(i, "dataset") <= 0) { i.unshift("dataset") } return i } Gq(aH, mj); var ty = ""; if (typeof navigator !== "undefined") { ty = navigator.platform || "" } var Gv = { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], textStyle: { fontFamily: ty.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, animation: "auto", animationDuration: 1000, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut", animationThreshold: 2000, progressiveThreshold: 3000, progressive: 400, hoverLayerThreshold: 3000, useUTC: false };
  var hU = fK(); function cV(k, e) { var v = k.length; for (var m = 0; m < v; m++) { if (k[m].length > e) { return k[m] } } return k[v - 1] } var yY = { clearColorPalette: function () { hU(this).colorIdx = 0; hU(this).colorNameMap = {} }, getColorFromPalette: function (e, v3, m) { v3 = v3 || this; var v1 = hU(v3); var Ij = v1.colorIdx || 0; var v = v1.colorNameMap = v1.colorNameMap || {}; if (v.hasOwnProperty(e)) { return v[e] } var Z = mp(this.get("color", true)); var v2 = this.get("colorLayer", true); var k = ((m == null || !v2) ? Z : cV(v2, m)); k = k || Z; if (!k || !k.length) { return } var i = k[Ij]; if (e) { v[e] = i } v1.colorIdx = (Ij + 1) % k.length; return i } }; function si(i) { var m = i.get("coordinateSystem"); var e = { coordSysName: m, coordSysDims: [], axisMap: CJ(), categoryAxisMap: CJ() }; var k = Cp[m]; if (k) { k(i, e, e.axisMap, e.categoryAxisMap); return e } } var Cp = { cartesian2d: function (i, e, v, Z) { var k = i.getReferringComponents("xAxis")[0]; var m = i.getReferringComponents("yAxis")[0]; if (ok) { if (!k) { throw new Error('xAxis "' + gu(i.get("xAxisIndex"), i.get("xAxisId"), 0) + '" not found') } if (!m) { throw new Error('yAxis "' + gu(i.get("xAxisIndex"), i.get("yAxisId"), 0) + '" not found') } } e.coordSysDims = ["x", "y"]; v.set("x", k); v.set("y", m); if (bV(k)) { Z.set("x", k); e.firstCategoryDimIndex = 0 } if (bV(m)) { Z.set("y", m); e.firstCategoryDimIndex = 1 } }, singleAxis: function (i, e, m, v) { var k = i.getReferringComponents("singleAxis")[0]; if (ok) { if (!k) { throw new Error("singleAxis should be specified.") } } e.coordSysDims = ["single"]; m.set("single", k); if (bV(k)) { v.set("single", k); e.firstCategoryDimIndex = 0 } }, polar: function (i, e, Z, v1) { var m = i.getReferringComponents("polar")[0]; var v = m.findAxisModel("radiusAxis"); var k = m.findAxisModel("angleAxis"); if (ok) { if (!k) { throw new Error("angleAxis option not found") } if (!v) { throw new Error("radiusAxis option not found") } } e.coordSysDims = ["radius", "angle"]; Z.set("radius", v); Z.set("angle", k); if (bV(v)) { v1.set("radius", v); e.firstCategoryDimIndex = 0 } if (bV(k)) { v1.set("angle", k); e.firstCategoryDimIndex = 1 } }, geo: function (i, e, k, m) { e.coordSysDims = ["lng", "lat"] }, parallel: function (k, i, Z, v1) { var e = k.ecModel; var v = e.getComponent("parallel", k.get("parallelIndex")); var m = i.coordSysDims = v.dimensions.slice(); o9(v.parallelAxisIndex, function (Ij, v2) { var v3 = e.getComponent("parallelAxis", Ij); var Ik = m[v2]; Z.set(Ik, v3); if (bV(v3) && i.firstCategoryDimIndex == null) { v1.set(Ik, v3); i.firstCategoryDimIndex = v2 } }) } }; function bV(e) { return e.get("type") === "category" } var fD = "original"; var h1 = "arrayRows"; var z0 = "objectRows"; var Hc = "keyedColumns"; var g6 = "unknown"; var wq = "typedArray"; var k3 = "column"; var bj = "row"; function qn(e) { this.fromDataset = e.fromDataset; this.data = e.data || (e.sourceFormat === Hc ? {} : []); this.sourceFormat = e.sourceFormat || g6; this.seriesLayoutBy = e.seriesLayoutBy || k3; this.dimensionsDefine = e.dimensionsDefine; this.encodeDefine = e.encodeDefine && CJ(e.encodeDefine); this.startIndex = e.startIndex || 0; this.dimensionsDetectCount = e.dimensionsDetectCount } qn.seriesDataToSource = function (e) { return new qn({ data: e, sourceFormat: HU(e) ? wq : fD, fromDataset: false }) }; z6(qn); var hS = fK(); function xn(v2) { var v1 = v2.option.source; var v = g6; if (HU(v1)) { v = wq } else { if (GG(v1)) { for (var m = 0, e = v1.length; m < e; m++) { var Z = v1[m]; if (Z == null) { continue } else { if (GG(Z)) { v = h1; break } else { if (tJ(Z)) { v = z0; break } } } } } else { if (tJ(v1)) { for (var k in v1) { if (v1.hasOwnProperty(k) && sP(v1[k])) { v = Hc; break } } } else { if (v1 != null) { throw new Error("Invalid data") } } } } hS(v2).sourceFormat = v } function ku(e) { return hS(e).source } function g8(e) { hS(e).datasetMap = CJ() } function kQ(m) { var v1 = m.option; var v = v1.data; var e = HU(v) ? wq : fD; var Z = false; var i = v1.seriesLayoutBy; var v3 = v1.sourceHeader; var k = v1.dimensions; var Ik = o2(m); if (Ik) { var Ij = Ik.option; v = Ij.source; e = hS(Ik).sourceFormat; Z = true; i = i || Ij.seriesLayoutBy; v3 == null && (v3 = Ij.sourceHeader); k = k || Ij.dimensions } var Il = A1(v, e, i, v3, k); var v2 = v1.encode; if (!v2 && Ik) { v2 = Hk(m, Ik, v, e, i, Il) } hS(m).source = new qn({ data: v, fromDataset: Z, seriesLayoutBy: i, sourceFormat: e, dimensionsDefine: Il.dimensionsDefine, startIndex: Il.startIndex, dimensionsDetectCount: Il.dimensionsDetectCount, encodeDefine: v2 }) } function A1(v, e, k, v3, m) { if (!v) { return { dimensionsDefine: Ea(m) } } var Z; var Ij; var i; if (e === h1) { if (v3 === "auto" || v3 == null) { DY(function (Ik) { if (Ik != null && Ik !== "-") { if (wb(Ik)) { Ij == null && (Ij = 1) } else { Ij = 0 } } }, k, v, 10) } else { Ij = v3 ? 1 : 0 } if (!m && Ij === 1) { m = []; DY(function (Il, Ik) { m[Ik] = Il != null ? Il : "" }, k, v) } Z = m ? m.length : k === bj ? v.length : v[0] ? v[0].length : null } else { if (e === z0) { if (!m) { m = Ao(v); i = true } } else { if (e === Hc) { if (!m) { m = []; i = true; o9(v, function (Il, Ik) { m.push(Ik) }) } } else { if (e === fD) { var v2 = xW(v[0]); Z = GG(v2) && v2.length || 1 } else { if (e === wq) { if (ok) { bM(!!m, "dimensions must be given if data is TypedArray.") } } } } } } var v1; if (i) { o9(m, function (Il, Ik) { if ((tJ(Il) ? Il.name : Il) === "name") { v1 = Ik } }) } return { startIndex: Ij, dimensionsDefine: Ea(m), dimensionsDetectCount: Z, potentialNameDimIndex: v1 } } function Ea(e) { if (!e) { return } var i = CJ(); return Ef(e, function (v, k) { v = b0({}, tJ(v) ? v : { name: v }); if (v.name == null) { return v } v.name += ""; if (v.displayName == null) { v.displayName = v.name } var m = i.get(v.name); if (!m) { i.set(v.name, { count: 1 }) } else { v.name += "-" + m.count++ } return v }) } function DY(e, v, v1, Z) {
    Z == null && (Z = Infinity); if (v === bj) {
      for (var m = 0;
        m < v1.length && m < Z; m++) { e(v1[m] ? v1[m][0] : null, m) }
    } else { var k = v1[0] || []; for (var m = 0; m < k.length && m < Z; m++) { e(k[m], m) } }
  } function Ao(k) { var e = 0; var m; while (e < k.length && !(m = k[e++])) { } if (m) { var i = []; o9(m, function (Z, v) { i.push(v) }); return i } } function Hk(In, Im, Is, Ij, v, Il) { var v1 = si(In); var v2 = {}; var v3 = []; var Z = []; var e = In.subType; var m = CJ(["pie", "map", "funnel"]); var k = CJ(["line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot"]); if (v1 && k.get(e) != null) { var Iu = In.ecModel; var Io = hS(Iu).datasetMap; var It = Im.uid + "_" + v; var Ip = Io.get(It) || Io.set(It, { categoryWayDim: 1, valueWayDim: 0 }); o9(v1.coordSysDims, function (Iv) { if (v1.firstCategoryDimIndex == null) { var i = Ip.valueWayDim++; v2[Iv] = i; Z.push(i) } else { if (v1.categoryAxisMap.get(Iv)) { v2[Iv] = 0; v3.push(0) } else { var i = Ip.categoryWayDim++; v2[Iv] = i; Z.push(i) } } }) } else { if (m.get(e) != null) { var Ik; for (var Iq = 0; Iq < 5 && Ik == null; Iq++) { if (!sY(Is, Ij, v, Il.dimensionsDefine, Il.startIndex, Iq)) { Ik = Iq } } if (Ik != null) { v2.value = Ik; var Ir = Il.potentialNameDimIndex || Math.max(Ik - 1, 0); Z.push(Ir); v3.push(Ir) } } } v3.length && (v2.itemName = v3); Z.length && (v2.seriesName = Z); return v2 } function o2(e) { var k = e.option; var i = k.data; if (!i) { return e.ecModel.getComponent("dataset", k.datasetIndex || 0) } } function vx(e, i) { return sY(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, i) } function sY(Ij, e, v, Z, Il, Im) { var Ip; var v1 = 5; if (HU(Ij)) { return false } var v2; if (Z) { v2 = Z[Im]; v2 = tJ(v2) ? v2.name : v2 } if (e === h1) { if (v === bj) { var Ik = Ij[Im]; for (var v3 = 0; v3 < (Ik || []).length && v3 < v1; v3++) { if ((Ip = k(Ik[Il + v3])) != null) { return Ip } } } else { for (var v3 = 0; v3 < Ij.length && v3 < v1; v3++) { var Io = Ij[Il + v3]; if (Io && (Ip = k(Io[Im])) != null) { return Ip } } } } else { if (e === z0) { if (!v2) { return } for (var v3 = 0; v3 < Ij.length && v3 < v1; v3++) { var In = Ij[v3]; if (In && (Ip = k(In[v2])) != null) { return Ip } } } else { if (e === Hc) { if (!v2) { return } var Ik = Ij[v2]; if (!Ik || HU(Ik)) { return false } for (var v3 = 0; v3 < Ik.length && v3 < v1; v3++) { if ((Ip = k(Ik[v3])) != null) { return Ip } } } else { if (e === fD) { for (var v3 = 0; v3 < Ij.length && v3 < v1; v3++) { var In = Ij[v3]; var m = xW(In); if (!GG(m)) { return false } if ((Ip = k(m[Im])) != null) { return Ip } } } } } } function k(i) { if (i != null && isFinite(i) && i !== "") { return false } else { if (wb(i) && i !== "-") { return true } } } return false } var DU = "\0_ec_inner"; var cj = fv.extend({
    init: function (k, i, m, e) { m = m || {}; this.option = null; this._theme = new fv(m); this._optionManager = e }, setOption: function (e, i) { bM(!(DU in e), "please use chart.getOption()"); this._optionManager.setOption(e, i); this.resetOption(null) }, resetOption: function (k) { var v = false; var i = this._optionManager; if (!k || k === "recreate") { var m = i.mountOption(k === "recreate"); if (!this.option || k === "recreate") { iy.call(this, m) } else { this.restoreData(); this.mergeOption(m) } v = true } if (k === "timeline" || k === "media") { this.restoreData() } if (!k || k === "recreate" || k === "timeline") { var Z = i.getTimelineOption(this); Z && (this.mergeOption(Z), v = true) } if (!k || k === "recreate" || k === "media") { var e = i.getMediaOption(this, this._api); if (e.length) { o9(e, function (v1) { this.mergeOption(v1, v = true) }, this) } } return v }, mergeOption: function (m) { var k = this.option; var e = this._componentsMap; var i = []; g8(this); o9(m, function (Z, v1) { if (Z == null) { return } if (!aH.hasClass(v1)) { k[v1] = k[v1] == null ? C5(Z) : v4(k[v1], Z, true) } else { if (v1) { i.push(v1) } } }); aH.topologicalTravel(i, aH.getAllClassMainTypes(), v, this); function v(Ij, v3) { var Z = mp(m[Ij]); var v2 = c9(e.get(Ij), Z); z3(v2); o9(v2, function (Im, Ik) { var Il = Im.option; if (tJ(Il)) { Im.keyInfo.mainType = Ij; Im.keyInfo.subType = e9(Ij, Il, Im.exist) } }); var v1 = zi(e, v3); k[Ij] = []; e.set(Ij, []); o9(v2, function (Il, Im) { var Ik = Il.exist; var In = Il.option; bM(tJ(In) || Ik, "Empty component definition"); if (!In) { Ik.mergeOption({}, this); Ik.optionUpdated({}, false) } else { var Io = aH.getClass(Ij, Il.keyInfo.subType, true); if (Ik && Ik instanceof Io) { Ik.name = Il.keyInfo.name; Ik.mergeOption(In, this); Ik.optionUpdated(In, false) } else { var Ip = b0({ dependentModels: v1, componentIndex: Im }, Il.keyInfo); Ik = new Io(In, this, this, Ip); b0(Ik, Ip); Ik.init(In, this, this, Ip); Ik.optionUpdated(null, true) } } e.get(Ij)[Im] = Ik; k[Ij][Im] = Ik.option }, this); if (Ij === "series") { D0(this, e.get("series")) } } this._seriesIndicesMap = CJ(this._seriesIndices = this._seriesIndices || []) }, getOption: function () { var e = C5(this.option); o9(e, function (m, v) { if (aH.hasClass(v)) { var m = mp(m); for (var k = m.length - 1; k >= 0; k--) { if (HF(m[k])) { m.splice(k, 1) } } e[v] = m } }); delete e[DU]; return e }, getTheme: function () { return this._theme }, getComponent: function (k, e) { var i = this._componentsMap.get(k); if (i) { return i[e || 0] } }, queryComponents: function (m) { var v1 = m.mainType; if (!v1) { return [] } var Z = m.index; var i = m.id; var e = m.name; var k = this._componentsMap.get(v1); if (!k || !k.length) { return [] } var v3; if (Z != null) { if (!GG(Z)) { Z = [Z] } v3 = q4(Ef(Z, function (Ij) { return k[Ij] }), function (Ij) { return !!Ij }) } else { if (i != null) { var v = GG(i); v3 = q4(k, function (Ij) { return (v && eP(i, Ij.id) >= 0) || (!v && Ij.id === i) }) } else { if (e != null) { var v2 = GG(e); v3 = q4(k, function (Ij) { return (v2 && eP(e, Ij.name) >= 0) || (!v2 && Ij.name === e) }) } else { v3 = k.slice() } } } return nJ(v3, m) }, findComponents: function (v1) {
      var m = v1.query; var Z = v1.mainType; var i = v(m); var e = i ? this.queryComponents(i) : this._componentsMap.get(Z);
      return k(nJ(e, v1)); function v(Ij) { var v3 = Z + "Index"; var Ik = Z + "Id"; var v2 = Z + "Name"; return Ij && (Ij[v3] != null || Ij[Ik] != null || Ij[v2] != null) ? { mainType: Z, index: Ij[v3], id: Ij[Ik], name: Ij[v2] } : null } function k(v2) { return v1.filter ? q4(v2, v1.filter) : v2 }
    }, eachComponent: function (v, e, k) { var i = this._componentsMap; if (typeof v === "function") { k = e; e = v; i.each(function (v1, Z) { o9(v1, function (v3, v2) { e.call(k, Z, v3, v2) }) }) } else { if (wb(v)) { o9(i.get(v), e, k) } else { if (tJ(v)) { var m = this.findComponents(v); o9(m, e, k) } } } }, getSeriesByName: function (e) { var i = this._componentsMap.get("series"); return q4(i, function (k) { return k.name === e }) }, getSeriesByIndex: function (e) { return this._componentsMap.get("series")[e] }, getSeriesByType: function (i) { var e = this._componentsMap.get("series"); return q4(e, function (k) { return k.subType === i }) }, getSeries: function () { return this._componentsMap.get("series").slice() }, getSeriesCount: function () { return this._componentsMap.get("series").length }, eachSeries: function (e, i) { kT(this); o9(this._seriesIndices, function (m) { var k = this._componentsMap.get("series")[m]; e.call(i, k, m) }, this) }, eachRawSeries: function (e, i) { o9(this._componentsMap.get("series"), e, i) }, eachSeriesByType: function (k, e, i) { kT(this); o9(this._seriesIndices, function (v) { var m = this._componentsMap.get("series")[v]; if (m.subType === k) { e.call(i, m, v) } }, this) }, eachRawSeriesByType: function (k, e, i) { return o9(this.getSeriesByType(k), e, i) }, isSeriesFiltered: function (e) { kT(this); return this._seriesIndicesMap.get(e.componentIndex) == null }, getCurrentSeriesIndices: function () { return (this._seriesIndices || []).slice() }, filterSeries: function (e, k) { kT(this); var i = q4(this._componentsMap.get("series"), e, k); D0(this, i) }, restoreData: function (k) { var i = this._componentsMap; D0(this, i.get("series")); var e = []; i.each(function (v, m) { e.push(m) }); aH.topologicalTravel(e, aH.getAllClassMainTypes(), function (m, v) { o9(i.get(m), function (Z) { (m !== "series" || !oc(Z, k)) && Z.restoreData() }) }) }
  }); function oc(e, m) { if (m) { var k = m.seiresIndex; var v = m.seriesId; var i = m.seriesName; return (k != null && e.componentIndex !== k) || (v != null && e.id !== v) || (i != null && e.name !== i) } } function ot(e, k) { var i = e.color && !e.colorLayer; o9(k, function (v, m) { if (m === "colorLayer" && i) { return } if (!aH.hasClass(m)) { if (typeof v === "object") { e[m] = !e[m] ? C5(v) : v4(e[m], v, false) } else { if (e[m] == null) { e[m] = v } } } }) } function iy(e) { e = e; this.option = {}; this.option[DU] = 1; this._componentsMap = CJ({ series: [] }); this._seriesIndices; this._seriesIndicesMap; ot(e, this._theme.option); v4(e, Gv, false); this.mergeOption(e) } function zi(e, k) { if (!GG(k)) { k = k ? [k] : [] } var i = {}; o9(k, function (m) { i[m] = (e.get(m) || []).slice() }); return i } function e9(m, i, e) { var k = i.type ? i.type : e ? e.subType : aH.determineSubType(m, i); return k } function D0(e, i) { e._seriesIndicesMap = CJ(e._seriesIndices = Ef(i, function (k) { return k.componentIndex }) || []) } function nJ(e, i) { return i.hasOwnProperty("subType") ? q4(e, function (k) { return k.subType === i.subType }) : e } function kT(e) { if (ok) { if (!e._seriesIndices) { throw new Error("Option should contains series.") } } } Gq(cj, yY); var iH = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"]; function lE(e) { o9(iH, function (i) { this[i] = km(e[i], e) }, this) } var DO = {}; function fz() { this._coordinateSystems = [] } fz.prototype = { constructor: fz, create: function (e, i) { var k = []; o9(DO, function (Z, m) { var v = Z.create(e, i); k = k.concat(v || []) }); this._coordinateSystems = k }, update: function (e, i) { o9(this._coordinateSystems, function (k) { k.update && k.update(e, i) }) }, getCoordinateSystems: function () { return this._coordinateSystems.slice() } }; fz.register = function (i, e) { DO[i] = e }; fz.get = function (e) { return DO[e] }; var o4 = o9; var uO = C5; var Ar = Ef; var le = v4; var HQ = /^(min|max)?(.+)$/; function mg(e) { this._api = e; this._timelineOptions = []; this._mediaList = []; this._mediaDefault; this._currentMediaIndices = []; this._optionBackup; this._newBaseOption } mg.prototype = {
    constructor: mg, setOption: function (i, m) { if (i) { o9(mp(i.series), function (v) { v && v.data && HU(v.data) && A(v.data) }) } i = uO(i, true); var e = this._optionBackup; var k = iw.call(this, i, m, !e); this._newBaseOption = k.baseOption; if (e) { DQ(e.baseOption, k.baseOption); if (k.timelineOptions.length) { e.timelineOptions = k.timelineOptions } if (k.mediaList.length) { e.mediaList = k.mediaList } if (k.mediaDefault) { e.mediaDefault = k.mediaDefault } } else { this._optionBackup = k } }, mountOption: function (i) { var e = this._optionBackup; this._timelineOptions = Ar(e.timelineOptions, uO); this._mediaList = Ar(e.mediaList, uO); this._mediaDefault = uO(e.mediaDefault); this._currentMediaIndices = []; return uO(i ? e.baseOption : this._newBaseOption) }, getTimelineOption: function (e) { var k; var i = this._timelineOptions; if (i.length) { var m = e.getComponent("timeline"); if (m) { k = uO(i[m.getCurrentIndex()], true) } } return k }, getMediaOption: function (v) {
      var e = this._api.getWidth(); var m = this._api.getHeight(); var v2 = this._mediaList; var v1 = this._mediaDefault; var v3 = []; var Ij = []; if (!v2.length && !v1) { return Ij } for (var k = 0, Z = v2.length; k < Z; k++) { if (ez(v2[k].query, e, m)) { v3.push(k) } } if (!v3.length && v1) {
        v3 = [-1]
      } if (v3.length && !lz(v3, this._currentMediaIndices)) { Ij = Ar(v3, function (i) { return uO(i === -1 ? v1.option : v2[i].option) }) } this._currentMediaIndices = v3; return Ij
    }
  }; function iw(i, k, m) { var Z = []; var v2 = []; var v; var v3; var v1 = i.timeline; if (i.baseOption) { v3 = i.baseOption } if (v1 || i.options) { v3 = v3 || {}; Z = (i.options || []).slice() } if (i.media) { v3 = v3 || {}; var e = i.media; o4(e, function (Ij) { if (Ij && Ij.option) { if (Ij.query) { v2.push(Ij) } else { if (!v) { v = Ij } } } }) } if (!v3) { v3 = i } if (!v3.timeline) { v3.timeline = v1 } o4([v3].concat(Z).concat(Ef(v2, function (Ij) { return Ij.option })), function (Ij) { o4(k, function (Ik) { Ik(Ij, m) }) }); return { baseOption: v3, timelineOptions: Z, mediaDefault: v, mediaList: v2 } } function ez(m, i, v) { var e = { width: i, height: v, aspectratio: i / v }; var k = true; o9(m, function (Ij, v2) { var v1 = v2.match(HQ); if (!v1 || !v1[1] || !v1[2]) { return } var v3 = v1[1]; var Z = v1[2].toLowerCase(); if (!C6(e[Z], Ij, v3)) { k = false } }); return k } function C6(k, i, e) { if (e === "min") { return k >= i } else { if (e === "max") { return k <= i } else { return k === i } } } function lz(i, e) { return i.join(",") === e.join(",") } function DQ(e, i) { i = i || {}; o4(i, function (v, Z) { if (v == null) { return } var m = e[Z]; if (!aH.hasClass(Z)) { e[Z] = le(m, v, true) } else { v = mp(v); m = mp(m); var k = c9(m, v); e[Z] = Ar(k, function (v1) { return (v1.option && v1.exist) ? le(v1.exist, v1.option, true) : (v1.exist || v1.option) }) } }) } var o3 = o9; var tH = tJ; var ms = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"]; function k5(Z) { var v1 = Z && Z.itemStyle; if (!v1) { return } for (var v = 0, e = ms.length; v < e; v++) { var m = ms[v]; var v2 = v1.normal; var k = v1.emphasis; if (v2 && v2[m]) { Z[m] = Z[m] || {}; if (!Z[m].normal) { Z[m].normal = v2[m] } else { v4(Z[m].normal, v2[m]) } v2[m] = null } if (k && k[m]) { Z[m] = Z[m] || {}; if (!Z[m].emphasis) { Z[m].emphasis = k[m] } else { v4(Z[m].emphasis, k[m]) } k[m] = null } } } function n4(i, e, m) { if (i && i[e] && (i[e].normal || i[e].emphasis)) { var k = i[e].normal; var v = i[e].emphasis; if (k) { if (m) { i[e].normal = i[e].emphasis = null; De(i[e], k) } else { i[e] = k } } if (v) { i.emphasis = i.emphasis || {}; i.emphasis[e] = v } } } function nh(e) { n4(e, "itemStyle"); n4(e, "lineStyle"); n4(e, "areaStyle"); n4(e, "label"); n4(e, "labelLine"); n4(e, "upperLabel"); n4(e, "edgeLabel") } function vp(m, v) { var v1 = tH(m) && m[v]; var Z = tH(v1) && v1.textStyle; if (Z) { for (var k = 0, e = Bl.length; k < e; k++) { var v = Bl[k]; if (Z.hasOwnProperty(v)) { v1[v] = Z[v] } } } } function cA(e) { if (e) { nh(e); vp(e, "label"); e.emphasis && vp(e.emphasis, "label") } } function Dp(Ij) { if (!tH(Ij)) { return } k5(Ij); nh(Ij); vp(Ij, "label"); vp(Ij, "upperLabel"); vp(Ij, "edgeLabel"); if (Ij.emphasis) { vp(Ij.emphasis, "label"); vp(Ij.emphasis, "upperLabel"); vp(Ij.emphasis, "edgeLabel") } var v3 = Ij.markPoint; if (v3) { k5(v3); cA(v3) } var e = Ij.markLine; if (e) { k5(e); cA(e) } var k = Ij.markArea; if (k) { cA(k) } var m = Ij.data; if (Ij.type === "graph") { m = m || Ij.nodes; var v1 = Ij.links || Ij.edges; if (v1 && !HU(v1)) { for (var v = 0; v < v1.length; v++) { cA(v1[v]) } } o9(Ij.categories, function (i) { nh(i) }) } if (m && !HU(m)) { for (var v = 0; v < m.length; v++) { cA(m[v]) } } var v3 = Ij.markPoint; if (v3 && v3.data) { var Z = v3.data; for (var v = 0; v < Z.length; v++) { cA(Z[v]) } } var e = Ij.markLine; if (e && e.data) { var v2 = e.data; for (var v = 0; v < v2.length; v++) { if (GG(v2[v])) { cA(v2[v][0]); cA(v2[v][1]) } else { cA(v2[v]) } } } if (Ij.type === "gauge") { vp(Ij, "axisLabel"); vp(Ij, "title"); vp(Ij, "detail") } else { if (Ij.type === "treemap") { n4(Ij.breadcrumb, "itemStyle"); o9(Ij.levels, function (i) { nh(i) }) } else { if (Ij.type === "tree") { nh(Ij.leaves) } } } } function Bw(e) { return GG(e) ? e : e ? [e] : [] } function tk(e) { return (GG(e) ? e[0] : e) || {} } var yV = function (e, k) { o3(Bw(e.series), function (m) { tH(m) && Dp(m) }); var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"]; k && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"); o3(i, function (m) { o3(Bw(e[m]), function (v) { if (v) { vp(v, "axisLabel"); vp(v.axisPointer, "label") } }) }); o3(Bw(e.parallel), function (v) { var m = v && v.parallelAxisDefault; vp(m, "axisLabel"); vp(m && m.axisPointer, "label") }); o3(Bw(e.calendar), function (m) { n4(m, "itemStyle"); vp(m, "dayLabel"); vp(m, "monthLabel"); vp(m, "yearLabel") }); o3(Bw(e.radar), function (m) { vp(m, "name") }); o3(Bw(e.geo), function (m) { if (tH(m)) { cA(m); o3(Bw(m.regions), function (v) { cA(v) }) } }); o3(Bw(e.timeline), function (m) { cA(m); n4(m, "label"); n4(m, "itemStyle"); n4(m, "controlStyle", true); var v = m.data; GG(v) && o9(v, function (Z) { if (tJ(Z)) { n4(Z, "label"); n4(Z, "itemStyle") } }) }); o3(Bw(e.toolbox), function (m) { n4(m, "iconStyle"); o3(m.feature, function (v) { n4(v, "iconStyle") }) }); vp(tk(e.axisPointer), "label"); vp(tk(e.tooltip).axisPointer, "label") }; function ym(k, v) { v = v.split(","); var m = k; for (var e = 0; e < v.length; e++) { m = m && m[v[e]]; if (m == null) { break } } return m } function md(v, v1, v2, e) { v1 = v1.split(","); var Z = v; var m; for (var k = 0; k < v1.length - 1; k++) { m = v1[k]; if (Z[m] == null) { Z[m] = {} } Z = Z[m] } if (e || Z[v1[k]] == null) { Z[v1[k]] = v2 } } function Bf(e) { o9(nY, function (i) { if (i[0] in e && !(i[1] in e)) { e[i[1]] = e[i[0]] } }) } var nY = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]]; var z2 = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"]; var Hr = function (e, i) {
    yV(e, i); e.series = mp(e.series); o9(e.series, function (k) {
      if (!tJ(k)) { return } var v = k.type; if (v === "pie" || v === "gauge") {
        if (k.clockWise != null) {
          k.clockwise = k.clockWise
        }
      } if (v === "gauge") { var m = ym(k, "pointer.color"); m != null && md(k, "itemStyle.normal.color", m) } Bf(k)
    }); if (e.dataRange) { e.visualMap = e.dataRange } o9(z2, function (k) { var m = e[k]; if (m) { if (!GG(m)) { m = [m] } o9(m, function (v) { Bf(v) }) } })
  }; var vZ = function (e) { var i = CJ(); e.eachSeries(function (m) { var k = m.get("stack"); if (k) { var v = i.get(k) || i.set(k, []); var Z = m.getData(); var v1 = { stackResultDimension: Z.getCalculationInfo("stackResultDimension"), stackedOverDimension: Z.getCalculationInfo("stackedOverDimension"), stackedDimension: Z.getCalculationInfo("stackedDimension"), stackedByDimension: Z.getCalculationInfo("stackedByDimension"), isStackedByIndex: Z.getCalculationInfo("isStackedByIndex"), data: Z, seriesModel: m }; if (!v1.stackedDimension || !(v1.isStackedByIndex || v1.stackedByDimension)) { return } v.length && Z.setCalculationInfo("stackedOnSeries", v[v.length - 1].seriesModel); v.push(v1) } }); i.each(qo) }; function qo(e) { o9(e, function (m, k) { var Z = []; var i = [NaN, NaN]; var v3 = [m.stackResultDimension, m.stackedOverDimension]; var v2 = m.data; var v = m.isStackedByIndex; var v1 = v2.map(v3, function (Ir, Iq, Ip) { var Io = v2.get(m.stackedDimension, Ip); if (isNaN(Io)) { return i } var Is; var Il; if (v) { Il = v2.getRawIndex(Ip) } else { Is = v2.get(m.stackedByDimension, Ip) } var Ij = NaN; for (var In = k - 1; In >= 0; In--) { var Ik = e[In]; if (!v) { Il = Ik.data.rawIndexOf(Ik.stackedByDimension, Is) } if (Il >= 0) { var Im = Ik.data.getByRawIndex(Ik.stackResultDimension, Il); if ((Io >= 0 && Im > 0) || (Io <= 0 && Im < 0)) { Io += Im; Ij = Im; break } } } Z[0] = Io; Z[1] = Ij; return Z }); v2.hostModel.setData(v1); m.data = v1 }) } function fS(m, v) { if (!qn.isInstance(m)) { m = qn.seriesDataToSource(m) } this._source = m; var k = this._data = m.data; var i = m.sourceFormat; if (i === wq) { if (ok) { if (v == null) { throw new Error("Typed array data must specify dimension size") } } this._offset = 0; this._dimSize = v; this._data = k } var e = oW[i === h1 ? i + "_" + m.seriesLayoutBy : i]; if (ok) { bM(e, "Invalide sourceFormat: " + i) } b0(this, e) } var pP = fS.prototype; pP.pure = false; pP.persistent = true; pP.getSource = function () { return this._source }; var oW = { "arrayRows_column": { pure: true, count: function () { return Math.max(0, this._data.length - this._source.startIndex) }, getItem: function (e) { return this._data[e + this._source.startIndex] }, appendData: dW }, "arrayRows_row": { pure: true, count: function () { var e = this._data[0]; return e ? Math.max(0, e.length - this._source.startIndex) : 0 }, getItem: function (e) { e += this._source.startIndex; var m = []; var v = this._data; for (var k = 0; k < v.length; k++) { var Z = v[k]; m.push(Z ? Z[e] : null) } return m }, appendData: function () { throw new Error('Do not support appendData when set seriesLayoutBy: "row".') } }, "objectRows": { pure: true, count: CY, getItem: zm, appendData: dW }, "keyedColumns": { pure: true, count: function () { var i = this._source.dimensionsDefine[0].name; var e = this._data[i]; return e ? e.length : 0 }, getItem: function (e) { var v = []; var Z = this._source.dimensionsDefine; for (var m = 0; m < Z.length; m++) { var k = this._data[Z[m].name]; v.push(k ? k[e] : null) } return v }, appendData: function (e) { var i = this._data; o9(e, function (Z, m) { var v = i[m] || (i[m] = []); for (var k = 0; k < (Z || []).length; k++) { v.push(Z[k]) } }) } }, "original": { count: CY, getItem: zm, appendData: dW }, "typedArray": { persistent: false, pure: true, count: function () { return this._data ? (this._data.length / this._dimSize) : 0 }, getItem: function (e, k) { e = e - this._offset; k = k || []; var v = this._dimSize * e; for (var m = 0; m < this._dimSize; m++) { k[m] = this._data[v + m] } return k }, appendData: function (e) { if (ok) { bM(HU(e), "Added data must be TypedArray if data in initialization is TypedArray") } this._data = e }, clean: function () { this._offset += this.count(); this._data = null } } }; function CY() { return this._data.length } function zm(e) { return this._data[e] } function dW(k) { for (var e = 0; e < k.length; e++) { this._data.push(k[e]) } } var gp = { arrayRows: DN, objectRows: function (e, i, m, k) { return m != null ? e[k] : e }, keyedColumns: DN, original: function (e, i, v, m) { var k = xW(e); return (v == null || !(k instanceof Array)) ? k : k[v] }, typedArray: DN }; function DN(e, i, m, k) { return m != null ? e[m] : e } var kG = { arrayRows: Fs, objectRows: function (e, m, i, k) { return kO(e[m], this._dimensionInfos[m]) }, keyedColumns: Fs, original: function (e, v, i, m) { var k = e && (e.value == null ? e : e.value); if (!this._rawData.pure && oa(e)) { this.hasItemOption = true } return kO((k instanceof Array) ? k[m] : k, this._dimensionInfos[v]) }, typedArray: function (e, m, i, k) { return e[k] } }; function Fs(e, m, i, k) { return kO(e[k], this._dimensionInfos[m]) } function kO(k, i) { var m = i && i.type; if (m === "ordinal") { var e = i && i.ordinalMeta; return e ? e.parseAndCollect(k) : k } if (m === "time" && typeof k !== "number" && k != null && k !== "-") { k = +vS(k) } return (k == null || k === "") ? NaN : +k } function i5(v, m, v2) { if (!v) { return } var i = v.getRawDataItem(m); if (i == null) { return } var k = v.getProvider().getSource().sourceFormat; var v1; var Z; var e = v.getDimensionInfo(v2); if (e) { v1 = e.name; Z = e.index } return gp[k](i, m, Z, v1) } function Gz(v, m, e) { if (!v) { return } var k = v.getProvider().getSource().sourceFormat; if (k !== fD && k !== z0) { return } var i = v.getRawDataItem(m); if (k === fD && !tJ(i)) { i = null } if (i) { return i[e] } } var C2 = /\{@(.+?)\}/g; var u8 = {
    getDataParams: function (v2, v3) {
      var Z = this.getData(v3); var k = this.getRawValue(v2, v3); var v1 = Z.getRawIndex(v2); var e = Z.getName(v2); var v = Z.getRawDataItem(v2);
      var m = Z.getItemVisual(v2, "color"); var Ij = this.ecModel.getComponent("tooltip"); var i = Ij && Ij.get("renderMode"); var Ik = wg(i); return { componentType: this.mainType, componentSubType: this.subType, seriesType: this.mainType === "series" ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: this.id, seriesName: this.name, name: e, dataIndex: v1, data: v, dataType: v3, value: k, color: m, marker: zu({ color: m, renderMode: Ik }), $vars: ["seriesName", "name", "value"] }
    }, getFormattedLabel: function (Z, i, v1, v3, k) { i = i || "normal"; var m = this.getData(v1); var Ij = m.getItemModel(Z); var e = this.getDataParams(Z, v1); if (v3 != null && (e.value instanceof Array)) { e.value = e.value[v3] } var v2 = Ij.get(i === "normal" ? [k || "label", "formatter"] : [i, k || "label", "formatter"]); if (typeof v2 === "function") { e.status = i; return v2(e) } else { if (typeof v2 === "string") { var v = ew(v2, e); return v.replace(C2, function (Il, Im) { var Ik = Im.length; if (Im.charAt(0) === "[" && Im.charAt(Ik - 1) === "]") { Im = +Im.slice(1, Ik - 1) } return i5(m, Z, Im) }) } } }, getRawValue: function (e, i) { return i5(this.getData(i), e) }, formatTooltip: function () { }
  }; function Ca(e) { return new tM(e) } function tM(e) { e = e || {}; this._reset = e.reset; this._plan = e.plan; this._count = e.count; this._onDirty = e.onDirty; this._dirty = true; this.context } var la = tM.prototype; la.perform = function (Ir) { var Io = this._upstream; var Ip = Ir && Ir.skip; if (this._dirty && Io) { var Z = this.context; Z.data = Z.outputData = Io.context.outputData } if (this.__pipeline) { this.__pipeline.currentTask = this } var v2; if (this._plan && !Ip) { v2 = this._plan(this.context) } var k = Im(this._modBy); var Il = this._modDataCount || 0; var m = Im(Ir && Ir.modBy); var In = Ir && Ir.modDataCount || 0; if (k !== m || Il !== In) { v2 = "reset" } function Im(i) { !(i >= 1) && (i = 1); return i } var Iq; if (this._dirty || v2 === "reset") { this._dirty = false; Iq = ze(this, Ip) } this._modBy = m; this._modDataCount = In; var v1 = Ir && Ir.step; if (Io) { if (ok) { bM(Io._outputDueEnd != null) } this._dueEnd = Io._outputDueEnd } else { if (ok) { bM(!this._progress || this._count) } this._dueEnd = this._count ? this._count(this.context) : Infinity } if (this._progress) { var v = this._dueIndex; var Ij = Math.min(v1 != null ? this._dueIndex + v1 : Infinity, this._dueEnd); if (!Ip && (Iq || v < Ij)) { var e = this._progress; if (GG(e)) { for (var Ik = 0; Ik < e.length; Ik++) { vI(this, e[Ik], v, Ij, m, In) } } else { vI(this, e, v, Ij, m, In) } } this._dueIndex = Ij; var v3 = this._settedOutputEnd != null ? this._settedOutputEnd : Ij; if (ok) { bM(v3 >= this._outputDueEnd) } this._outputDueEnd = v3 } else { this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd } return this.unfinished() }; var iU = (function () { var e; var v1; var Z; var m; var i; var k = { reset: function (Ij, Ik, v3, Il) { v1 = Ij; e = Ik; Z = v3; m = Il; i = Math.ceil(m / Z); k.next = (Z > 1 && m > 0) ? v2 : v } }; return k; function v() { return v1 < e ? v1++ : null } function v2() { var Ij = (v1 % i) * Z + Math.ceil(v1 / i); var v3 = v1 >= e ? null : Ij < m ? Ij : v1; v1++; return v3 } })(); la.dirty = function () { this._dirty = true; this._onDirty && this._onDirty(this.context) }; function vI(m, i, Z, e, v, k) { iU.reset(Z, e, v, k); m._callingProgress = i; m._callingProgress({ start: Z, end: e, count: e - Z, next: iU.next }, m.context) } function ze(v, i) { v._dueIndex = v._outputDueEnd = v._dueEnd = 0; v._settedOutputEnd = null; var e; var m; if (!i && v._reset) { e = v._reset(v.context); if (e && e.progress) { m = e.forceFirstProgress; e = e.progress } if (GG(e) && !e.length) { e = null } } v._progress = e; v._modBy = v._modDataCount = null; var k = v._downstream; k && k.dirty(); return m } la.unfinished = function () { return this._progress && this._dueIndex < this._dueEnd }; la.pipe = function (e) { if (ok) { bM(e && !e._disposed && e !== this) } if (this._downstream !== e || this._dirty) { this._downstream = e; e._upstream = this; e.dirty() } }; la.dispose = function () { if (this._disposed) { return } this._upstream && (this._upstream._downstream = null); this._downstream && (this._downstream._upstream = null); this._dirty = false; this._disposed = true }; la.getUpstream = function () { return this._upstream }; la.getDownstream = function () { return this._downstream }; la.setOutputEnd = function (e) { this._outputDueEnd = this._settedOutputEnd = e }; var hQ = fK(); var nU = aH.extend({
    type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendDataProvider: null, visualColorAccessPath: "itemStyle.color", layoutMode: null, init: function (k, i, e, v) { this.seriesIndex = this.componentIndex; this.dataTask = Ca({ count: pR, reset: lh }); this.dataTask.context = { model: this }; this.mergeDefaultAndTheme(k, e); kQ(this); var m = this.getInitialData(k, e); uR(m, this); this.dataTask.context.data = m; if (ok) { bM(m, "getInitialData returned invalid data.") } hQ(this).dataBeforeProcessed = m; pj(this) }, mergeDefaultAndTheme: function (i, e) { var m = this.layoutMode; var v = m ? g2(i) : {}; var k = this.subType; if (aH.hasClass(k)) { k += "Series" } v4(i, e.getTheme().get(this.subType)); v4(i, this.getDefaultOption()); DA(i, "label", ["show"]); this.fillDataTextStyle(i.data); if (m) { he(i, v, m) } }, mergeOption: function (i, e) { i = v4(this.option, i, true); this.fillDataTextStyle(i.data); var m = this.layoutMode; if (m) { he(this.option, i, m) } kQ(this); var k = this.getInitialData(i, e); uR(k, this); this.dataTask.dirty(); this.dataTask.context.data = k; hQ(this).dataBeforeProcessed = k; pj(this) }, fillDataTextStyle: function (m) {
      if (m && !HU(m)) {
        var k = ["show"]; for (var e = 0; e < m.length; e++) {
          if (m[e] && m[e].label) {
            DA(m[e], "label", k)
          }
        }
      }
    }, getInitialData: function () { }, appendData: function (i) { var e = this.getRawData(); e.appendData(i.data) }, getData: function (i) { var e = mN(this); if (e) { var k = e.context.data; return i == null ? k : k.getLinkedData(i) } else { return hQ(this).data } }, setData: function (k) { var e = mN(this); if (e) { var i = e.context; if (i.data !== k && e.modifyOutputEnd) { e.setOutputEnd(k.count()) } i.outputData = k; if (e !== this.dataTask) { i.data = k } } hQ(this).data = k }, getSource: function () { return ku(this) }, getRawData: function () { return hQ(this).dataBeforeProcessed }, getBaseAxis: function () { var e = this.coordinateSystem; return e && e.getBaseAxis && e.getBaseAxis() }, formatTooltip: function (Iv, It, Io, k) { var v2 = this; k = k || "html"; var Iu = k === "html" ? "<br/>" : "\n"; var Ik = k === "richText"; var Ir = {}; var Iy = 0; function Il(IC) { var IA = xc(IC, function (IH, II, IG) { var IF = Iw.getDimensionInfo(IG); return IH |= IF && IF.tooltip !== false && IF.displayName != null }, 0); var Iz = []; m.length ? o9(m, function (IF) { ID(i5(Iw, Iv, IF), IF) }) : o9(IC, ID); function ID(IL, II) { var IF = Iw.getDimensionInfo(II); if (!IF || IF.otherDims.tooltip === false) { return } var IM = IF.type; var IH = "sub" + v2.seriesIndex + "at" + Iy; var IK = zu({ color: Ip, type: "subItem", renderMode: k, markerId: IH }); var IJ = typeof IK === "string" ? IK : IK.content; var IG = (IA ? IJ + mv(IF.displayName || "-") + ": " : "") + mv(IM === "ordinal" ? IL + "" : IM === "time" ? (It ? "" : mT("yyyy/MM/dd hh:mm:ss", IL)) : j7(IL)); IG && Iz.push(IG); if (Ik) { Ir[IH] = Ip; ++Iy } } var IE = IA ? (Ik ? "\n" : "<br/>") : ""; var IB = IE + Iz.join(IE || ", "); return { renderMode: k, content: IB, style: Ir } } function e(Iz) { return { renderMode: k, content: mv(j7(Iz)), style: Ir } } var Iw = this.getData(); var m = Iw.mapDimension("defaultedTooltip", true); var Z = m.length; var Im = this.getRawValue(Iv); var Iq = GG(Im); var Ip = Iw.getItemVisual(Iv, "color"); if (tJ(Ip) && Ip.colorStops) { Ip = (Ip.colorStops[0] || {}).color } Ip = Ip || "transparent"; var v = (Z > 1 || (Iq && !Z)) ? Il(Im) : Z ? e(i5(Iw, Iv, m[0])) : e(Iq ? Im[0] : Im); var In = v.content; var v1 = v2.seriesIndex + "at" + Iy; var i = zu({ color: Ip, type: "item", renderMode: k, markerId: v1 }); Ir[v1] = Ip; ++Iy; var Ix = Iw.getName(Iv); var Is = this.name; if (!qV(this)) { Is = "" } Is = Is ? mv(Is) + (!It ? Iu : ": ") : ""; var Ij = typeof i === "string" ? i : i.content; var v3 = !It ? Is + Ij + (Ix ? mv(Ix) + ": " + In : In) : Ij + Is + In; return { html: v3, markers: Ir } }, isAnimationEnabled: function () { if (sW.node) { return false } var e = this.getShallow("animation"); if (e) { if (this.getData().count() > this.getShallow("animationThreshold")) { e = false } } return e }, restoreData: function () { this.dataTask.dirty() }, getColorFromPalette: function (m, v, i) { var e = this.ecModel; var k = yY.getColorFromPalette.call(this, m, v, i); if (!k) { k = e.getColorFromPalette(m, v, i) } return k }, coordDimToDataDim: function (e) { return this.getRawData().mapDimension(e, true) }, getProgressive: function () { return this.get("progressive") }, getProgressiveThreshold: function () { return this.get("progressiveThreshold") }, getAxisTooltipData: null, getTooltipPosition: null, pipeTask: null, preventIncremental: null, pipelineContext: null
  }); Gq(nU, u8); Gq(nU, yY); function pj(e) { var i = e.name; if (!qV(e)) { e.name = lF(e) || i } } function lF(i) { var m = i.getRawData(); var k = m.mapDimension("seriesName", true); var e = []; o9(k, function (Z) { var v = m.getDimensionInfo(Z); v.displayName && e.push(v.displayName) }); return e.join(" ") } function pR(e) { return e.model.getRawData().count() } function lh(i) { var e = i.model; e.setData(e.getRawData().cloneShallow()); return dH } function dH(i, e) { if (i.end > e.outputData.count()) { e.model.getRawData().cloneShallow(e.outputData) } } function uR(i, e) { o9(i.CHANGABLE_METHODS, function (k) { i.wrapMethod(k, sv(fw, e)) }) } function fw(i) { var e = mN(i); if (e) { e.setOutputEnd(this.count()) } } function mN(i) { var m = (i.ecModel || {}).scheduler; var k = m && m.getPipeline(i.uid); if (k) { var e = k.currentTask; if (e) { var v = e.agentStubMap; if (v) { e = v.get(i.uid) } } return e } } var sT = function () { this.group = new B8(); this.uid = l8("viewComponent") }; sT.prototype = { constructor: sT, init: function (e, i) { }, render: function (i, e, k, m) { }, dispose: function () { }, filterForExposedEvent: null }; var jW = sT.prototype; jW.updateView = jW.updateLayout = jW.updateVisual = function (i, e, k, m) { }; AG(sT); yk(sT, { registerWhenExtend: true }); var Es = function () { var e = fK(); return function (k) { var i = e(k); var v1 = k.pipelineContext; var v2 = i.large; var v = i.progressiveRender; var m = i.large = v1.large; var Z = i.progressiveRender = v1.progressiveRender; return !!((v2 ^ m) || (v ^ Z)) && "reset" } }; var hN = fK(); var EM = Es(); function dF() { this.group = new B8(); this.uid = l8("viewChart"); this.renderTask = Ca({ plan: ab, reset: lD }); this.renderTask.context = { view: this } } dF.prototype = { type: "chart", init: function (e, i) { }, render: function (i, e, k, m) { }, highlight: function (i, e, k, m) { Df(i.getData(), m, "emphasis") }, downplay: function (i, e, k, m) { Df(i.getData(), m, "normal") }, remove: function (e, i) { this.group.removeAll() }, dispose: function () { }, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null }; var pH = dF.prototype; pH.updateView = pH.updateLayout = pH.updateVisual = function (i, e, k, m) { this.render(i, e, k, m) }; function vG(k, m) { if (k) { k.trigger(m); if (k.type === "group") { for (var e = 0; e < k.childCount(); e++) { vG(k.childAt(e), m) } } } } function Df(k, m, i) {
    var e = xe(k, m); if (e != null) {
      o9(mp(e), function (v) {
        vG(k.getItemGraphicEl(v), i)
      })
    } else { k.eachItemGraphicEl(function (v) { vG(v, i) }) }
  } AG(dF, ["dispose"]); yk(dF, { registerWhenExtend: true }); dF.markUpdateMethod = function (i, e) { hN(i).updateMethod = e }; function ab(e) { return EM(e.model) } function lD(e) { var i = e.model; var m = e.ecModel; var v = e.api; var v3 = e.payload; var Z = i.pipelineContext.progressiveRender; var v1 = e.view; var k = v3 && hN(v3).updateMethod; var v2 = Z ? "incrementalPrepareRender" : (k && v1[k]) ? k : "render"; if (v2 !== "render") { v1[v2](i, m, v, v3) } return sk[v2] } var sk = { incrementalPrepareRender: { progress: function (i, e) { e.view.incrementalRender(i, e.model, e.ecModel, e.api, e.payload) } }, render: { forceFirstProgress: true, progress: function (i, e) { e.view.render(e.model, e.ecModel, e.api, e.payload) } } }; var d4 = "\0__throttleOriginMethod"; var kp = "\0__throttleRate"; var AE = "\0__throttleType"; function e1(v3, Z, Il) { var k; var Ik = 0; var i = 0; var e = null; var Ij; var Im; var v1; var v2; Z = Z || 0; function v() { i = (new Date()).getTime(); e = null; v3.apply(Im, v1 || []) } var m = function () { k = (new Date()).getTime(); Im = this; v1 = arguments; var Io = v2 || Z; var In = v2 || Il; v2 = null; Ij = k - (In ? Ik : i) - Io; clearTimeout(e); if (In) { e = setTimeout(v, Io) } else { if (Ij >= 0) { v() } else { e = setTimeout(v, -Ij) } } Ik = k }; m.clear = function () { if (e) { clearTimeout(e); e = null } }; m.debounceNextCall = function (In) { v2 = In }; return m } function mK(Z, v, m, v2) { var k = Z[v]; if (!k) { return } var e = k[d4] || k; var v1 = k[AE]; var i = k[kp]; if (i !== m || v1 !== v2) { if (m == null || !v2) { return (Z[v] = e) } k = Z[v] = e1(e, m, v2 === "debounce"); k[d4] = e; k[AE] = v2; k[kp] = m } return k } function cG(k, i) { var e = k[i]; if (e && e[d4]) { k[i] = e[d4] } } var CC = { createOnAllSeries: true, performRawSeries: true, reset: function (m, e) { var Z = m.getData(); var k = (m.visualColorAccessPath || "itemStyle.color").split("."); var i = m.get(k) || m.getColorFromPalette(m.name, null, e.getSeriesCount()); Z.setVisual("color", i); if (!e.isSeriesFiltered(m)) { if (typeof i === "function" && !(i instanceof lV)) { Z.each(function (v1) { Z.setItemVisual(v1, "color", i(m.getDataParams(v1))) }) } var v = function (Ij, v1) { var v3 = Ij.getItemModel(v1); var v2 = v3.get(k, true); if (v2 != null) { Ij.setItemVisual(v1, "color", v2) } }; return { dataEach: Z.hasItemOption ? v : null } } } }; var Cn = { toolbox: { brush: { title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } }, dataView: { title: "", lang: ["", "", ""] }, dataZoom: { title: { zoom: "", back: "" } }, magicType: { title: { line: "", bar: "", stack: "", tiled: "" } }, restore: { title: "" }, saveAsImage: { title: "", lang: [""] } }, series: { typeNames: { pie: "", bar: "", line: "", scatter: "", effectScatter: "", radar: "", tree: "", treemap: "", boxplot: "", candlestick: "K", k: "K", heatmap: "", map: "", parallel: "", lines: "", graph: "", sankey: "", funnel: "", gauge: "", pictorialBar: "", themeRiver: "", sunburst: "" } }, aria: { general: { withTitle: "{title}", withoutTitle: "" }, series: { single: { prefix: "", withName: "{seriesType}{seriesName}", withoutName: "{seriesType}" }, multiple: { prefix: "{seriesCount}", withName: "{seriesId}{seriesName}{seriesType}", withoutName: "{seriesId}{seriesType}", separator: { middle: "", end: "" } } }, data: { allData: "", partialData: "{displayCnt}", withName: "{name}{value}", withoutName: "{value}", separator: { middle: "", end: "" } } } }; var ib = function (v, v2) { var Z = v2.getModel("aria"); if (!Z.get("show")) { return } else { if (Z.get("description")) { v.setAttribute("aria-label", Z.get("description")); return } } var i = 0; v2.eachSeries(function (Iq, Ip) { ++i }, this); var In = Z.get("data.maxCount") || 10; var Io = Z.get("series.maxCount") || 10; var e = Math.min(i, Io); var Ik; if (i < 1) { return } else { var Im = m(); if (Im) { Ik = k(Il("general.withTitle"), { title: Im }) } else { Ik = Il("general.withoutTitle") } var Ij = []; var v1 = i > 1 ? "series.multiple.prefix" : "series.single.prefix"; Ik += k(Il(v1), { seriesCount: i }); v2.eachSeries(function (Iq, Iy) { if (Iy < e) { var Iv; var Iw = Iq.get("name"); var Ir = "series." + (i > 1 ? "multiple" : "single") + "."; Iv = Il(Iw ? Ir + "withName" : Ir + "withoutName"); Iv = k(Iv, { seriesId: Iq.seriesIndex, seriesName: Iq.get("name"), seriesType: v3(Iq.subType) }); var Is = Iq.getData(); window.data = Is; if (Is.count() > In) { Iv += k(Il("data.partialData"), { displayCnt: In }) } else { Iv += Il("data.allData") } var Iu = []; for (var It = 0; It < Is.count(); It++) { if (It < In) { var Ip = Is.getName(It); var Ix = i5(Is, It); Iu.push(k(Ip ? Il("data.withName") : Il("data.withoutName"), { name: Ip, value: Ix })) } } Iv += Iu.join(Il("data.separator.middle")) + Il("data.separator.end"); Ij.push(Iv) } }); Ik += Ij.join(Il("series.multiple.separator.middle")) + Il("series.multiple.separator.end"); v.setAttribute("aria-label", Ik) } function k(Ir, Iq) { if (typeof Ir !== "string") { return Ir } var Ip = Ir; o9(Iq, function (It, Is) { Ip = Ip.replace(new RegExp("\\{\\s*" + Is + "\\s*\\}", "g"), It) }); return Ip } function Il(It) { var Ir = Z.get(It); if (Ir == null) { var Is = It.split("."); var Ip = Cn.aria; for (var Iq = 0; Iq < Is.length; ++Iq) { Ip = Ip[Is[Iq]] } return Ip } else { return Ir } } function m() { var Ip = v2.getModel("title").option; if (Ip && Ip.length) { Ip = Ip[0] } return Ip && Ip.text } function v3(Ip) { return Cn.series.typeNames[Ip] || "" } }; var yF = Math.PI; var uI = function (m, v) {
    v = v || {}; De(v, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 });
    var e = new EH({ style: { fill: v.maskColor }, zlevel: v.zlevel, z: 10000 }); var k = new pS({ shape: { startAngle: -yF / 2, endAngle: -yF / 2 + 0.1, r: 10 }, style: { stroke: v.color, lineCap: "round", lineWidth: 5 }, zlevel: v.zlevel, z: 10001 }); var i = new EH({ style: { fill: "none", text: v.text, textPosition: "right", textDistance: 10, textFill: v.textColor }, zlevel: v.zlevel, z: 10001 }); k.animateShape(true).when(1000, { endAngle: yF * 3 / 2 }).start("circularInOut"); k.animateShape(true).when(1000, { startAngle: yF * 3 / 2 }).delay(300).start("circularInOut"); var Z = new B8(); Z.add(k); Z.add(i); Z.add(e); Z.resize = function () { var v1 = m.getWidth() / 2; var v3 = m.getHeight() / 2; k.setShape({ cx: v1, cy: v3 }); var v2 = k.shape.r; i.setShape({ x: v1 - v2, y: v3 - v2, width: v2 * 2, height: v2 * 2 }); e.setShape({ x: 0, y: 0, width: m.getWidth(), height: m.getHeight() }) }; Z.resize(); return Z
  }; function ES(k, m, e, i) { this.ecInstance = k; this.api = m; this.unfinished; var e = this._dataProcessorHandlers = e.slice(); var i = this._visualHandlers = i.slice(); this._allHandlers = e.concat(i); this._stageTaskMap = CJ() } var fi = ES.prototype; fi.restoreData = function (e, i) { e.restoreData(i); this._stageTaskMap.each(function (k) { var m = k.overallTask; m && m.dirty() }) }; fi.getPerformArgs = function (k, e) { if (!k.__pipeline) { return } var m = this._pipelineMap.get(k.__pipeline.id); var i = m.context; var v2 = !e && m.progressiveEnabled && (!i || i.progressiveRender) && k.__idxInPipeline > m.blockIndex; var Z = v2 ? m.step : null; var v = i && i.modDataCount; var v1 = v != null ? Math.ceil(v / Z) : null; return { step: Z, modBy: v1, modDataCount: v } }; fi.getPipeline = function (e) { return this._pipelineMap.get(e) }; fi.updateStreamModes = function (i, e) { var k = this._pipelineMap.get(i.uid); var v1 = i.getData(); var v = v1.count(); var v2 = k.progressiveEnabled && e.incrementalPrepareRender && v >= k.threshold; var m = i.get("large") && v >= i.get("largeThreshold"); var Z = i.get("progressiveChunkMode") === "mod" ? v : null; i.pipelineContext = k.context = { progressiveRender: v2, modDataCount: Z, large: m } }; fi.restorePipelines = function (e) { var i = this; var k = i._pipelineMap = CJ(); e.eachSeries(function (m) { var v = m.getProgressive(); var Z = m.uid; k.set(Z, { id: Z, head: null, tail: null, threshold: m.getProgressiveThreshold(), progressiveEnabled: v && !(m.preventIncremental && m.preventIncremental()), blockIndex: -1, step: Math.round(v || 700), count: 0 }); qD(i, m, m.dataTask) }) }; fi.prepareStageTasks = function () { var i = this._stageTaskMap; var e = this.ecInstance.getModel(); var k = this.api; o9(this._allHandlers, function (v) { var m = i.get(v.uid) || i.set(v.uid, []); v.reset && fC(this, v, m, e, k); v.overallReset && nx(this, v, m, e, k) }, this) }; fi.prepareView = function (i, m, e, Z) { var k = i.renderTask; var v = k.context; v.model = m; v.ecModel = e; v.api = Z; k.__block = !i.incrementalPrepareRender; qD(this, m, k) }; fi.performDataProcessorTasks = function (e, i) { wz(this, this._dataProcessorHandlers, e, i, { block: true }) }; fi.performVisualTasks = function (e, k, i) { wz(this, this._visualHandlers, e, k, i) }; function wz(k, m, e, v, i) { i = i || {}; var v1; o9(m, function (Io, Ij) { if (i.visualType && i.visualType !== Io.visualType) { return } var v3 = k._stageTaskMap.get(Io.uid); var v2 = v3.seriesTaskMap; var Ik = v3.overallTask; if (Ik) { var In; var Il = Ik.agentStubMap; Il.each(function (Ip) { if (Z(i, Ip)) { Ip.dirty(); In = true } }); In && Ik.dirty(); kc(Ik, v); var Im = k.getPerformArgs(Ik, i.block); Il.each(function (Ip) { Ip.perform(Im) }); v1 |= Ik.perform(Im) } else { if (v2) { v2.each(function (Ip, Ir) { if (Z(i, Ip)) { Ip.dirty() } var Iq = k.getPerformArgs(Ip, i.block); Iq.skip = !Io.performRawSeries && e.isSeriesFiltered(Ip.context.model); kc(Ip, v); v1 |= Ip.perform(Iq) }) } } }); function Z(v3, v2) { return v3.setDirty && (!v3.dirtyMap || v3.dirtyMap.get(v2.__pipeline.id)) } k.unfinished |= v1 } fi.performSeriesTasks = function (e) { var i; e.eachSeries(function (k) { i |= k.dataTask.perform() }); this.unfinished |= i }; fi.plan = function () { this._pipelineMap.each(function (i) { var e = i.tail; do { if (e.__block) { i.blockIndex = e.__idxInPipeline; break } e = e.getUpstream() } while (e) }) }; var kc = fi.updatePayload = function (e, i) { i !== "remain" && (e.context.payload = i) }; function fC(v, k, v1, v2, v3) { var e = v1.seriesTaskMap || (v1.seriesTaskMap = CJ()); var m = k.seriesType; var Ij = k.getTargetSeries; if (k.createOnAllSeries) { v2.eachRawSeries(Z) } else { if (m) { v2.eachRawSeriesByType(m, Z) } else { if (Ij) { Ij(v2, v3).each(Z) } } } function Z(Il) { var Im = Il.uid; var Ik = e.get(Im) || e.set(Im, Ca({ plan: l3, reset: xF, count: Cg })); Ik.context = { model: Il, ecModel: v2, api: v3, useClearVisual: k.isVisual && !k.isLayout, plan: k.plan, reset: k.reset, scheduler: v }; qD(v, Il, Ik) } var i = v._pipelineMap; e.each(function (Ik, Il) { if (!i.get(Il)) { Ik.dispose(); e.removeKey(Il) } }) } function nx(v, k, Z, v1, v2) {
    var v3 = Z.overallTask = Z.overallTask || Ca({ reset: j6 }); v3.context = { ecModel: v1, api: v2, overallReset: k.overallReset, scheduler: v }; var e = v3.agentStubMap = v3.agentStubMap || CJ(); var m = k.seriesType; var Ik = k.getTargetSeries; var Il = true; var Ij = k.modifyOutputEnd; if (m) { v1.eachRawSeriesByType(m, Im) } else { if (Ik) { Ik(v1, v2).each(Im) } else { Il = false; o9(v1.getSeries(), Im) } } function Im(In) { var Ip = In.uid; var Io = e.get(Ip); if (!Io) { Io = e.set(Ip, Ca({ reset: xw, onDirty: Ci })); v3.dirty() } Io.context = { model: In, overallProgress: Il, modifyOutputEnd: Ij }; Io.agent = v3; Io.__block = Il; qD(v, In, Io) } var i = v._pipelineMap; e.each(function (In, Io) {
      if (!i.get(Io)) {
        In.dispose();
        v3.dirty(); e.removeKey(Io)
      }
    })
  } function j6(e) { e.overallReset(e.ecModel, e.api, e.payload) } function xw(i, e) { return i.overallProgress && Be } function Be() { this.agent.dirty(); this.getDownstream().dirty() } function Ci() { this.agent && this.agent.dirty() } function l3(e) { return e.plan && e.plan(e.model, e.ecModel, e.api, e.payload) } function xF(e) { if (e.useClearVisual) { e.data.clearAllVisual() } var i = e.resetDefines = mp(e.reset(e.model, e.ecModel, e.api, e.payload)); return i.length > 1 ? Ef(i, function (m, k) { return A3(k) }) : Bq } var Bq = A3(0); function A3(e) { return function (Z, m) { var v = m.data; var v1 = m.resetDefines[e]; if (v1 && v1.dataEach) { for (var k = Z.start; k < Z.end; k++) { v1.dataEach(v, k) } } else { if (v1 && v1.progress) { v1.progress(Z, v) } } } } function Cg(e) { return e.data.count() } function qD(m, i, e) { var v = i.uid; var k = m._pipelineMap.get(v); !k.head && (k.head = e); k.tail && k.tail.pipe(e); k.tail = e; e.__idxInPipeline = k.count++; e.__pipeline = k } ES.wrapStageHandler = function (i, e) { if (E5(i)) { i = { overallReset: i, seriesType: O(i) } } i.uid = l8("stageHandler"); e && (i.visualType = e); return i }; function O(i) { d9 = null; try { i(dV, kM) } catch (k) { } return d9 } var dV = {}; var kM = {}; var d9; sN(dV, cj); sN(kM, lE); dV.eachSeriesByType = dV.eachRawSeriesByType = function (e) { d9 = e }; dV.eachComponent = function (e) { if (e.mainType === "series" && e.subType) { d9 = e.subType } }; function sN(k, e) { for (var i in e.prototype) { k[i] = V } } var n3 = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"]; var bv = { color: n3, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], n3] }; var gc = "#eee"; var CQ = function () { return { axisLine: { lineStyle: { color: gc } }, axisTick: { lineStyle: { color: gc } }, axisLabel: { textStyle: { color: gc } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: gc } } } }; var dt = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"]; var qt = { color: dt, backgroundColor: "#333", tooltip: { axisPointer: { lineStyle: { color: gc }, crossStyle: { color: gc } } }, legend: { textStyle: { color: gc } }, textStyle: { color: gc }, title: { textStyle: { color: gc } }, toolbox: { iconStyle: { normal: { borderColor: gc } } }, dataZoom: { textStyle: { color: gc } }, visualMap: { textStyle: { color: gc } }, timeline: { lineStyle: { color: gc }, itemStyle: { normal: { color: dt[1] } }, label: { normal: { textStyle: { color: gc } } }, controlStyle: { normal: { color: gc, borderColor: gc } } }, timeAxis: CQ(), logAxis: CQ(), valueAxis: CQ(), categoryAxis: CQ(), line: { symbol: "circle" }, graph: { color: dt }, gauge: { title: { textStyle: { color: gc } } }, candlestick: { itemStyle: { normal: { color: "#FD1050", color0: "#0CF49B", borderColor: "#FD1050", borderColor0: "#0CF49B" } } } }; qt.categoryAxis.splitLine.show = false; aH.extend({ type: "dataset", defaultOption: { seriesLayoutBy: k3, sourceHeader: null, dimensions: null, source: null }, optionUpdated: function () { xn(this) } }); sT.extend({ type: "dataset" }); var Co = mm.extend({ type: "ellipse", shape: { cx: 0, cy: 0, rx: 0, ry: 0 }, buildPath: function (Ij, v) { var m = 0.5522848; var v3 = v.cx; var Z = v.cy; var v2 = v.rx; var v1 = v.ry; var i = v2 * m; var e = v1 * m; Ij.moveTo(v3 - v2, Z); Ij.bezierCurveTo(v3 - v2, Z - e, v3 - i, Z - v1, v3, Z - v1); Ij.bezierCurveTo(v3 + i, Z - v1, v3 + v2, Z - e, v3 + v2, Z); Ij.bezierCurveTo(v3 + v2, Z + e, v3 + i, Z + v1, v3, Z + v1); Ij.bezierCurveTo(v3 - i, Z + v1, v3 - v2, Z + e, v3 - v2, Z); Ij.closePath() } }); var ja = /[\s,]+/; function mX(e) { if (wb(e)) { var i = new DOMParser(); e = i.parseFromString(e, "text/xml") } if (e.nodeType === 9) { e = e.firstChild } while (e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1) { e = e.nextSibling } return e } function s4() { this._defs = {}; this._root = null; this._isDefine = false; this._isText = false } s4.prototype.parse = function (Z, i) { i = i || {}; var v1 = mX(Z); if (!v1) { throw new Error("Illegal svg") } var v3 = new B8(); this._root = v3; var Il = v1.getAttribute("viewBox") || ""; var e = parseFloat(v1.getAttribute("width") || i.width); var Ij = parseFloat(v1.getAttribute("height") || i.height); isNaN(e) && (e = null); isNaN(Ij) && (Ij = null); Dt(v1, v3, null, true); var k = v1.firstChild; while (k) { this._parseNode(k, v3); k = k.nextSibling } var v; var m; if (Il) { var Ik = Gs(Il).split(ja); if (Ik.length >= 4) { v = { x: parseFloat(Ik[0] || 0), y: parseFloat(Ik[1] || 0), width: parseFloat(Ik[2]), height: parseFloat(Ik[3]) } } } if (v && e != null && Ij != null) { m = AN(v, e, Ij); if (!i.ignoreViewBox) { var v2 = v3; v3 = new B8(); v3.add(v2); v2.scale = m.scale.slice(); v2.position = m.position.slice() } } if (!i.ignoreRootClip && e != null && Ij != null) { v3.setClipPath(new EH({ shape: { x: 0, y: 0, width: e, height: Ij } })) } return { root: v3, width: e, height: Ij, viewBoxRect: v, viewBoxTransform: m } }; s4.prototype._parseNode = function (e, m) {
    var v2 = e.nodeName.toLowerCase(); if (v2 === "defs") { this._isDefine = true } else { if (v2 === "text") { this._isText = true } } var i; if (this._isDefine) { var v1 = gy[v2]; if (v1) { var k = v1.call(this, e); var Z = e.getAttribute("id"); if (Z) { this._defs[Z] = k } } } else { var v1 = sg[v2]; if (v1) { i = v1.call(this, e, m); m.add(i) } } var v = e.firstChild; while (v) { if (v.nodeType === 1) { this._parseNode(v, i) } if (v.nodeType === 3 && this._isText) { this._parseText(v, i) } v = v.nextSibling } if (v2 === "defs") { this._isDefine = false } else {
      if (v2 === "text") {
        this._isText = false
      }
    }
  }; s4.prototype._parseText = function (k, Z) { if (k.nodeType === 1) { var i = k.getAttribute("dx") || 0; var e = k.getAttribute("dy") || 0; this._textX += parseFloat(i); this._textY += parseFloat(e) } var v1 = new iR({ style: { text: k.textContent, transformText: true }, position: [this._textX || 0, this._textY || 0] }); Ck(Z, v1); Dt(k, v1, this._defs); var v = v1.style.fontSize; if (v && v < 9) { v1.style.fontSize = 9; v1.scale = v1.scale || [1, 1]; v1.scale[0] *= v / 9; v1.scale[1] *= v / 9 } var m = v1.getBoundingRect(); this._textX += m.width; Z.add(v1); return v1 }; var sg = { "g": function (e, k) { var i = new B8(); Ck(k, i); Dt(e, i, this._defs); return i }, "rect": function (e, k) { var i = new EH(); Ck(k, i); Dt(e, i, this._defs); i.setShape({ x: parseFloat(e.getAttribute("x") || 0), y: parseFloat(e.getAttribute("y") || 0), width: parseFloat(e.getAttribute("width") || 0), height: parseFloat(e.getAttribute("height") || 0) }); return i }, "circle": function (e, k) { var i = new GI(); Ck(k, i); Dt(e, i, this._defs); i.setShape({ cx: parseFloat(e.getAttribute("cx") || 0), cy: parseFloat(e.getAttribute("cy") || 0), r: parseFloat(e.getAttribute("r") || 0) }); return i }, "line": function (i, k) { var e = new zB(); Ck(k, e); Dt(i, e, this._defs); e.setShape({ x1: parseFloat(i.getAttribute("x1") || 0), y1: parseFloat(i.getAttribute("y1") || 0), x2: parseFloat(i.getAttribute("x2") || 0), y2: parseFloat(i.getAttribute("y2") || 0) }); return e }, "ellipse": function (e, k) { var i = new Co(); Ck(k, i); Dt(e, i, this._defs); i.setShape({ cx: parseFloat(e.getAttribute("cx") || 0), cy: parseFloat(e.getAttribute("cy") || 0), rx: parseFloat(e.getAttribute("rx") || 0), ry: parseFloat(e.getAttribute("ry") || 0) }); return i }, "polygon": function (i, m) { var k = i.getAttribute("points"); if (k) { k = cJ(k) } var e = new ia({ shape: { points: k || [] } }); Ck(m, e); Dt(i, e, this._defs); return e }, "polyline": function (i, v) { var m = new mm(); Ck(v, m); Dt(i, m, this._defs); var k = i.getAttribute("points"); if (k) { k = cJ(k) } var e = new z7({ shape: { points: k || [] } }); return e }, "image": function (i, k) { var e = new Ft(); Ck(k, e); Dt(i, e, this._defs); e.setStyle({ image: i.getAttribute("xlink:href"), x: i.getAttribute("x"), y: i.getAttribute("y"), width: i.getAttribute("width"), height: i.getAttribute("height") }); return e }, "text": function (m, Z) { var e = m.getAttribute("x") || 0; var v1 = m.getAttribute("y") || 0; var k = m.getAttribute("dx") || 0; var i = m.getAttribute("dy") || 0; this._textX = parseFloat(e) + parseFloat(k); this._textY = parseFloat(v1) + parseFloat(i); var v = new B8(); Ck(Z, v); Dt(m, v, this._defs); return v }, "tspan": function (m, Z) { var e = m.getAttribute("x"); var v1 = m.getAttribute("y"); if (e != null) { this._textX = parseFloat(e) } if (v1 != null) { this._textY = parseFloat(v1) } var k = m.getAttribute("dx") || 0; var i = m.getAttribute("dy") || 0; var v = new B8(); Ck(Z, v); Dt(m, v, this._defs); this._textX += k; this._textY += i; return v }, "path": function (e, k) { var m = e.getAttribute("d") || ""; var i = fo(m); Ck(k, i); Dt(e, i, this._defs); return i } }; var gy = { "lineargradient": function (m) { var i = parseInt(m.getAttribute("x1") || 0); var v = parseInt(m.getAttribute("y1") || 0); var e = parseInt(m.getAttribute("x2") || 10); var k = parseInt(m.getAttribute("y2") || 0); var Z = new uD(i, v, e, k); dj(m, Z); return Z }, "radialgradient": function (e) { } }; function dj(k, m) { var i = k.firstChild; while (i) { if (i.nodeType === 1) { var v = i.getAttribute("offset"); if (v.indexOf("%") > 0) { v = parseInt(v) / 100 } else { if (v) { v = parseFloat(v) } else { v = 0 } } var e = i.getAttribute("stop-color") || "#000000"; m.addColorStop(v, e) } i = i.nextSibling } } function Ck(e, i) { if (e && e.__inheritedStyle) { if (!i.__inheritedStyle) { i.__inheritedStyle = {} } De(i.__inheritedStyle, e.__inheritedStyle) } } function cJ(k) { var Z = Gs(k).split(ja); var v = []; for (var m = 0; m < Z.length; m += 2) { var e = parseFloat(Z[m]); var v1 = parseFloat(Z[m + 1]); v.push([e, v1]) } return v } var CI = { "fill": "fill", "stroke": "stroke", "stroke-width": "lineWidth", "opacity": "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-align": "textAlign", "alignment-baseline": "textBaseline" }; function Dt(Ij, e, m, k) {
    var Ik = e.__inheritedStyle || {}; var Z = e.type === "text"; if (Ij.nodeType === 1) { l5(Ij, e); b0(Ik, ct(Ij)); if (!k) { for (var i in CI) { if (CI.hasOwnProperty(i)) { var v = Ij.getAttribute(i); if (v != null) { Ik[CI[i]] = v } } } } } var v2 = Z ? "textFill" : "fill"; var v1 = Z ? "textStroke" : "stroke"; e.style = e.style || new xS(); var v3 = e.style; Ik.fill != null && v3.set(v2, oT(Ik.fill, m)); Ik.stroke != null && v3.set(v1, oT(Ik.stroke, m)); o9(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function (Im) { var Il = (Im === "lineWidth" && Z) ? "textStrokeWidth" : Im; Ik[Im] != null && v3.set(Il, parseFloat(Ik[Im])) }); if (!Ik.textBaseline || Ik.textBaseline === "auto") { Ik.textBaseline = "alphabetic" } if (Ik.textBaseline === "alphabetic") { Ik.textBaseline = "bottom" } if (Ik.textAlign === "start") { Ik.textAlign = "left" } if (Ik.textAlign === "end") { Ik.textAlign = "right" } o9(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function (Il) { Ik[Il] != null && v3.set(Il, Ik[Il]) }); if (Ik.lineDash) {
      e.style.lineDash = Gs(Ik.lineDash).split(ja)
    } if (v3[v1] && v3[v1] !== "none") { e[v1] = true } e.__inheritedStyle = Ik
  } var Dn = /url\(\s*#(.*?)\)/; function oT(v, e) { var k = e && v && v.match(Dn); if (k) { var i = Gs(k[1]); var m = e[i]; return m } return v } var b = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g; function l5(v1, v3) { var v = v1.getAttribute("transform"); if (v) { v = v.replace(/,/g, " "); var e = null; var k = []; v.replace(b, function (Ik, i, m) { k.push(i, m) }); for (var Z = k.length - 1; Z > 0; Z -= 2) { var Ij = k[Z]; var v2 = k[Z - 1]; e = e || CB(); switch (v2) { case "translate": Ij = Gs(Ij).split(ja); vm(e, e, [parseFloat(Ij[0]), parseFloat(Ij[1] || 0)]); break; case "scale": Ij = Gs(Ij).split(ja); qX(e, e, [parseFloat(Ij[0]), parseFloat(Ij[1] || Ij[0])]); break; case "rotate": Ij = Gs(Ij).split(ja); ki(e, e, parseFloat(Ij[0])); break; case "skew": Ij = Gs(Ij).split(ja); console.warn("Skew transform is not supported yet"); break; case "matrix": var Ij = Gs(Ij).split(ja); e[0] = parseFloat(Ij[0]); e[1] = parseFloat(Ij[1]); e[2] = parseFloat(Ij[2]); e[3] = parseFloat(Ij[3]); e[4] = parseFloat(Ij[4]); e[5] = parseFloat(Ij[5]); break } } } v3.setLocalTransform(e) } var yp = /([^\s:;]+)\s*:\s*([^:;]+)/g; function ct(k) { var m = k.getAttribute("style"); var e = {}; if (!m) { return e } var Z = {}; yp.lastIndex = 0; var i; while ((i = yp.exec(m)) != null) { Z[i[1]] = i[2] } for (var v in CI) { if (CI.hasOwnProperty(v) && Z[v] != null) { e[CI[v]] = Z[v] } } return e } function AN(i, Z, e) { var v = Z / i.width; var m = e / i.height; var v1 = Math.min(v, m); var v2 = [v1, v1]; var k = [-(i.x + i.width / 2) * v1 + Z / 2, -(i.y + i.height / 2) * v1 + e / 2]; return { scale: v2, position: k } } function D3(e, i) { var k = new s4(); return k.parse(e, i) } var EE = CJ(); var DS = { registerMap: function (m, k, e) { var i; if (GG(k)) { i = k } else { if (k.svg) { i = [{ type: "svg", source: k.svg, specialAreas: k.specialAreas }] } else { if (k.geoJson && !k.features) { e = k.specialAreas; k = k.geoJson } i = [{ type: "geoJSON", source: k, specialAreas: e }] } } o9(i, function (v) { var Z = v.type; Z === "geoJson" && (Z = v.type = "geoJSON"); var v1 = bL[Z]; if (ok) { bM(v1, "Illegal map type: " + Z) } v1(v) }); return EE.set(m, i) }, retrieveMap: function (e) { return EE.get(e) } }; var bL = { geoJSON: function (e) { var i = e.source; e.geoJSON = !wb(i) ? i : (typeof JSON !== "undefined" && JSON.parse) ? JSON.parse(i) : (new Function("return (" + i + ");"))() }, svg: function (e) { e.svgXML = mX(e.source) } }; var ag = bM; var CT = o9; var oO = E5; var j0 = tJ; var s9 = aH.parseClassType; var H5 = "4.1.0"; var qY = { zrender: "4.0.4" }; var me = 1; var ig = 1000; var rK = 5000; var am = 1000; var pc = 2000; var yl = 3000; var FA = 4000; var e2 = 5000; var B6 = { PROCESSOR: { FILTER: ig, STATISTIC: rK }, VISUAL: { LAYOUT: am, GLOBAL: pc, CHART: yl, COMPONENT: FA, BRUSH: e2 } }; var mz = "__flagInMainProcess"; var rp = "__optionUpdated"; var f6 = /^[a-zA-Z0-9_]+$/; function GR(e) { return function (i, m, k) { i = i && i.toLowerCase(); Gc.prototype[e].call(this, i, m, k) } } function CU() { Gc.call(this) } CU.prototype.on = GR("on"); CU.prototype.off = GR("off"); CU.prototype.one = GR("one"); Gq(CU, Gc); function t6(v1, k, i) { i = i || {}; if (typeof k === "string") { k = HR[k] } this.id; this.group; this._dom = v1; var v = "canvas"; if (ok) { v = (typeof window === "undefined" ? global : window).__ECHARTS__DEFAULT__RENDERER__ || v } var Z = this._zr = nE(v1, { renderer: i.renderer || v, devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height }); this._throttledZrFlush = e1(km(Z.flush, Z), 17); var k = C5(k); k && Hr(k, true); this._theme = k; this._chartsViews = []; this._chartsMap = {}; this._componentsViews = []; this._componentsMap = {}; this._coordSysMgr = new fz(); var e = this._api = k2(this); function m(v3, v2) { return v3.__prio - v2.__prio } qu(c8, m); qu(ix, m); this._scheduler = new ES(this, e, ix, c8); Gc.call(this, this._ecEventProcessor = AW(this)); this._messageCenter = new CU(); this._initEvents(); this.resize = km(this.resize, this); this._pendingActions = []; Z.animation.on("frame", this._onframe, this); mD(Z, this); A(this) } var Fp = t6.prototype; Fp._onframe = function () { if (this._disposed) { return } var k = this._scheduler; if (this[rp]) { var i = this[rp].silent; this[mz] = true; xP(this); Ai.update.call(this); this[mz] = false; this[rp] = false; av.call(this, i); C9.call(this, i) } else { if (k.unfinished) { var Z = me; var e = this._model; var v = this._api; k.unfinished = false; do { var m = +new Date(); k.performSeriesTasks(e); k.performDataProcessorTasks(e); Cq(this, e); k.performVisualTasks(e); fQ(this, this._model, v, "remain"); Z -= (+new Date() - m) } while (Z > 0 && k.unfinished); if (!k.unfinished) { this._zr.flush() } } } }; Fp.getDom = function () { return this._dom }; Fp.getZr = function () { return this._zr }; Fp.setOption = function (m, v1, Z) { if (ok) { ag(!this[mz], "`setOption` should not be called during main process.") } var k; if (j0(v1)) { Z = v1.lazyUpdate; k = v1.silent; v1 = v1.notMerge } this[mz] = true; if (!this._model || v1) { var i = new mg(this._api); var v = this._theme; var e = this._model = new cj(null, null, v, i); e.scheduler = this._scheduler; e.init(null, null, v, i) } this._model.setOption(m, fZ); if (Z) { this[rp] = { silent: k }; this[mz] = false } else { xP(this); Ai.update.call(this); this._zr.flush(); this[rp] = false; this[mz] = false; av.call(this, k); C9.call(this, k) } }; Fp.setTheme = function () { console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0") }; Fp.getModel = function () { return this._model }; Fp.getOption = function () { return this._model && this._model.getOption() }; Fp.getWidth = function () { return this._zr.getWidth() }; Fp.getHeight = function () { return this._zr.getHeight() };
  Fp.getDevicePixelRatio = function () { return this._zr.painter.dpr || window.devicePixelRatio || 1 }; Fp.getRenderedCanvas = function (e) { if (!sW.canvasSupported) { return } e = e || {}; e.pixelRatio = e.pixelRatio || 1; e.backgroundColor = e.backgroundColor || this._model.get("backgroundColor"); var i = this._zr; return i.painter.getRenderedCanvas(e) }; Fp.getSvgDataUrl = function () { if (!sW.svgSupported) { return } var i = this._zr; var e = i.storage.getDisplayList(); o9(e, function (k) { k.stopAnimation(true) }); return i.painter.pathToDataUrl() }; Fp.getDataURL = function (v) { v = v || {}; var Z = v.excludeComponents; var e = this._model; var m = []; var i = this; CT(Z, function (v1) { e.eachComponent({ mainType: v1 }, function (v3) { var v2 = i._componentsMap[v3.__viewId]; if (!v2.group.ignore) { m.push(v2); v2.group.ignore = true } }) }); var k = this._zr.painter.getType() === "svg" ? this.getSvgDataUrl() : this.getRenderedCanvas(v).toDataURL("image/" + (v && v.type || "png")); CT(m, function (v1) { v1.group.ignore = false }); return k }; Fp.getConnectedDataURL = function (i) { if (!sW.canvasSupported) { return } var Z = this.group; var m = Math.min; var v1 = Math.max; var Im = Infinity; if (dN[Z]) { var v = Im; var Ij = Im; var In = -Im; var e = -Im; var v2 = []; var Il = (i && i.pixelRatio) || 1; o9(az, function (Ir, Is) { if (Ir.group === Z) { var Iq = Ir.getRenderedCanvas(C5(i)); var Ip = Ir.getDom().getBoundingClientRect(); v = m(Ip.left, v); Ij = m(Ip.top, Ij); In = v1(Ip.right, In); e = v1(Ip.bottom, e); v2.push({ dom: Iq, left: Ip.left, top: Ip.top }) } }); v *= Il; Ij *= Il; In *= Il; e *= Il; var k = In - v; var Io = e - Ij; var Ik = Dc(); Ik.width = k; Ik.height = Io; var v3 = nE(Ik); CT(v2, function (Iq) { var Ip = new Ft({ style: { x: Iq.left * Il - v, y: Iq.top * Il - Ij, image: Iq.dom } }); v3.add(Ip) }); v3.refreshImmediately(); return Ik.toDataURL("image/" + (i && i.type || "png")) } else { return this.getDataURL(i) } }; Fp.convertToPixel = sv(pp, "convertToPixel"); Fp.convertFromPixel = sv(pp, "convertFromPixel"); function pp(v, v3, v2) { var k = this._model; var m = this._coordSysMgr.getCoordinateSystems(); var e; v3 = nF(k, v3); for (var v1 = 0; v1 < m.length; v1++) { var Z = m[v1]; if (Z[v] && (e = Z[v](k, v3, v2)) != null) { return e } } if (ok) { console.warn("No coordinate system that supports " + v + " found by the given finder.") } } Fp.containPixel = function (m, k) { var i = this._model; var e; m = nF(i, m); o9(m, function (Z, v) { v.indexOf("Models") >= 0 && o9(Z, function (v2) { var v3 = v2.coordinateSystem; if (v3 && v3.containPoint) { e |= !!v3.containPoint(k) } else { if (v === "seriesModels") { var v1 = this._chartsMap[v2.__viewId]; if (v1 && v1.containPoint) { e |= v1.containPoint(k, v2) } else { if (ok) { console.warn(v + ": " + (v1 ? "The found component do not support containPoint." : "No view mapping to the found component.")) } } } else { if (ok) { console.warn(v + ": containPoint is not supported") } } } }, this) }, this); return !!e }; Fp.getVisual = function (Z, v) { var e = this._model; Z = nF(e, Z, { defaultMainType: "series" }); var i = Z.seriesModel; if (ok) { if (!i) { console.warn("There is no specified seires model") } } var m = i.getData(); var k = Z.hasOwnProperty("dataIndexInside") ? Z.dataIndexInside : Z.hasOwnProperty("dataIndex") ? m.indexOfRawIndex(Z.dataIndex) : null; return k != null ? m.getItemVisual(k, v) : m.getVisual(v) }; Fp.getViewOfComponentModel = function (e) { return this._componentsMap[e.__viewId] }; Fp.getViewOfSeriesModel = function (e) { return this._chartsMap[e.__viewId] }; var Ai = { prepareAndUpdate: function (e) { xP(this); Ai.update.call(this, e) }, update: function (v2) { var e = this._model; var m = this._api; var v1 = this._zr; var Z = this._coordSysMgr; var k = this._scheduler; if (!e) { return } k.restoreData(e, v2); k.performSeriesTasks(e); Z.create(e, m); k.performDataProcessorTasks(e, v2); Cq(this, e); Z.update(e, m); s3(e); k.performVisualTasks(e, v2); Ho(this, e, m, v2); var i = e.get("backgroundColor") || "transparent"; if (!sW.canvasSupported) { var v = eW(i); i = wp(v, "rgb"); if (v[3] === 0) { i = "transparent" } } else { v1.setBackgroundColor(i) } Cw(e, m) }, updateTransform: function (v) { var i = this._model; var e = this; var k = this._api; if (!i) { return } var m = []; i.eachComponent(function (v3, v2) { var Ij = e.getViewOfComponentModel(v2); if (Ij && Ij.__alive) { if (Ij.updateTransform) { var v1 = Ij.updateTransform(v2, i, k, v); v1 && v1.update && m.push(Ij) } else { m.push(Ij) } } }); var Z = CJ(); i.eachSeries(function (v3) { var v2 = e._chartsMap[v3.__viewId]; if (v2.updateTransform) { var v1 = v2.updateTransform(v3, i, k, v); v1 && v1.update && Z.set(v3.uid, 1) } else { Z.set(v3.uid, 1) } }); s3(i); this._scheduler.performVisualTasks(i, v, { setDirty: true, dirtyMap: Z }); fQ(e, i, k, v, Z); Cw(i, this._api) }, updateView: function (i) { var e = this._model; if (!e) { return } dF.markUpdateMethod(i, "updateView"); s3(e); this._scheduler.performVisualTasks(e, i, { setDirty: true }); Ho(this, this._model, this._api, i); Cw(e, this._api) }, updateVisual: function (e) { Ai.update.call(this, e) }, updateLayout: function (e) { Ai.update.call(this, e) } }; function xP(i) { var e = i._model; var k = i._scheduler; k.restorePipelines(e); k.prepareStageTasks(); Cb(i, "component", e, k); Cb(i, "chart", e, k); k.plan() } function n1(Ij, e, v1, v, v3) {
    var k = Ij._model; if (!v) { CT(Ij._componentsViews.concat(Ij._chartsViews), m); return } var Z = {}; Z[v + "Id"] = v1[v + "Id"]; Z[v + "Index"] = v1[v + "Index"]; Z[v + "Name"] = v1[v + "Name"]; var i = { mainType: v, query: Z }; v3 && (i.subType = v3); var v2 = v1.excludeSeriesId; if (v2 != null) { v2 = CJ(mp(v2)) } k && k.eachComponent(i, function (Ik) {
      if (!v2 || v2.get(Ik.id) == null) {
        m(Ij[v === "series" ? "_chartsMap" : "_componentsMap"][Ik.__viewId])
      }
    }, Ij); function m(Ik) { Ik && Ik.__alive && Ik[e] && Ik[e](Ik.__model, k, Ij._api, v1) }
  } Fp.resize = function (m) { if (ok) { ag(!this[mz], "`resize` should not be called during main process.") } this._zr.resize(m); var e = this._model; this._loadingFX && this._loadingFX.resize(); if (!e) { return } var k = e.resetOption("media"); var i = m && m.silent; this[mz] = true; k && xP(this); Ai.update.call(this); this[mz] = false; av.call(this, i); C9.call(this, i) }; function Cq(i, e) { var k = i._chartsMap; var m = i._scheduler; e.eachSeries(function (v) { m.updateStreamModes(v, k[v.__viewId]) }) } Fp.showLoading = function (i, e) { if (j0(i)) { e = i; i = "" } i = i || "default"; this.hideLoading(); if (!FK[i]) { if (ok) { console.warn("Loading effects " + i + " not exists.") } return } var k = FK[i](this._api, e); var m = this._zr; this._loadingFX = k; m.add(k) }; Fp.hideLoading = function () { this._loadingFX && this._zr.remove(this._loadingFX); this._loadingFX = null }; Fp.makeActionFromEvent = function (e) { var i = b0({}, e); i.type = q5[e.type]; return i }; Fp.dispatchAction = function (i, e) { if (!j0(e)) { e = { silent: !!e } } if (!cS[i.type]) { return } if (!this._model) { return } if (this[mz]) { this._pendingActions.push(i); return } iN.call(this, i, e.silent); if (e.flush) { this._zr.flush(true) } else { if (e.flush !== false && sW.browser.weChat) { this._throttledZrFlush() } } av.call(this, e.silent); C9.call(this, e.silent) }; function iN(Ik, v2) { var Il = Ik.type; var k = Ik.escapeConnect; var v3 = cS[Il]; var Ij = v3.actionInfo; var i = (Ij.update || "update").split(":"); var m = i.pop(); i = i[0] != null && s9(i[0]); this[mz] = true; var v = [Ik]; var e = false; if (Ik.batch) { e = true; v = Ef(Ik.batch, function (In) { In = De(b0({}, In), Ik); In.batch = null; return In }) } var Im = []; var v1; var Z = Il === "highlight" || Il === "downplay"; CT(v, function (In) { v1 = v3.action(In, this._model, this._api); v1 = v1 || b0({}, In); v1.type = Ij.event || v1.type; Im.push(v1); if (Z) { n1(this, m, In, "series") } else { if (i) { n1(this, m, In, i.main, i.sub) } } }, this); if (m !== "none" && !Z && !i) { if (this[rp]) { xP(this); Ai.update.call(this, Ik); this[rp] = false } else { Ai[m].call(this, Ik) } } if (e) { v1 = { type: Ij.event || Il, escapeConnect: k, batch: Im } } else { v1 = Im[0] } this[mz] = false; !v2 && this._messageCenter.trigger(v1.type, v1) } function av(e) { var i = this._pendingActions; while (i.length) { var k = i.shift(); iN.call(this, k, e) } } function C9(e) { !e && this.trigger("updated") } function mD(i, e) { i.on("rendered", function () { e.trigger("rendered"); if (i.animation.isFinished() && !e[rp] && !e._scheduler.unfinished && !e._pendingActions.length) { e.trigger("finished") } }) } Fp.appendData = function (m) { var k = m.seriesIndex; var e = this.getModel(); var i = e.getSeriesByIndex(k); if (ok) { ag(m.data && i) } i.appendData(m); this._scheduler.unfinished = true }; Fp.on = GR("on"); Fp.off = GR("off"); Fp.one = GR("one"); function Cb(Im, Ij, Z, m) { var v = Ij === "component"; var e = v ? Im._componentsViews : Im._chartsViews; var v3 = v ? Im._componentsMap : Im._chartsMap; var v2 = Im._zr; var v1 = Im._api; for (var k = 0; k < e.length; k++) { e[k].__alive = false } v ? Z.eachComponent(function (In, i) { In !== "series" && Il(i) }) : Z.eachSeries(Il); function Il(Io) { var i = "_ec_" + Io.id + "_" + Io.type; var In = v3[i]; if (!In) { var Ip = s9(Io.type); var Iq = v ? sT.getClass(Ip.main, Ip.sub) : dF.getClass(Ip.sub); if (ok) { ag(Iq, Ip.sub + " does not exist.") } In = new Iq(); In.init(Z, v1); v3[i] = In; e.push(In); v2.add(In.group) } Io.__viewId = In.__id = i; In.__alive = true; In.__model = Io; In.group.__ecComponentInfo = { mainType: Io.mainType, index: Io.componentIndex }; !v && m.prepareView(In, Io, Z, v1) } for (var k = 0; k < e.length;) { var Ik = e[k]; if (!Ik.__alive) { !v && Ik.renderTask.dispose(); v2.remove(Ik.group); Ik.dispose(Z, v1); e.splice(k, 1); delete v3[Ik.__id]; Ik.__id = Ik.group.__ecComponentInfo = null } else { k++ } } } function s3(e) { e.clearColorPalette(); e.eachSeries(function (i) { i.clearColorPalette() }) } function Ho(i, e, k, m) { hR(i, e, k, m); CT(i._chartsViews, function (v) { v.__alive = false }); fQ(i, e, k, m); CT(i._chartsViews, function (v) { if (!v.__alive) { v.remove(e, k) } }) } function hR(i, e, m, v, k) { CT(k || i._componentsViews, function (v1) { var Z = v1.__model; v1.render(Z, e, m, v); qE(Z, v1) }) } function fQ(i, e, v, Z, k) { var m = i._scheduler; var v1; e.eachSeries(function (Ij) { var v2 = i._chartsMap[Ij.__viewId]; v2.__alive = true; var v3 = v2.renderTask; m.updatePayload(v3, Z); if (k && k.get(Ij.uid)) { v3.dirty() } v1 |= v3.perform(m.getPerformArgs(v3)); v2.group.silent = !!Ij.get("silent"); qE(Ij, v2); F4(Ij, v2) }); m.unfinished |= v1; Av(i._zr, e); ib(i._zr.dom, e) } function Cw(e, i) { CT(hE, function (k) { k(e, i) }) } var mI = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"]; Fp._initEvents = function () {
    CT(mI, function (e) { this._zr.on(e, function (v3) { var v2 = this.getModel(); var k = v3.target; var v; var i = e === "globalout"; if (i) { v = {} } else { if (k && k.dataIndex != null) { var Ij = k.dataModel || v2.getSeriesByIndex(k.seriesIndex); v = Ij && Ij.getDataParams(k.dataIndex, k.dataType) || {} } else { if (k && k.eventData) { v = b0({}, k.eventData) } } } if (v) { var m = v.componentType; var Z = v[m + "Index"]; var v1 = m && Z != null && v2.getComponent(m, Z); var Ik = v1 && this[v1.mainType === "series" ? "_chartsMap" : "_componentsMap"][v1.__viewId]; if (ok) { bM(i || (v1 && Ik)) } v.event = v3; v.type = e; var Il = this._ecEventProcessor; Il.targetEl = k; Il.packedEvent = v; Il.model = v1; Il.view = Ik; this.trigger(e, v) } }, this) }, this); CT(q5, function (e, i) {
      this._messageCenter.on(i, function (k) {
        this.trigger(i, k)
      }, this)
    }, this)
  }; Fp.isDisposed = function () { return this._disposed }; Fp.clear = function () { this.setOption({ series: [] }, true) }; Fp.dispose = function () { if (this._disposed) { if (ok) { console.warn("Instance " + this.id + " has been disposed") } return } this._disposed = true; bU(this.getDom(), ao, ""); var i = this._api; var e = this._model; CT(this._componentsViews, function (k) { k.dispose(e, i) }); CT(this._chartsViews, function (k) { k.dispose(e, i) }); this._zr.dispose(); delete az[this.id] }; Gq(t6, Gc); function Av(k, e) { var m = k.storage; var i = 0; m.traverse(function (v) { if (!v.isGroup) { i++ } }); if (i > e.get("hoverLayerThreshold") && !sW.node) { m.traverse(function (v) { if (!v.isGroup) { v.useHoverLayer = true } }) } } function F4(i, e) { var k = i.get("blendMode") || null; if (ok) { if (!sW.canvasSupported && k && k !== "source-over") { console.warn("Only canvas support blendMode") } } e.group.traverse(function (m) { if (!m.isGroup) { if (m.style.blend !== k) { m.setStyle("blend", k) } } if (m.eachPendingDisplayable) { m.eachPendingDisplayable(function (v) { v.setStyle("blend", k) }) } }) } function qE(k, i) { var m = k.get("z"); var e = k.get("zlevel"); i.group.traverse(function (v) { if (v.type !== "group") { m != null && (v.z = m); e != null && (v.zlevel = e) } }) } function k2(e) { var i = e._coordSysMgr; return b0(new lE(e), { getCoordinateSystems: km(i.getCoordinateSystems, i), getComponentByElement: function (k) { while (k) { var m = k.__ecComponentInfo; if (m != null) { return e._model.getComponent(m.mainType, m.index) } k = k.parent } } }) } function AW(e) { return { normalizeQuery: function (v2) { var v = {}; var v3 = {}; var Z = {}; if (wb(v2)) { var v1 = s9(v2); v.mainType = v1.main || null; v.subType = v1.sub || null } else { var m = ["Index", "Name", "Id"]; var k = { name: 1, dataIndex: 1, dataType: 1 }; o9(v2, function (Io, Im) { var Ik; for (var Il = 0; Il < m.length; Il++) { var In = m[Il]; var Ij = Im.lastIndexOf(In); if (Ij > 0 && Ij === Im.length - In.length) { var Ip = Im.slice(0, Ij); if (Ip !== "data") { v.mainType = Ip; v[In.toLowerCase()] = Io; Ik = true } } } if (k.hasOwnProperty(Im)) { v3[Im] = Io; Ik = true } if (!Ik) { Z[Im] = Io } }) } return { cptQuery: v, dataQuery: v3, otherQuery: Z } }, filter: function (k, v2, v1) { var Ik = this.targetEl; var Z = this.packedEvent; var v = this.model; var v3 = this.view; if (!v || !v3) { return true } var m = v2.cptQuery; var Ij = v2.dataQuery; return i(m, v, "mainType") && i(m, v, "subType") && i(m, v, "index", "componentIndex") && i(m, v, "name") && i(m, v, "id") && i(Ij, Z, "name") && i(Ij, Z, "dataIndex") && i(Ij, Z, "dataType") && (!v3.filterForExposedEvent || v3.filterForExposedEvent(k, v2.otherQuery, Ik, Z)) } }; function i(v, m, Z, k) { return v[Z] == null || m[k || Z] === v[Z] } } var cS = {}; var q5 = {}; var ix = []; var fZ = []; var hE = []; var c8 = []; var HR = {}; var FK = {}; var az = {}; var dN = {}; var cY = new Date() - 0; var ce = new Date() - 0; var ao = "_echarts_instance_"; function kP(m) { var e = 0; var v = 1; var k = 2; var i = "__connectUpdateStatus"; function Z(Ij, v1) { for (var v3 = 0; v3 < Ij.length; v3++) { var v2 = Ij[v3]; v2[i] = v1 } } CT(q5, function (v1, v2) { m._messageCenter.on(v2, function (v3) { if (dN[m.group] && m[i] !== e) { if (v3 && v3.escapeConnect) { return } var Ij = m.makeActionFromEvent(v3); var Ik = []; CT(az, function (Il) { if (Il !== m && Il.group === m.group) { Ik.push(Il) } }); Z(Ik, e); CT(Ik, function (Il) { if (Il[i] !== v) { Il.dispatchAction(Ij) } }); Z(Ik, k) } }) }) } function EV(v, k, i) { if (ok) { if ((s5.replace(".", "") - 0) < (qY.zrender.replace(".", "") - 0)) { throw new Error("zrender/src " + s5 + " is too old for ECharts " + H5 + ". Current version need ZRender " + qY.zrender + "+") } if (!v) { throw new Error("Initialize failed: invalid dom.") } } var m = b2(v); if (m) { if (ok) { console.warn("There is a chart instance already initialized on the dom.") } return m } if (ok) { if (ay(v) && v.nodeName.toUpperCase() !== "CANVAS" && ((!v.clientWidth && (!i || i.width == null)) || (!v.clientHeight && (!i || i.height == null)))) { console.warn("Can't get dom width or height") } } var e = new t6(v, k, i); e.id = "ec_" + cY++; az[e.id] = e; bU(v, ao, e.id); kP(e); return e } function nM(e) { if (GG(e)) { var i = e; e = null; CT(i, function (k) { if (k.group != null) { e = k.group } }); e = e || ("g_" + ce++); CT(i, function (k) { k.group = e }) } dN[e] = true; return e } function hF(e) { dN[e] = false } var yW = hF; function u3(e) { if (typeof e === "string") { e = az[e] } else { if (!(e instanceof t6)) { e = b2(e) } } if ((e instanceof t6) && !e.isDisposed()) { e.dispose() } } function b2(e) { return az[vN(e, ao)] } function dT(e) { return az[e] } function zx(e, i) { HR[e] = i } function y2(e) { fZ.push(e) } function eb(e, i) { yR(ix, e, i, ig) } function wh(e) { hE.push(e) } function b1(k, e, m) { if (typeof e === "function") { m = e; e = "" } var i = j0(k) ? k.type : ([k, k = { event: e }][0]); k.event = (k.event || i).toLowerCase(); e = k.event; ag(f6.test(i) && f6.test(e)); if (!cS[i]) { cS[i] = { action: m, actionInfo: k } } q5[e] = i } function wA(i, e) { fz.register(i, e) } function g1(e) { var i = fz.get(e); if (i) { return i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice() } } function pr(i, e) { yR(c8, i, e, am, "layout") } function G(e, i) { yR(c8, e, i, yl, "visual") } function yR(Z, i, k, e, v) { if (oO(i) || j0(i)) { k = i; i = e } if (ok) { if (isNaN(i) || i == null) { throw new Error("Illegal priority") } CT(Z, function (v1) { ag(v1.__raw !== k) }) } var m = ES.wrapStageHandler(k, v); m.__prio = i; m.__raw = k; Z.push(m); return m } function xV(i, e) { FK[i] = e } function p2(e) { return aH.extend(e) } function qy(e) { return sT.extend(e) } function B3(e) { return nU.extend(e) } function BL(e) { return dF.extend(e) } function eG(e) { AQ("createCanvas", e) } function fE(i, e, k) {
    DS.registerMap(i, e, k)
  } function va(i) { var e = DS.retrieveMap(i); return e && e[0] && { geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas } } G(pc, CC); y2(Hr); eb(rK, vZ); xV("default", uI); b1({ type: "highlight", event: "highlight", update: "highlight" }, V); b1({ type: "downplay", event: "downplay", update: "downplay" }, V); zx("light", bv); zx("dark", qt); var wB = {}; function Ae(e) { return e } function Gx(k, v, i, m, e) { this._old = k; this._new = v; this._oldKeyGetter = i || Ae; this._newKeyGetter = m || Ae; this.context = e } Gx.prototype = { constructor: Gx, add: function (e) { this._add = e; return this }, update: function (e) { this._update = e; return this }, remove: function (e) { this._remove = e; return this }, execute: function () { var e = this._old; var v = this._new; var v1 = {}; var m = {}; var v2 = []; var Ij = []; var Z; yS(e, v1, v2, "_oldKeyGetter", this); yS(v, m, Ij, "_newKeyGetter", this); for (Z = 0; Z < e.length; Z++) { var Il = v2[Z]; var Ik = m[Il]; if (Ik != null) { var v3 = Ik.length; if (v3) { v3 === 1 && (m[Il] = null); Ik = Ik.unshift() } else { m[Il] = null } this._update && this._update(Ik, Z) } else { this._remove && this._remove(Z) } } for (var Z = 0; Z < Ij.length; Z++) { var Il = Ij[Z]; if (m.hasOwnProperty(Il)) { var Ik = m[Il]; if (Ik == null) { continue } if (!Ik.length) { this._add && this._add(Ik) } else { for (var k = 0, v3 = Ik.length; k < v3; k++) { this._add && this._add(Ik[k]) } } } } } }; function yS(e, v1, k, v3, Z) { for (var v = 0; v < e.length; v++) { var m = "_ec_" + Z[v3](e[v], v); var v2 = v1[m]; if (v2 == null) { k.push(m); v1[m] = v } else { if (!v2.length) { v1[m] = v2 = [v2] } v2.push(v) } } } var wc = CJ(["tooltip", "label", "itemName", "itemId", "seriesName"]); function H0(m) { var v1 = {}; var Z = v1.encode = {}; var e = CJ(); var v3 = []; var Ij = []; o9(m.dimensions, function (In) { var Ik = m.getDimensionInfo(In); var Im = Ik.coordDim; if (Im) { if (ok) { bM(wc.get(Im) == null) } var Il = Z[Im]; if (!Z.hasOwnProperty(Im)) { Il = Z[Im] = [] } Il[Ik.coordDimIndex] = In; if (!Ik.isExtraCoord) { e.set(Im, 1); if (hh(Ik.type)) { v3[0] = In } } if (Ik.defaultTooltip) { Ij.push(In) } } wc.each(function (Ip, Io) { var Ir = Z[Io]; if (!Z.hasOwnProperty(Io)) { Ir = Z[Io] = [] } var Iq = Ik.otherDims[Io]; if (Iq != null && Iq !== false) { Ir[Iq] = Ik.name } }) }); var v2 = []; var v = {}; e.each(function (Ik, Im) { var Il = Z[Im]; v[Im] = Il[0]; v2 = v2.concat(Il) }); v1.dataDimsOnCoord = v2; v1.encodeFirstDimNotExtra = v; var i = Z.label; if (i && i.length) { v3 = i.slice() } var k = Z.tooltip; if (k && k.length) { Ij = k.slice() } else { if (!Ij.length) { Ij = v3.slice() } } Z.defaultedLabel = v3; Z.defaultedTooltip = Ij; return v1 } function qI(e) { return e === "category" ? "ordinal" : e === "time" ? "time" : "float" } function hh(e) { return !(e === "ordinal" || e === "time") } var tF = tJ; var g4 = "undefined"; var bm = "e\0\0"; var xg = { "float": typeof Float64Array === g4 ? Array : Float64Array, "int": typeof Int32Array === g4 ? Array : Int32Array, "ordinal": Array, "number": Array, "time": Array }; var F = typeof Uint32Array === g4 ? Array : Uint32Array; var bn = typeof Uint16Array === g4 ? Array : Uint16Array; function A8(e) { return e._rawCount > 65535 ? F : bn } function sJ(i) { var e = i.constructor; return e === Array ? i.slice() : new e(i) } var gj = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"]; var pi = ["_extent", "_approximateExtent", "_rawExtent"]; function dY(i, e) { o9(gj.concat(e.__wrappedMethods || []), function (k) { if (e.hasOwnProperty(k)) { i[k] = e[k] } }); i.__wrappedMethods = e.__wrappedMethods; o9(pi, function (k) { i[k] = C5(e[k]) }); i._calculationInfo = b0(e._calculationInfo) } var xt = function (v, v3) { v = v || ["x", "y"]; var v2 = {}; var v1 = []; var m = {}; for (var k = 0; k < v.length; k++) { var Z = v[k]; if (wb(Z)) { Z = { name: Z } } var e = Z.name; Z.type = Z.type || "float"; if (!Z.coordDim) { Z.coordDim = e; Z.coordDimIndex = 0 } Z.otherDims = Z.otherDims || {}; v1.push(e); v2[e] = Z; Z.index = k; if (Z.createInvertedIndices) { m[e] = [] } } this.dimensions = v1; this._dimensionInfos = v2; this.hostModel = v3; this.dataType; this._indices = null; this._count = 0; this._rawCount = 0; this._storage = {}; this._nameList = []; this._idList = []; this._optionModels = []; this._visual = {}; this._layout = {}; this._itemVisuals = []; this.hasItemVisual = {}; this._itemLayouts = []; this._graphicEls = []; this._chunkSize = 100000; this._chunkCount = 0; this._rawData; this._rawExtent = {}; this._extent = {}; this._approximateExtent = {}; this._dimensionsSummary = H0(this); this._invertedIndicesMap = m; this._calculationInfo = {} }; var up = xt.prototype; up.type = "list"; up.hasItemOption = true; up.getDimension = function (e) { if (!isNaN(e)) { e = this.dimensions[e] || e } return e }; up.getDimensionInfo = function (e) { return this._dimensionInfos[this.getDimension(e)] }; up.getDimensionsOnCoord = function () { return this._dimensionsSummary.dataDimsOnCoord.slice() }; up.mapDimension = function (i, e) { var k = this._dimensionsSummary; if (e == null) { return k.encodeFirstDimNotExtra[i] } var m = k.encode[i]; return e === true ? (m || []).slice() : (m && m[e]) }; up.initData = function (k, m, e) {
    var i = qn.isInstance(k) || sP(k); if (i) { k = new fS(k, this.dimensions.length) } if (ok) { if (!i && (typeof k.getItem != "function" || typeof k.count != "function")) { throw new Error("Inavlid data provider.") } } this._rawData = k; this._storage = {}; this._indices = null; this._nameList = m || []; this._idList = []; this._nameRepeatCount = {}; if (!e) { this.hasItemOption = false } this.defaultDimValueGetter = kG[this._rawData.getSource().sourceFormat]; this._dimValueGetter = e = e || this.defaultDimValueGetter;
    this._rawExtent = {}; this._initDataFromProvider(0, k.count()); if (k.pure) { this.hasItemOption = false }
  }; up.getProvider = function () { return this._rawData }; up.appendData = function (i) { if (ok) { bM(!this._indices, "appendData can only be called on raw data.") } var m = this._rawData; var k = this.count(); m.appendData(i); var e = m.count(); if (!m.persistent) { e += k } this._initDataFromProvider(k, e) }; up._initDataFromProvider = function (Ik, Ij) { if (Ik >= Ij) { return } var Ip = this._chunkSize; var Ix = this._rawData; var IF = this._storage; var In = this.dimensions; var Io = In.length; var IH = this._dimensionInfos; var IG = this._nameList; var Iy = this._idList; var Z = this._rawExtent; var II = this._nameRepeatCount = {}; var Iw; var m = this._chunkCount; var IC = m - 1; for (var ID = 0; ID < Io; ID++) { var IB = In[ID]; if (!Z[IB]) { Z[IB] = eh() } var Il = IH[IB]; if (Il.otherDims.itemName === 0) { Iw = this._nameDimIdx = ID } if (Il.otherDims.itemId === 0) { this._idDimIdx = ID } var IE = xg[Il.type]; if (!IF[IB]) { IF[IB] = [] } var Ir = IF[IB][IC]; if (Ir && Ir.length < Ip) { var v2 = new IE(Math.min(Ij - IC * Ip, Ip)); for (var IA = 0; IA < Ir.length; IA++) { v2[IA] = Ir[IA] } IF[IB][IC] = v2 } for (var Iz = m * Ip; Iz < Ij; Iz += Ip) { IF[IB].push(new IE(Math.min(Ij - Iz, Ip))) } this._chunkCount = IF[IB].length } var Iq = new Array(Io); for (var Is = Ik; Is < Ij; Is++) { Iq = Ix.getItem(Is, Iq); var e = Math.floor(Is / Ip); var v3 = Is % Ip; for (var Iz = 0; Iz < Io; Iz++) { var IB = In[Iz]; var Im = IF[IB][e]; var IK = this._dimValueGetter(Iq, IB, Is, Iz); Im[v3] = IK; var Iv = Z[IB]; if (IK < Iv[0]) { Iv[0] = IK } if (IK > Iv[1]) { Iv[1] = IK } } if (!Ix.pure) { var IJ = IG[Is]; if (Iq && IJ == null) { if (Iq.name != null) { IG[Is] = IJ = Iq.name } else { if (Iw != null) { var It = In[Iw]; var v = IF[It][e]; if (v) { IJ = v[v3]; var v1 = IH[It].ordinalMeta; if (v1 && v1.categories.length) { IJ = v1.categories[IJ] } } } } } var Iu = Iq == null ? null : Iq.id; if (Iu == null && IJ != null) { II[IJ] = II[IJ] || 0; Iu = IJ; if (II[IJ] > 0) { Iu += "__ec__" + II[IJ] } II[IJ]++ } Iu != null && (Iy[Is] = Iu) } } if (!Ix.persistent && Ix.clean) { Ix.clean() } this._rawCount = this._count = Ij; this._extent = {}; GS(this) }; function GS(i) { var e = i._invertedIndicesMap; o9(e, function (k, v1) { var v = i._dimensionInfos[v1]; var m = v.ordinalMeta; if (m) { k = e[v1] = new F(m.categories.length); for (var Z = 0; Z < k.length; Z++) { k[Z] = NaN } for (var Z = 0; Z < i._count; Z++) { k[i.get(v1, Z)] = Z } } }) } function nT(v2, Ij, e) { var i; if (Ij != null) { var m = v2._chunkSize; var v1 = Math.floor(e / m); var k = e % m; var v = v2.dimensions[Ij]; var v3 = v2._storage[v][v1]; if (v3) { i = v3[k]; var Z = v2._dimensionInfos[v].ordinalMeta; if (Z && Z.categories.length) { i = Z.categories[i] } } } return i } up.count = function () { return this._count }; up.getIndices = function () { var v; var Z = this._indices; if (Z) { var k = Z.constructor; var e = this._count; if (k === Array) { v = new k(e); for (var m = 0; m < e; m++) { v[m] = Z[m] } } else { v = new k(Z.buffer, 0, e) } } else { var k = A8(this); var v = new k(this.count()); for (var m = 0; m < v.length; m++) { v[m] = m } } return v }; up.get = function (Z, e) { if (!(e >= 0 && e < this._count)) { return NaN } var v1 = this._storage; if (!v1[Z]) { return NaN } e = this.getRawIndex(e); var k = Math.floor(e / this._chunkSize); var v = e % this._chunkSize; var i = v1[Z][k]; var m = i[v]; return m }; up.getByRawIndex = function (v, Z) { if (!(Z >= 0 && Z < this._rawCount)) { return NaN } var k = this._storage[v]; if (!k) { return NaN } var i = Math.floor(Z / this._chunkSize); var m = Z % this._chunkSize; var e = k[i]; return e[m] }; up._getFast = function (m, v) { var i = Math.floor(v / this._chunkSize); var k = v % this._chunkSize; var e = this._storage[m][i]; return e[k] }; up.getValues = function (Z, k) { var m = []; if (!GG(Z)) { k = Z; Z = this.dimensions } for (var v = 0, e = Z.length; v < e; v++) { m.push(this.get(Z[v], k)) } return m }; up.hasValue = function (m) { var k = this._dimensionsSummary.dataDimsOnCoord; var Z = this._dimensionInfos; for (var v = 0, e = k.length; v < e; v++) { if (Z[k[v]].type !== "ordinal" && isNaN(this.get(k[v], m))) { return false } } return true }; up.getDataExtent = function (Z) { Z = this.getDimension(Z); var v2 = this._storage[Z]; var v1 = eh(); if (!v2) { return v1 } var e = this.count(); var v = !this._indices; var v3; if (v) { return this._rawExtent[Z].slice() } v3 = this._extent[Z]; if (v3) { return v3.slice() } v3 = v1; var k = v3[0]; var Ij = v3[1]; for (var m = 0; m < e; m++) { var Ik = this._getFast(Z, this.getRawIndex(m)); Ik < k && (k = Ik); Ik > Ij && (Ij = Ik) } v3 = [k, Ij]; this._extent[Z] = v3; return v3 }; up.getApproximateExtent = function (e) { e = this.getDimension(e); return this._approximateExtent[e] || this.getDataExtent(e) }; up.setApproximateExtent = function (e, i) { i = this.getDimension(i); this._approximateExtent[i] = e.slice() }; up.getCalculationInfo = function (e) { return this._calculationInfo[e] }; up.setCalculationInfo = function (e, i) { tF(e) ? b0(this._calculationInfo, e) : (this._calculationInfo[e] = i) }; up.getSum = function (v1) { var k = this._storage[v1]; var v = 0; if (k) { for (var m = 0, e = this.count(); m < e; m++) { var Z = this.get(v1, m); if (!isNaN(Z)) { v += Z } } } return v }; up.getMedian = function (m) { var i = []; this.each(m, function (Z, v) { if (!isNaN(Z)) { i.push(Z) } }); var k = [].concat(i).sort(function (Z, v) { return Z - v }); var e = this.count(); return e === 0 ? 0 : e % 2 === 1 ? k[(e - 1) / 2] : (k[e / 2] + k[e / 2 - 1]) / 2 }; up.rawIndexOf = function (m, k) { var e = m && this._invertedIndicesMap[m]; if (ok) { if (!e) { throw new Error("Do not supported yet") } } var i = e[k]; if (i == null || isNaN(i)) { return -1 } return i }; up.indexOfName = function (k) { for (var m = 0, e = this.count(); m < e; m++) { if (this.getName(m) === k) { return m } } return -1 }; up.indexOfRawIndex = function (k) {
    if (!this._indices) {
      return k
    } if (k >= this._rawCount || k < 0) { return -1 } var Z = this._indices; var i = Z[k]; if (i != null && i < this._count && i === k) { return k } var v = 0; var m = this._count - 1; while (v <= m) { var e = (v + m) / 2 | 0; if (Z[e] < k) { v = e + 1 } else { if (Z[e] > k) { m = e - 1 } else { return e } } } return -1
  }; up.indicesOfNearest = function (v, Ik, e) { var v1 = this._storage; var v3 = v1[v]; var k = []; if (!v3) { return k } if (e == null) { e = Infinity } var Il = Number.MAX_VALUE; var Im = -1; for (var m = 0, Z = this.count(); m < Z; m++) { var Ij = Ik - this.get(v, m); var v2 = Math.abs(Ij); if (Ij <= e && v2 <= Il) { if (v2 < Il || (Ij >= 0 && Im < 0)) { Il = v2; Im = Ij; k.length = 0 } k.push(m) } } return k }; up.getRawIndex = yq; function yq(e) { return e } function qe(e) { if (e < this._count && e >= 0) { return this._indices[e] } return -1 } up.getRawDataItem = function (e) { if (!this._rawData.persistent) { var v = []; for (var k = 0; k < this.dimensions.length; k++) { var m = this.dimensions[k]; v.push(this.get(m, e)) } return v } else { return this._rawData.getItem(this.getRawIndex(e)) } }; up.getName = function (e) { var i = this.getRawIndex(e); return this._nameList[i] || nT(this, this._nameDimIdx, i) || "" }; up.getId = function (e) { return wC(this, this.getRawIndex(e)) }; function wC(i, e) { var k = i._idList[e]; if (k == null) { k = nT(i, i._idDimIdx, e) } if (k == null) { k = bm + e } return k } function vo(e) { if (!GG(e)) { e = [e] } return e } function pk(k, m) { for (var e = 0; e < m.length; e++) { if (!k._dimensionInfos[m[e]]) { console.error("Unkown dimension " + m[e]) } } } up.each = function (Ij, e, Z, v1) { if (!this._count) { return } if (typeof Ij === "function") { v1 = Z; Z = e; e = Ij; Ij = [] } Z = Z || v1 || this; Ij = Ef(vo(Ij), this.getDimension, this); if (ok) { pk(this, Ij) } var v3 = Ij.length; for (var v = 0; v < this.count(); v++) { switch (v3) { case 0: e.call(Z, v); break; case 1: e.call(Z, this.get(Ij[0], v), v); break; case 2: e.call(Z, this.get(Ij[0], v), this.get(Ij[1], v), v); break; default: var m = 0; var v2 = []; for (; m < v3; m++) { v2[m] = this.get(Ij[m], v) } v2[m] = v; e.apply(Z, v2) } } }; up.filterSelf = function (m, Ij, v, Ir) { if (!this._count) { return } if (typeof m === "function") { Ir = v; v = Ij; Ij = m; m = [] } v = v || Ir || this; m = Ef(vo(m), this.getDimension, this); if (ok) { pk(this, m) } var Io = this.count(); var Z = A8(this); var v3 = new Z(Io); var Iq = []; var v2 = m.length; var Im = 0; var Ip = m[0]; for (var In = 0; In < Io; In++) { var e; var Il = this.getRawIndex(In); if (v2 === 0) { e = Ij.call(v, In) } else { if (v2 === 1) { var v1 = this._getFast(Ip, Il); e = Ij.call(v, v1, In) } else { for (var Ik = 0; Ik < v2; Ik++) { Iq[Ik] = this._getFast(Ip, Il) } Iq[Ik] = In; e = Ij.apply(v, Iq) } } if (e) { v3[Im++] = Il } } if (Im < Io) { this._indices = v3 } this._count = Im; this._extent = {}; this.getRawIndex = this._indices ? qe : yq; return this }; up.selectRange = function (Ij) { if (!this._count) { return } var Z = []; for (var Is in Ij) { if (Ij.hasOwnProperty(Is)) { Z.push(Is) } } if (ok) { pk(this, Z) } var IC = Z.length; if (!IC) { return } var Il = this.count(); var v3 = A8(this); var Iy = new v3(Il); var m = 0; var e = Z[0]; var Iq = Ij[e][0]; var Iu = Ij[e][1]; var Im = false; if (!this._indices) { var Ik = 0; if (IC === 1) { var v = this._storage[Z[0]]; for (var Ir = 0; Ir < this._chunkCount; Ir++) { var Io = v[Ir]; var Iv = Math.min(this._count - Ir * this._chunkSize, this._chunkSize); for (var It = 0; It < Iv; It++) { var IB = Io[It]; if ((IB >= Iq && IB <= Iu) || isNaN(IB)) { Iy[m++] = Ik } Ik++ } } Im = true } else { if (IC === 2) { var v = this._storage[e]; var v1 = this._storage[Z[1]]; var Ip = Ij[Z[1]][0]; var In = Ij[Z[1]][1]; for (var Ir = 0; Ir < this._chunkCount; Ir++) { var Io = v[Ir]; var IA = v1[Ir]; var Iv = Math.min(this._count - Ir * this._chunkSize, this._chunkSize); for (var It = 0; It < Iv; It++) { var IB = Io[It]; var Iz = IA[It]; if (((IB >= Iq && IB <= Iu) || isNaN(IB)) && ((Iz >= Ip && Iz <= In) || isNaN(Iz))) { Iy[m++] = Ik } Ik++ } } Im = true } } } if (!Im) { if (IC === 1) { for (var It = 0; It < Il; It++) { var v2 = this.getRawIndex(It); var IB = this._getFast(e, v2); if ((IB >= Iq && IB <= Iu) || isNaN(IB)) { Iy[m++] = v2 } } } else { for (var It = 0; It < Il; It++) { var Ix = true; var v2 = this.getRawIndex(It); for (var Ir = 0; Ir < IC; Ir++) { var Iw = Z[Ir]; var IB = this._getFast(Is, v2); if (IB < Ij[Iw][0] || IB > Ij[Iw][1]) { Ix = false } } if (Ix) { Iy[m++] = this.getRawIndex(It) } } } } if (m < Il) { this._indices = Iy } this._count = m; this._extent = {}; this.getRawIndex = this._indices ? qe : yq; return this }; up.mapArray = function (v, i, k, m) { if (typeof v === "function") { m = k; k = i; i = v; v = [] } k = k || m || this; var e = []; this.each(v, function () { e.push(i && i.apply(this, arguments)) }, k); return e }; function CW(m, Z) { var v = m.dimensions; var v1 = new xt(Ef(v, m.getDimensionInfo, m), m.hostModel); dY(v1, m); var v3 = v1._storage = {}; var k = m._storage; for (var e = 0; e < v.length; e++) { var v2 = v[e]; if (k[v2]) { if (eP(Z, v2) >= 0) { v3[v2] = ov(k[v2]); v1._rawExtent[v2] = eh(); v1._extent[v2] = null } else { v3[v2] = k[v2] } } } return v1 } function ov(i) { var e = new Array(i.length); for (var k = 0; k < i.length; k++) { e[k] = sJ(i[k]) } return e } function eh() { return [Infinity, -Infinity] } up.map = function (v1, Io, v, Ij) {
    v = v || Ij || this; v1 = Ef(vo(v1), this.getDimension, this); if (ok) { pk(this, v1) } var Is = CW(this, v1); Is._indices = this._indices; Is.getRawIndex = Is._indices ? qe : yq; var It = Is._storage; var Ir = []; var v2 = this._chunkSize; var Ix = v1.length; var Iu = this.count(); var m = []; var k = Is._rawExtent; for (var Iv = 0; Iv < Iu; Iv++) {
      for (var Im = 0; Im < Ix; Im++) { m[Im] = this.get(v1[Im], Iv) } m[Ix] = Iv; var In = Io && Io.apply(v, m); if (In != null) {
        if (typeof In !== "object") { Ir[0] = In; In = Ir } var v3 = this.getRawIndex(Iv); var e = Math.floor(v3 / v2); var Z = v3 % v2; for (var Iq = 0; Iq < In.length; Iq++) {
          var Ip = v1[Iq]; var Iw = In[Iq]; var Il = k[Ip]; var Ik = It[Ip];
          if (Ik) { Ik[e][Z] = Iw } if (Iw < Il[0]) { Il[0] = Iw } if (Iw > Il[1]) { Il[1] = Iw }
        }
      }
    } return Is
  }; up.downSample = function (Iu, Ix, It, v1) { var Is = CW(this, [Iu]); var e = Is._storage; var Iw = []; var Il = Math.floor(1 / Ix); var v3 = e[Iu]; var Io = this.count(); var v = this._chunkSize; var Ij = Is._rawExtent[Iu]; var Iq = new (A8(this))(Io); var m = 0; for (var In = 0; In < Io; In += Il) { if (Il > Io - In) { Il = Io - In; Iw.length = Il } for (var Im = 0; Im < Il; Im++) { var Ip = this.getRawIndex(In + Im); var Ir = Math.floor(Ip / v); var Iv = Ip % v; Iw[Im] = v3[Ir][Iv] } var Ik = It(Iw); var Iy = this.getRawIndex(Math.min(In + v1(Iw, Ik) || 0, Io - 1)); var Z = Math.floor(Iy / v); var v2 = Iy % v; v3[Z][v2] = Ik; if (Ik < Ij[0]) { Ij[0] = Ik } if (Ik > Ij[1]) { Ij[1] = Ik } Iq[m++] = Iy } Is._count = m; Is._indices = Iq; Is.getRawIndex = qe; return Is }; up.getItemModel = function (e) { var i = this.hostModel; return new fv(this.getRawDataItem(e), i, i && i.ecModel) }; up.diff = function (i) { var e = this; return new Gx(i ? i.getIndices() : [], this.getIndices(), function (k) { return wC(i, k) }, function (k) { return wC(e, k) }) }; up.getVisual = function (e) { var i = this._visual; return i && i[e] }; up.setVisual = function (i, k) { if (tF(i)) { for (var e in i) { if (i.hasOwnProperty(e)) { this.setVisual(e, i[e]) } } return } this._visual = this._visual || {}; this._visual[i] = k }; up.setLayout = function (i, k) { if (tF(i)) { for (var e in i) { if (i.hasOwnProperty(e)) { this.setLayout(e, i[e]) } } return } this._layout[i] = k }; up.getLayout = function (e) { return this._layout[e] }; up.getItemLayout = function (e) { return this._itemLayouts[e] }; up.setItemLayout = function (e, k, i) { this._itemLayouts[e] = i ? b0(this._itemLayouts[e] || {}, k) : k }; up.clearItemLayouts = function () { this._itemLayouts.length = 0 }; up.getItemVisual = function (e, k, i) { var m = this._itemVisuals[e]; var v = m && m[k]; if (v == null && !i) { return this.getVisual(k) } return v }; up.setItemVisual = function (e, k, v) { var m = this._itemVisuals[e] || {}; var Z = this.hasItemVisual; this._itemVisuals[e] = m; if (tF(k)) { for (var i in k) { if (k.hasOwnProperty(i)) { m[i] = k[i]; Z[i] = true } } return } m[k] = v; Z[k] = true }; up.clearAllVisual = function () { this._visual = {}; this._itemVisuals = []; this.hasItemVisual = {} }; var AY = function (e) { e.seriesIndex = this.seriesIndex; e.dataIndex = this.dataIndex; e.dataType = this.dataType }; up.setItemGraphicEl = function (e, i) { var k = this.hostModel; if (i) { i.dataIndex = e; i.dataType = this.dataType; i.seriesIndex = k && k.seriesIndex; if (i.type === "group") { i.traverse(AY, i) } } this._graphicEls[e] = i }; up.getItemGraphicEl = function (e) { return this._graphicEls[e] }; up.eachItemGraphicEl = function (e, i) { o9(this._graphicEls, function (m, k) { if (m) { e && e.call(i, m, k) } }) }; up.cloneShallow = function (k) { if (!k) { var i = Ef(this.dimensions, this.getDimensionInfo, this); k = new xt(i, this.hostModel) } k._storage = this._storage; dY(k, this); if (this._indices) { var e = this._indices.constructor; k._indices = new e(this._indices) } else { k._indices = null } k.getRawIndex = k._indices ? qe : yq; return k }; up.wrapMethod = function (e, i) { var k = this[e]; if (typeof k !== "function") { return } this.__wrappedMethods = this.__wrappedMethods || []; this.__wrappedMethods.push(e); this[e] = function () { var m = k.apply(this, arguments); return i.apply(this, [m].concat(h7(arguments))) } }; up.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"]; up.CHANGABLE_METHODS = ["filterSelf", "selectRange"]; function HD(v2, Is, k) { if (!qn.isInstance(Is)) { Is = qn.seriesDataToSource(Is) } k = k || {}; v2 = (v2 || []).slice(); var v = (k.dimsDef || []).slice(); var v3 = CJ(k.encodeDef); var Io = CJ(); var Ip = CJ(); var Im = []; var In = Do(Is, v2, v, k.dimCount); for (var Iv = 0; Iv < In; Iv++) { var Ik = v[Iv] = b0({}, tJ(v[Iv]) ? v[Iv] : { name: v[Iv] }); var Il = Ik.name; var e = Im[Iv] = { otherDims: {} }; if (Il != null && Io.get(Il) == null) { e.name = e.displayName = Il; Io.set(Il, Iv) } Ik.type != null && (e.type = Ik.type); Ik.displayName != null && (e.displayName = Ik.displayName) } v3.each(function (Ix, Iw) { Ix = mp(Ix).slice(); var i = v3.set(Iw, []); o9(Ix, function (Iz, Iy) { wb(Iz) && (Iz = Io.get(Iz)); if (Iz != null && Iz < In) { i[Iy] = Iz; Ir(Im[Iz], Iw, Iy) } }) }); var Iq = 0; o9(v2, function (ID, Iz) { var IB; var ID; var Iy; var Iw; if (wb(ID)) { IB = ID; ID = {} } else { IB = ID.name; var Ix = ID.ordinalMeta; ID.ordinalMeta = null; ID = C5(ID); ID.ordinalMeta = Ix; Iy = ID.dimsDef; Iw = ID.otherDims; ID.name = ID.coordDim = ID.coordDimIndex = ID.dimsDef = ID.otherDims = null } var IC = mp(v3.get(IB)); if (!IC.length) { for (var IA = 0; IA < (Iy && Iy.length || 1); IA++) { while (Iq < Im.length && Im[Iq].coordDim != null) { Iq++ } Iq < Im.length && IC.push(Iq++) } } o9(IC, function (IG, IF) { var i = Im[IG]; Ir(De(i, ID), IB, IF); if (i.name == null && Iy) { var IE = Iy[IF]; !tJ(IE) && (IE = { name: IE }); i.name = i.displayName = IE.name; i.defaultTooltip = IE.defaultTooltip } Iw && De(i.otherDims, Iw) }) }); function Ir(i, Iw, Ix) { if (wc.get(Iw) != null) { i.otherDims[Iw] = Ix } else { i.coordDim = Iw; i.coordDimIndex = Ix; Ip.set(Iw, true) } } var Iu = k.generateCoord; var v1 = k.generateCoordCount; var Z = v1 != null; v1 = Iu ? (v1 || 1) : 0; var m = Iu || "value"; for (var Ij = 0; Ij < In; Ij++) { var e = Im[Ij] = Im[Ij] || {}; var It = e.coordDim; if (It == null) { e.coordDim = oE(m, Ip, Z); e.coordDimIndex = 0; if (!Iu || v1 <= 0) { e.isExtraCoord = true } v1-- } e.name == null && (e.name = oE(e.coordDim, Io)); if (e.type == null && vx(Is, Ij, e.name)) { e.type = "ordinal" } } return Im } function Do(m, i, k, v) { var e = Math.max(m.dimensionsDetectCount || 1, i.length, k.length, v || 0); o9(i, function (v1) { var Z = v1.dimsDef; Z && (e = Math.max(e, Z.length)) }); return e } function oE(e, m, v) {
    if (v || m.get(e) != null) {
      var k = 0;
      while (m.get(e + k) != null) { k++ } e += k
    } m.set(e, true); return e
  } var yw = function (i, e) { e = e || {}; return HD(e.coordDimensions || [], i, { dimsDef: e.dimensionsDefine || i.dimensionsDefine, encodeDef: e.encodeDefine || i.encodeDefine, dimCount: e.dimensionsCount, generateCoord: e.generateCoord, generateCoordCount: e.generateCoordCount }) }; function j1(m, v1, i) { i = i || {}; var Ij = i.byIndex; var k = i.stackedCoordDimension; var Ik = !!(m && m.get("stack")); var v; var Im; var Il; var e; o9(v1, function (Io, In) { if (wb(Io)) { v1[In] = Io = { name: Io } } if (Ik && !Io.isExtraCoord) { if (!Ij && !v && Io.ordinalMeta) { v = Io } if (!Im && Io.type !== "ordinal" && Io.type !== "time" && (!k || k === Io.coordDim)) { Im = Io } } }); if (Im && !Ij && !v) { Ij = true } if (Im) { Il = "__\0ecstackresult"; e = "__\0ecstackedover"; if (v) { v.createInvertedIndices = true } var v2 = Im.coordDim; var Z = Im.type; var v3 = 0; o9(v1, function (In) { if (In.coordDim === v2) { v3++ } }); v1.push({ name: Il, coordDim: v2, coordDimIndex: v3, type: Z, isExtraCoord: true, isCalculationCoord: true }); v3++; v1.push({ name: e, coordDim: e, coordDimIndex: v3, type: Z, isExtraCoord: true, isCalculationCoord: true }) } return { stackedDimension: Im && Im.name, stackedByDimension: v && v.name, isStackedByIndex: Ij, stackedOverDimension: e, stackResultDimension: Il } } function lU(i, e) { return !!e && e === i.getCalculationInfo("stackedDimension") } function jB(i, e) { return lU(i, e) ? i.getCalculationInfo("stackResultDimension") : e } function a(e, v, i) { i = i || {}; if (!qn.isInstance(e)) { e = qn.seriesDataToSource(e) } var m = v.get("coordinateSystem"); var Im = fz.get(m); var k = si(v); var Z; if (k) { Z = Ef(k.coordSysDims, function (Iq) { var Io = { name: Iq }; var Ip = k.axisMap.get(Iq); if (Ip) { var In = Ip.get("type"); Io.type = qI(In) } return Io }) } if (!Z) { Z = (Im && (Im.getDimensionsInfo ? Im.getDimensionsInfo() : Im.dimensions.slice())) || ["x", "y"] } var v1 = yw(e, { coordDimensions: Z, generateCoord: i.generateCoord }); var Ij; var v3; k && o9(v1, function (In, Iq) { var Ip = In.coordDim; var Io = k.categoryAxisMap.get(Ip); if (Io) { if (Ij == null) { Ij = Iq } In.ordinalMeta = Io.getOrdinalMeta() } if (In.otherDims.itemName != null) { v3 = true } }); if (!v3 && Ij != null) { v1[Ij].otherDims.itemName = 0 } var Il = j1(v, v1); var v2 = new xt(v1, v); v2.setCalculationInfo(Il); var Ik = (Ij != null && Gd(e)) ? function (Iq, Ip, In, Io) { return Io === Ij ? In : this.defaultDimValueGetter(Iq, Ip, In, Io) } : null; v2.hasItemOption = false; v2.initData(e, null, Ik); return v2 } function Gd(i) { if (i.sourceFormat === fD) { var e = t0(i.data || []); return e != null && !GG(xW(e)) } } function t0(k) { var e = 0; while (e < k.length && k[e] == null) { e++ } return k[e] } function dz(e) { this._setting = e || {}; this._extent = [Infinity, -Infinity]; this._interval = 0; this.init && this.init.apply(this, arguments) } dz.prototype.parse = function (e) { return e }; dz.prototype.getSetting = function (e) { return this._setting[e] }; dz.prototype.contain = function (i) { var e = this._extent; return i >= e[0] && i <= e[1] }; dz.prototype.normalize = function (i) { var e = this._extent; if (e[1] === e[0]) { return 0.5 } return (i - e[0]) / (e[1] - e[0]) }; dz.prototype.scale = function (i) { var e = this._extent; return i * (e[1] - e[0]) + e[0] }; dz.prototype.unionExtent = function (e) { var i = this._extent; e[0] < i[0] && (i[0] = e[0]); e[1] > i[1] && (i[1] = e[1]) }; dz.prototype.unionExtentFromData = function (e, i) { this.unionExtent(e.getApproximateExtent(i)) }; dz.prototype.getExtent = function () { return this._extent.slice() }; dz.prototype.setExtent = function (k, e) { var i = this._extent; if (!isNaN(k)) { i[0] = k } if (!isNaN(e)) { i[1] = e } }; dz.prototype.isBlank = function () { return this._isBlank }, dz.prototype.setBlank = function (e) { this._isBlank = e }; dz.prototype.getLabel = null; AG(dz); yk(dz, { registerWhenExtend: true }); function lP(e) { this.categories = e.categories || []; this._needCollect = e.needCollect; this._deduplication = e.deduplication; this._map } lP.createByAxisModel = function (i) { var k = i.option; var m = k.data; var e = m && Ef(m, cP); return new lP({ categories: e, needCollect: !e, deduplication: k.dedplication !== false }) }; var cf = lP.prototype; cf.getOrdinal = function (e) { return qr(this).get(e) }; cf.parseAndCollect = function (m) { var e; var k = this._needCollect; if (typeof m !== "string" && !k) { return m } if (k && !this._deduplication) { e = this.categories.length; this.categories[e] = m; return e } var i = qr(this); e = i.get(m); if (e == null) { if (k) { e = this.categories.length; this.categories[e] = m; i.set(m, e) } else { e = NaN } } return e }; function qr(e) { return e._map || (e._map = CJ(e.categories)) } function cP(e) { if (tJ(e) && e.value != null) { return e.value } else { return e + "" } } var uL = dz.prototype; var E8 = dz.extend({
    type: "ordinal", init: function (e, i) { if (!e || GG(e)) { e = new lP({ categories: e }) } this._ordinalMeta = e; this._extent = i || [0, e.categories.length - 1] }, parse: function (e) { return typeof e === "string" ? this._ordinalMeta.getOrdinal(e) : Math.round(e) }, contain: function (e) { e = this.parse(e); return uL.contain.call(this, e) && this._ordinalMeta.categories[e] != null }, normalize: function (e) { return uL.normalize.call(this, this.parse(e)) }, scale: function (e) { return Math.round(uL.scale.call(this, e)) }, getTicks: function () { var i = []; var e = this._extent; var k = e[0]; while (k <= e[1]) { i.push(k); k++ } return i }, getLabel: function (e) { if (!this.isBlank()) { return this._ordinalMeta.categories[e] } }, count: function () { return this._extent[1] - this._extent[0] + 1 }, unionExtentFromData: function (e, i) {
      this.unionExtent(e.getApproximateExtent(i))
    }, getOrdinalMeta: function () { return this._ordinalMeta }, niceTicks: V, niceExtent: V
  }); E8.create = function () { return new E8() }; var ur = FM; function Dh(v1, e, v2, k) { var v3 = {}; var Z = v1[1] - v1[0]; var i = v3.interval = Y(Z / e, true); if (v2 != null && i < v2) { i = v3.interval = v2 } if (k != null && i > k) { i = v3.interval = k } var v = v3.intervalPrecision = ej(i); var m = v3.niceTickExtent = [ur(Math.ceil(v1[0] / i) * i, v), ur(Math.floor(v1[1] / i) * i, v)]; Eu(m, v1); return v3 } function ej(e) { return t4(e) + 2 } function gZ(i, e, k) { i[e] = Math.max(Math.min(i[e], k[1]), k[0]) } function Eu(e, i) { !isFinite(e[0]) && (e[0] = i[0]); !isFinite(e[1]) && (e[1] = i[1]); gZ(e, 0, i); gZ(e, 1, i); if (e[0] > e[1]) { e[0] = e[1] } } function E2(i, v, e, v1) { var Z = []; if (!i) { return Z } var m = 10000; if (v[0] < e[0]) { Z.push(v[0]) } var k = e[0]; while (k <= e[1]) { Z.push(k); k = ur(k + i, v1); if (k === Z[Z.length - 1]) { break } if (Z.length > m) { return [] } } if (v[1] > (Z.length ? Z[Z.length - 1] : e[1])) { Z.push(v[1]) } return Z } var F8 = FM; var Cz = dz.extend({ type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function (k, e) { var i = this._extent; if (!isNaN(k)) { i[0] = parseFloat(k) } if (!isNaN(e)) { i[1] = parseFloat(e) } }, unionExtent: function (e) { var i = this._extent; e[0] < i[0] && (i[0] = e[0]); e[1] > i[1] && (i[1] = e[1]); Cz.prototype.setExtent.call(this, i[0], i[1]) }, getInterval: function () { return this._interval }, setInterval: function (e) { this._interval = e; this._niceExtent = this._extent.slice(); this._intervalPrecision = ej(e) }, getTicks: function () { return E2(this._interval, this._extent, this._niceExtent, this._intervalPrecision) }, getLabel: function (k, i) { if (k == null) { return "" } var e = i && i.precision; if (e == null) { e = t4(k) || 0 } else { if (e === "auto") { e = this._intervalPrecision } } k = F8(k, e, true); return j7(k) }, niceTicks: function (Z, k, i) { Z = Z || 5; var v = this._extent; var m = v[1] - v[0]; if (!isFinite(m)) { return } if (m < 0) { m = -m; v.reverse() } var e = Dh(v, Z, k, i); this._intervalPrecision = e.intervalPrecision; this._interval = e.interval; this._niceExtent = e.niceTickExtent }, niceExtent: function (k) { var v = this._extent; if (v[0] === v[1]) { if (v[0] !== 0) { var e = v[0]; if (!k.fixMax) { v[1] += e / 2; v[0] -= e / 2 } else { v[0] -= e / 2 } } else { v[1] = 1 } } var m = v[1] - v[0]; if (!isFinite(m)) { v[0] = 0; v[1] = 1 } this.niceTicks(k.splitNumber, k.minInterval, k.maxInterval); var i = this._interval; if (!k.fixMin) { v[0] = F8(Math.floor(v[0] / i) * i) } if (!k.fixMax) { v[1] = F8(Math.ceil(v[1] / i) * i) } } }); Cz.create = function () { return new Cz() }; var hP = "__ec_stack_"; var CK = 0.5; var lL = typeof Float32Array !== "undefined" ? Float32Array : Array; function a0(e) { return e.get("stack") || hP + e.seriesIndex } function kA(e) { return e.dim + e.index } function og(k) { var Z = []; var v = k.axis; var m = "axis0"; if (v.type !== "category") { return } var v1 = v.getBandWidth(); for (var v2 = 0; v2 < k.count || 0; v2++) { Z.push(De({ bandWidth: v1, axisKey: m, stackId: hP + v2 }, k)) } var e = n8(Z); var Ij = []; for (var v2 = 0; v2 < k.count; v2++) { var v3 = e[m][hP + v2]; v3.offsetCenter = v3.offset + v3.width / 2; Ij.push(v3) } return Ij } function n9(i, e) { var k = []; e.eachSeriesByType(i, function (m) { if (qW(m) && !lA(m)) { k.push(m) } }); return k } function xM(e) { var i = []; o9(e, function (v1) { var v3 = v1.getData(); var Ij = v1.coordinateSystem; var m = Ij.getBaseAxis(); var Z = m.getExtent(); var v2 = m.type === "category" ? m.getBandWidth() : (Math.abs(Z[1] - Z[0]) / v3.count()); var Il = zN(v1.get("barWidth"), v2); var k = zN(v1.get("barMaxWidth"), v2); var Ik = v1.get("barGap"); var v = v1.get("barCategoryGap"); i.push({ bandWidth: v2, barWidth: Il, barMaxWidth: k, barGap: Ik, barCategoryGap: v, axisKey: kA(m), stackId: a0(v1) }) }); return n8(i) } function n8(k) { var i = {}; o9(k, function (Il, Ik) { var Z = Il.axisKey; var v3 = Il.bandWidth; var Im = i[Z] || { bandWidth: v3, remainedWidth: v3, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }; var v = Im.stacks; i[Z] = Im; var v2 = Il.stackId; if (!v[v2]) { Im.autoWidthCount++ } v[v2] = v[v2] || { width: 0, maxWidth: 0 }; var In = Il.barWidth; if (In && !v[v2].width) { v[v2].width = In; In = Math.min(Im.remainedWidth, In); Im.remainedWidth -= In } var m = Il.barMaxWidth; m && (v[v2].maxWidth = m); var Ij = Il.barGap; (Ij != null) && (Im.gap = Ij); var v1 = Il.barCategoryGap; (v1 != null) && (Im.categoryGap = v1) }); var e = {}; o9(i, function (Io, Z) { e[Z] = {}; var m = Io.stacks; var v2 = Io.bandWidth; var v = zN(Io.categoryGap, v2); var Il = zN(Io.gap, 1); var v1 = Io.remainedWidth; var Im = Io.autoWidthCount; var Ik = (v1 - v) / (Im + (Im - 1) * Il); Ik = Math.max(Ik, 0); o9(m, function (Iq, Ip) { var Ir = Iq.maxWidth; if (Ir && Ir < Ik) { Ir = Math.min(Ir, v1); if (Iq.width) { Ir = Math.min(Ir, Iq.width) } v1 -= Ir; Iq.width = Ir; Im-- } }); Ik = (v1 - v) / (Im + (Im - 1) * Il); Ik = Math.max(Ik, 0); var Ij = 0; var In; o9(m, function (Iq, Ip) { if (!Iq.width) { Iq.width = Ik } In = Iq; Ij += Iq.width * (1 + Il) }); if (In) { Ij -= In.width * Il } var v3 = -Ij / 2; o9(m, function (Iq, Ip) { e[Z][Ip] = e[Z][Ip] || { offset: v3, width: Iq.width }; v3 += Iq.width * (1 + Il) }) }); return e } function EA(m, k, i) { if (m && k) { var e = m[kA(k)]; if (e != null && i != null) { e = e[a0(i)] } return e } } function bA(i, e) {
    var k = n9(i, e); var m = xM(k); var v = {}; o9(k, function (It) {
      var IE = It.getData(); var Is = It.coordinateSystem; var In = Is.getBaseAxis(); var Ij = a0(It); var Io = m[kA(In)][Ij]; var Ik = Io.offset; var v3 = Io.width; var Ix = Is.getOtherAxis(In); var Z = It.get("barMinHeight") || 0; v[Ij] = v[Ij] || []; IE.setLayout({ offset: Ik, size: v3 }); var v1 = IE.mapDimension(Ix.dim); var Ip = IE.mapDimension(In.dim); var IA = lU(IE, v1); var Iz = Ix.isHorizontal(); var v2 = c7(In, Ix, IA);
      for (var Iq = 0, Iy = IE.count(); Iq < Iy; Iq++) { var Iv = IE.get(v1, Iq); var IB = IE.get(Ip, Iq); if (isNaN(Iv)) { continue } var ID = Iv >= 0 ? "p" : "n"; var IC = v2; if (IA) { if (!v[Ij][IB]) { v[Ij][IB] = { p: v2, n: v2 } } IC = v[Ij][IB][ID] } var Im; var Il; var Iu; var Ir; if (Iz) { var Iw = Is.dataToPoint([Iv, IB]); Im = IC; Il = Iw[1] + Ik; Iu = Iw[0] - v2; Ir = v3; if (Math.abs(Iu) < Z) { Iu = (Iu < 0 ? -1 : 1) * Z } IA && (v[Ij][IB][ID] += Iu) } else { var Iw = Is.dataToPoint([IB, Iv]); Im = Iw[0] + Ik; Il = IC; Iu = v3; Ir = Iw[1] - v2; if (Math.abs(Ir) < Z) { Ir = (Ir <= 0 ? -1 : 1) * Z } IA && (v[Ij][IB][ID] += Ir) } IE.setItemLayout(Iq, { x: Im, y: Il, width: Iu, height: Ir }) }
    }, this)
  } var Hn = { seriesType: "bar", plan: Es(), reset: function (m) { if (!qW(m) || !lA(m)) { return } var v = m.getData(); var Z = m.coordinateSystem; var i = Z.getBaseAxis(); var v3 = Z.getOtherAxis(i); var v1 = v.mapDimension(v3.dim); var Ik = v.mapDimension(i.dim); var k = v3.isHorizontal(); var v2 = k ? 0 : 1; var Ij = EA(xM([m]), i, m).width; if (!(Ij > CK)) { Ij = CK } return { progress: e }; function e(Iq, Io) { var In = new lL(Iq.count * 2); var Im; var Ir = []; var Il = []; var Ip = 0; while ((Im = Iq.next()) != null) { Il[v2] = Io.get(v1, Im); Il[1 - v2] = Io.get(Ik, Im); Ir = Z.dataToPoint(Il, null, Ir); In[Ip++] = Ir[0]; In[Ip++] = Ir[1] } Io.setLayout({ largePoints: In, barWidth: Ij, valueAxisStart: c7(i, v3, false), valueAxisHorizontal: k }) } } }; function qW(e) { return e.coordinateSystem && e.coordinateSystem.type === "cartesian2d" } function lA(e) { return e.pipelineContext && e.pipelineContext.large } function c7(i, k, e) { return (eP(i.getAxesOnZeroOf(), k) >= 0 || e) ? k.toGlobalCoord(k.dataToCoord(0)) : k.getGlobalExtent()[0] } var jT = Cz.prototype; var BX = Math.ceil; var fe = Math.floor; var sI = 1000; var r7 = sI * 60; var jG = r7 * 60; var wZ = jG * 24; var H8 = function (i, e, v, m) { while (v < m) { var k = v + m >>> 1; if (i[k][1] < e) { v = k + 1 } else { m = k } } return v }; var y1 = Cz.extend({ type: "time", getLabel: function (k) { var i = this._stepLvl; var e = new Date(k); return mT(i[0], e, this.getSetting("useUTC")) }, niceExtent: function (i) { var k = this._extent; if (k[0] === k[1]) { k[0] -= wZ; k[1] += wZ } if (k[1] === -Infinity && k[0] === Infinity) { var m = new Date(); k[1] = +new Date(m.getFullYear(), m.getMonth(), m.getDate()); k[0] = k[1] - wZ } this.niceTicks(i.splitNumber, i.minInterval, i.maxInterval); var e = this._interval; if (!i.fixMin) { k[0] = FM(fe(k[0] / e) * e) } if (!i.fixMax) { k[1] = FM(BX(k[1] / e) * e) } }, niceTicks: function (Il, In, m) { Il = Il || 10; var Im = this._extent; var Ij = Im[1] - Im[0]; var v = Ij / Il; if (In != null && v < In) { v = In } if (m != null && v > m) { v = m } var v2 = yi.length; var Ik = H8(yi, v, 0, v2); var e = yi[Math.min(Ik, v2 - 1)]; var k = e[1]; if (e[0] === "year") { var i = Ij / k; var Z = Y(i / Il, true); k *= Z } var v3 = this.getSetting("useUTC") ? 0 : (new Date(+Im[0] || +Im[1])).getTimezoneOffset() * 60 * 1000; var v1 = [Math.round(BX((Im[0] - v3) / k) * k + v3), Math.round(fe((Im[1] - v3) / k) * k + v3)]; Eu(v1, Im); this._stepLvl = e; this._interval = k; this._niceExtent = v1 }, parse: function (e) { return +vS(e) } }); o9(["contain", "normalize"], function (e) { y1.prototype[e] = function (i) { return jT[e].call(this, this.parse(i)) } }); var yi = [["hh:mm:ss", sI], ["hh:mm:ss", sI * 5], ["hh:mm:ss", sI * 10], ["hh:mm:ss", sI * 15], ["hh:mm:ss", sI * 30], ["hh:mm\nMM-dd", r7], ["hh:mm\nMM-dd", r7 * 5], ["hh:mm\nMM-dd", r7 * 10], ["hh:mm\nMM-dd", r7 * 15], ["hh:mm\nMM-dd", r7 * 30], ["hh:mm\nMM-dd", jG], ["hh:mm\nMM-dd", jG * 2], ["hh:mm\nMM-dd", jG * 6], ["hh:mm\nMM-dd", jG * 12], ["MM-dd\nyyyy", wZ], ["MM-dd\nyyyy", wZ * 2], ["MM-dd\nyyyy", wZ * 3], ["MM-dd\nyyyy", wZ * 4], ["MM-dd\nyyyy", wZ * 5], ["MM-dd\nyyyy", wZ * 6], ["week", wZ * 7], ["MM-dd\nyyyy", wZ * 10], ["week", wZ * 14], ["week", wZ * 21], ["month", wZ * 31], ["week", wZ * 42], ["month", wZ * 62], ["week", wZ * 70], ["quarter", wZ * 95], ["month", wZ * 31 * 4], ["month", wZ * 31 * 5], ["half-year", wZ * 380 / 2], ["month", wZ * 31 * 8], ["month", wZ * 31 * 10], ["year", wZ * 380]]; y1.create = function (e) { return new y1({ useUTC: e.ecModel.get("useUTC") }) }; var Fl = dz.prototype; var jJ = Cz.prototype; var k0 = t4; var fm = FM; var v0 = Math.floor; var oR = Math.ceil; var c6 = Math.pow; var F1 = Math.log; var gA = dz.extend({
    type: "log", base: 10, $constructor: function () { dz.apply(this, arguments); this._originalScale = new Cz() }, getTicks: function () { var i = this._originalScale; var k = this._extent; var e = i.getExtent(); return Ef(jJ.getTicks.call(this), function (v) { var m = FM(c6(this.base, v)); m = (v === k[0] && i.__fixMin) ? A5(m, e[0]) : m; m = (v === k[1] && i.__fixMax) ? A5(m, e[1]) : m; return m }, this) }, getLabel: jJ.getLabel, scale: function (e) { e = Fl.scale.call(this, e); return c6(this.base, e) }, setExtent: function (k, e) { var i = this.base; k = F1(k) / F1(i); e = F1(e) / F1(i); jJ.setExtent.call(this, k, e) }, getExtent: function () { var m = this.base; var k = Fl.getExtent.call(this); k[0] = c6(m, k[0]); k[1] = c6(m, k[1]); var i = this._originalScale; var e = i.getExtent(); i.__fixMin && (k[0] = A5(k[0], e[0])); i.__fixMax && (k[1] = A5(k[1], e[1])); return k }, unionExtent: function (e) { this._originalScale.unionExtent(e); var i = this.base; e[0] = F1(e[0]) / F1(i); e[1] = F1(e[1]) / F1(i); Fl.unionExtent.call(this, e) }, unionExtentFromData: function (e, i) { this.unionExtent(e.getApproximateExtent(i)) }, niceTicks: function (Z) { Z = Z || 10; var m = this._extent; var k = m[1] - m[0]; if (k === Infinity || k <= 0) { return } var e = rY(k); var v = Z / k * e; if (v <= 0.5) { e *= 10 } while (!isNaN(e) && Math.abs(e) < 1 && Math.abs(e) > 0) { e *= 10 } var i = [FM(oR(m[0] / e) * e), FM(v0(m[1] / e) * e)]; this._interval = e; this._niceExtent = i }, niceExtent: function (i) {
      jJ.niceExtent.call(this, i); var e = this._originalScale; e.__fixMin = i.fixMin;
      e.__fixMax = i.fixMax
    }
  }); o9(["contain", "normalize"], function (e) { gA.prototype[e] = function (i) { i = F1(i) / F1(this.base); return Fl[e].call(this, i) } }); gA.create = function () { return new gA() }; function A5(i, e) { return fm(i, k0(e)) } function FD(Z, v3) { var e = Z.type; var v2 = v3.getMin(); var Io = v3.getMax(); var v1 = v2 != null; var In = Io != null; var Ij = Z.getExtent(); var Im; var v; var Ip; if (e === "ordinal") { Im = v3.getCategories().length } else { v = v3.get("boundaryGap"); if (!GG(v)) { v = [v || 0, v || 0] } if (typeof v[0] === "boolean") { if (ok) { console.warn("Boolean type for boundaryGap is only " + "allowed for ordinal axis. Please use string in " + 'percentage instead, e.g., "20%". Currently, ' + "boundaryGap is set to be 0.") } v = [0, 0] } v[0] = zN(v[0], 1); v[1] = zN(v[1], 1); Ip = (Ij[1] - Ij[0]) || Math.abs(Ij[0]) } if (v2 == null) { v2 = e === "ordinal" ? (Im ? 0 : NaN) : Ij[0] - v[0] * Ip } if (Io == null) { Io = e === "ordinal" ? (Im ? Im - 1 : NaN) : Ij[1] + v[1] * Ip } if (v2 === "dataMin") { v2 = Ij[0] } else { if (typeof v2 === "function") { v2 = v2({ min: Ij[0], max: Ij[1] }) } } if (Io === "dataMax") { Io = Ij[1] } else { if (typeof Io === "function") { Io = Io({ min: Ij[0], max: Ij[1] }) } } (v2 == null || !isFinite(v2)) && (v2 = NaN); (Io == null || !isFinite(Io)) && (Io = NaN); Z.setBlank(lu(v2) || lu(Io) || (e === "ordinal" && !Z.getOrdinalMeta().categories.length)); if (v3.getNeedCrossZero()) { if (v2 > 0 && Io > 0 && !v1) { v2 = 0 } if (v2 < 0 && Io < 0 && !In) { Io = 0 } } var Il = v3.ecModel; if (Il && (e === "time")) { var m = n9("bar", Il); var i; o9(m, function (Iq) { i |= Iq.getBaseAxis() === v3.axis }); if (i) { var Ik = xM(m); var k = yC(v2, Io, v3, Ik); v2 = k.min; Io = k.max } } return [v2, Io] } function yC(Z, Il, v1, v2) { var v = v1.axis.getExtent(); var v3 = v[1] - v[0]; var Im = EA(v2, v1.axis); if (Im === undefined) { return { min: Z, max: Il } } var e = Infinity; o9(Im, function (In) { e = Math.min(In.offset, e) }); var m = -Infinity; o9(Im, function (In) { m = Math.max(In.offset + In.width, m) }); e = Math.abs(e); m = Math.abs(m); var k = e + m; var Ik = Il - Z; var i = (1 - (e + m) / v3); var Ij = ((Ik / i) - Ik); Il += Ij * (m / k); Z -= Ij * (e / k); return { min: Z, max: Il } } function nL(v1, m) { var Z = FD(v1, m); var v = m.getMin() != null; var i = m.getMax() != null; var v2 = m.get("splitNumber"); if (v1.type === "log") { v1.base = m.get("logBase") } var e = v1.type; v1.setExtent(Z[0], Z[1]); v1.niceExtent({ splitNumber: v2, fixMin: v, fixMax: i, minInterval: (e === "interval" || e === "time") ? m.get("minInterval") : null, maxInterval: (e === "interval" || e === "time") ? m.get("maxInterval") : null }); var k = m.get("interval"); if (k != null) { v1.setInterval && v1.setInterval(k) } } function nq(i, e) { e = e || i.get("type"); if (e) { switch (e) { case "category": return new E8(i.getOrdinalMeta ? i.getOrdinalMeta() : i.getCategories(), [Infinity, -Infinity]); case "value": return new Cz(); default: return (dz.getClass(e) || Cz).create(i) } } } function A9(k) { var m = k.scale.getExtent(); var i = m[0]; var e = m[1]; return !((i > 0 && e > 0) || (i < 0 && e < 0)) } function lQ(i) { var e = i.getLabelModel().get("formatter"); var k = i.type === "category" ? i.scale.getExtent()[0] : null; if (typeof e === "string") { e = (function (m) { return function (v) { v = i.scale.getLabel(v); return m.replace("{value}", v != null ? v : "") } })(e); return e } else { if (typeof e === "function") { return function (v, m) { if (k != null) { m = v - k } return e(nV(i, v), m) } } else { return function (m) { return i.scale.getLabel(m) } } } } function nV(e, i) { return e.type === "category" ? e.scale.getLabel(i) : i } function eB(Z) { var Iq = Z.model; var v1 = Z.scale; if (!Iq.get("axisLabel.show") || v1.isBlank()) { return } var Im = Z.type === "category"; var v3; var e; var Ij = v1.getExtent(); if (Im) { e = v1.count() } else { v3 = v1.getTicks(); e = v3.length } var Ip = Z.getLabelModel(); var Il = lQ(Z); var In; var k = 1; if (e > 40) { k = Math.ceil(e / 40) } for (var Ik = 0; Ik < e; Ik += k) { var v2 = v3 ? v3[Ik] : Ij[0] + Ik; var Io = Il(v2); var v = Ip.getTextRect(Io); var m = zc(v, Ip.get("rotate") || 0); In ? In.union(m) : (In = m) } return In } function zc(v1, k) { var e = k * Math.PI / 180; var m = v1.plain(); var v3 = m.width; var v = m.height; var v2 = v3 * Math.cos(e) + v * Math.sin(e); var i = v3 * Math.sin(e) + v * Math.cos(e); var Z = new CH(m.x, m.y, v2, i); return Z } var nB = { getMin: function (e) { var k = this.option; var i = (!e && k.rangeStart != null) ? k.rangeStart : k.min; if (this.axis && i != null && i !== "dataMin" && typeof i !== "function" && !lu(i)) { i = this.axis.scale.parse(i) } return i }, getMax: function (i) { var k = this.option; var e = (!i && k.rangeEnd != null) ? k.rangeEnd : k.max; if (this.axis && e != null && e !== "dataMax" && typeof e !== "function" && !lu(e)) { e = this.axis.scale.parse(e) } return e }, getNeedCrossZero: function () { var e = this.option; return (e.rangeStart != null || e.rangeEnd != null) ? false : !e.scale }, getCoordSysModel: V, setRange: function (i, e) { this.option.rangeStart = i; this.option.rangeEnd = e }, resetRange: function () { this.option.rangeStart = this.option.rangeEnd = null } }; var r9 = Hw({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (v, k) { var i = k.cx; var Z = k.cy; var m = k.width / 2; var e = k.height / 2; v.moveTo(i, Z - e); v.lineTo(i + m, Z + e); v.lineTo(i - m, Z + e); v.closePath() } }); var jY = Hw({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (v, k) { var i = k.cx; var Z = k.cy; var m = k.width / 2; var e = k.height / 2; v.moveTo(i, Z - e); v.lineTo(i + m, Z); v.lineTo(i, Z + e); v.lineTo(i - m, Z); v.closePath() } }); var DZ = Hw({
    type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (Io, Z) {
      var Ik = Z.x; var v3 = Z.y; var Il = Z.width / 5 * 3; var v = Math.max(Il, Z.height); var e = Il / 2; var Im = e * e / (v - e); var k = v3 - v + e + Im;
      var i = Math.asin(Im / e); var In = Math.cos(i) * e; var v2 = Math.sin(i); var v1 = Math.cos(i); var Ij = e * 0.6; var m = e * 0.7; Io.moveTo(Ik - In, k + Im); Io.arc(Ik, k, e, Math.PI - i, Math.PI * 2 + i); Io.bezierCurveTo(Ik + In - v2 * Ij, k + Im + v1 * Ij, Ik, v3 - m, Ik, v3); Io.bezierCurveTo(Ik, v3 - m, Ik - In + v2 * Ij, k + Im + v1 * Ij, Ik - In, k + Im); Io.closePath()
    }
  }); var iE = Hw({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (k, v) { var i = v.height; var Z = v.width; var e = v.x; var v1 = v.y; var m = Z / 3 * 2; k.moveTo(e, v1); k.lineTo(e + m, v1 + i); k.lineTo(e, v1 + i / 4 * 3); k.lineTo(e - m, v1 + i); k.lineTo(e, v1); k.closePath() } }); var El = { line: zB, rect: EH, roundRect: EH, square: EH, circle: GI, diamond: jY, pin: DZ, arrow: iE, triangle: r9 }; var wy = { line: function (e, v, i, m, k) { k.x1 = e; k.y1 = v + m / 2; k.x2 = e + i; k.y2 = v + m / 2 }, rect: function (e, v, i, m, k) { k.x = e; k.y = v; k.width = i; k.height = m }, roundRect: function (e, v, i, m, k) { k.x = e; k.y = v; k.width = i; k.height = m; k.r = Math.min(i, m) / 4 }, square: function (e, Z, i, v, k) { var m = Math.min(i, v); k.x = e; k.y = Z; k.width = m; k.height = m }, circle: function (e, v, i, m, k) { k.cx = e + i / 2; k.cy = v + m / 2; k.r = Math.min(i, m) / 2 }, diamond: function (e, v, i, m, k) { k.cx = e + i / 2; k.cy = v + m / 2; k.width = i; k.height = m }, pin: function (e, v, i, m, k) { k.x = e + i / 2; k.y = v + m / 2; k.width = i; k.height = m }, arrow: function (e, v, i, m, k) { k.x = e + i / 2; k.y = v + m / 2; k.width = i; k.height = m }, triangle: function (e, v, i, m, k) { k.cx = e + i / 2; k.cy = v + m / 2; k.width = i; k.height = m } }; var qC = {}; o9(El, function (i, e) { qC[e] = new i() }); var lX = Hw({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function () { var i = this.style; var e = this.shape; if (e.symbolType === "pin" && i.textPosition === "inside") { i.textPosition = ["50%", "40%"]; i.textAlign = "center"; i.textVerticalAlign = "middle" } }, buildPath: function (e, i, k) { var m = i.symbolType; var v = qC[m]; if (i.symbolType !== "none") { if (!v) { m = "rect"; v = qC[m] } wy[m](i.x, i.y, i.width, i.height, v.shape); v.buildPath(e, v.shape, k) } } }); function aX(i, m) { if (this.type !== "image") { var k = this.style; var e = this.shape; if (e && e.symbolType === "line") { k.stroke = i } else { if (this.__isEmptyBrush) { k.stroke = i; k.fill = m || "#fff" } else { k.fill && (k.fill = i); k.stroke && (k.stroke = i) } } this.dirty(false) } } function t9(v3, v1, Z, v2, m, i, v) { var k = v3.indexOf("empty") === 0; if (k) { v3 = v3.substr(5, 1).toLowerCase() + v3.substr(6) } var e; if (v3.indexOf("image://") === 0) { e = Gt(v3.slice(8), new CH(v1, Z, v2, m), v ? "center" : "cover") } else { if (v3.indexOf("path://") === 0) { e = Bd(v3.slice(7), {}, new CH(v1, Z, v2, m), v ? "center" : "cover") } else { e = new lX({ shape: { symbolType: v3, x: v1, y: Z, width: v2, height: m } }) } } e.__isEmptyBrush = k; e.setColor = aX; e.setColor(i); return e } function Fk(e) { return a(e.getSource(), e) } var mF = { isDimensionStacked: lU, enableDataStack: j1, getStackedDimension: jB }; function AS(k, i) { var e = i; if (!fv.isInstance(i)) { e = new fv(i); Gq(e, nB) } var m = nq(e); m.setExtent(k[0], k[1]); nL(m, e); return m } function qv(e) { Gq(e, nB) } var B9 = (Object.freeze || Object)({ createList: Fk, getLayoutRect: kV, dataStack: mF, createScale: AS, mixinAxisModelCommonMethods: qv, completeDimensions: HD, createDimensions: yw, createSymbol: t9 }); var ll = 1e-8; function Dq(i, e) { return Math.abs(i - e) < ll } function EN(v, e, v3) { var k = 0; var v1 = v[0]; if (!v1) { return false } for (var m = 1; m < v.length; m++) { var Z = v[m]; k += mq(v1[0], v1[1], Z[0], Z[1], e, v3); v1 = Z } var v2 = v[0]; if (!Dq(v1[0], v2[0]) || !Dq(v1[1], v2[1])) { k += mq(v1[0], v1[1], v2[0], v2[1], e, v3) } return k !== 0 } function vT(e, i, m) { this.name = e; this.geometries = i; if (!m) { var k = this.getBoundingRect(); m = [k.x + k.width / 2, k.y + k.height / 2] } else { m = [m[0], m[1]] } this.center = m } vT.prototype = { constructor: vT, properties: null, getBoundingRect: function () { var v = this._rect; if (v) { return v } var v2 = Number.MAX_VALUE; var v1 = [v2, v2]; var v3 = [-v2, -v2]; var Ij = []; var Z = []; var e = this.geometries; for (var m = 0; m < e.length; m++) { if (e[m].type !== "polygon") { continue } var k = e[m].exterior; oI(k, Ij, Z); Bu(v1, v1, Ij); D5(v3, v3, Z) } if (m === 0) { v1[0] = v1[1] = v3[0] = v3[1] = 0 } return (this._rect = new CH(v1[0], v1[1], v3[0] - v1[0], v3[1] - v1[1])) }, contain: function (Ij) { var v1 = this.getBoundingRect(); var Z = this.geometries; if (!v1.contain(Ij[0], Ij[1])) { return false } loopGeo: for (var v = 0, m = Z.length; v < m; v++) { if (Z[v].type !== "polygon") { continue } var v2 = Z[v].exterior; var v3 = Z[v].interiors; if (EN(v2, Ij[0], Ij[1])) { for (var e = 0; e < (v3 ? v3.length : 0); e++) { if (EN(v3[e])) { continue loopGeo } } return true } } return false }, transformTo: function (Im, Ik, m, Io) { var Il = this.getBoundingRect(); var e = Il.width / Il.height; if (!m) { m = e * Io } else { if (!Io) { Io = m / e } } var Ij = new CH(Im, Ik, m, Io); var Z = Il.calculateTransform(Ij); var v = this.geometries; for (var v2 = 0; v2 < v.length; v2++) { if (v[v2].type !== "polygon") { continue } var v1 = v[v2].exterior; var In = v[v2].interiors; for (var k = 0; k < v1.length; k++) { aY(v1[k], v1[k], Z) } for (var v3 = 0; v3 < (In ? In.length : 0); v3++) { for (var k = 0; k < In[v3].length; k++) { aY(In[v3][k], In[v3][k], Z) } } } Il = this._rect; Il.copy(Ij); this.center = [Il.x + Il.width / 2, Il.y + Il.height / 2] }, cloneShallow: function (e) { e == null && (e = this.name); var i = new vT(e, this.geometries, this.center); i._rect = this._rect; i.transformTo = null; return i } }; function dO(Ik) {
    if (!Ik.UTF8Encoding) { return Ik } var v3 = Ik.UTF8Scale; if (v3 == null) { v3 = 1024 } var e = Ik.features; for (var k = 0; k < e.length; k++) {
      var Il = e[k]; var v = Il.geometry; var v2 = v.coordinates; var Z = v.encodeOffsets; for (var m = 0; m < v2.length; m++) {
        var Ij = v2[m];
        if (v.type === "Polygon") { v2[m] = CE(Ij, Z[m], v3) } else { if (v.type === "MultiPolygon") { for (var i = 0; i < Ij.length; i++) { var v1 = Ij[i]; Ij[i] = CE(v1, Z[m][i], v3) } } }
      }
    } Ik.UTF8Encoding = false; return Ik
  } function CE(v3, Z, v2) { var Ij = []; var m = Z[0]; var k = Z[1]; for (var e = 0; e < v3.length; e += 2) { var v1 = v3.charCodeAt(e) - 64; var v = v3.charCodeAt(e + 1) - 64; v1 = (v1 >> 1) ^ (-(v1 & 1)); v = (v >> 1) ^ (-(v & 1)); v1 += m; v += k; m = v1; k = v; Ij.push([v1 / v2, v / v2]) } return Ij } var bK = function (e) { dO(e); return Ef(q4(e.features, function (i) { return i.geometry && i.properties && i.geometry.coordinates.length > 0 }), function (i) { var k = i.properties; var Z = i.geometry; var v1 = Z.coordinates; var m = []; if (Z.type === "Polygon") { m.push({ type: "polygon", exterior: v1[0], interiors: v1.slice(1) }) } if (Z.type === "MultiPolygon") { o9(v1, function (v2) { if (v2[0]) { m.push({ type: "polygon", exterior: v2[0], interiors: v2.slice(1) }) } }) } var v = new vT(k.name, m, k.cp); v.properties = k; return v }) }; var hM = fK(); function x9(e) { return e.type === "category" ? GA(e) : xv(e) } function mx(e, i) { return e.type === "category" ? EF(e, i) : { ticks: e.scale.getTicks() } } function GA(i) { var k = i.getLabelModel(); var e = ks(i, k); return (!k.get("show") || i.scale.isBlank()) ? { labels: [], labelCategoryInterval: e.labelCategoryInterval } : e } function ks(k, Z) { var m = l7(k, "labels"); var i = pT(Z); var e = pD(m, i); if (e) { return e } var v1; var v; if (E5(i)) { v1 = pq(k, i) } else { v = i === "auto" ? eE(k) : i; v1 = qG(k, v) } return yx(m, i, { labels: v1, labelCategoryInterval: v }) } function EF(m, v1) { var Z = l7(m, "ticks"); var v2 = pT(v1); var i = pD(Z, v2); if (i) { return i } var v; var e; if (!v1.get("show") || m.scale.isBlank()) { v = [] } if (E5(v2)) { v = pq(m, v2, true) } else { if (v2 === "auto") { var k = ks(m, m.getLabelModel()); e = k.labelCategoryInterval; v = Ef(k.labels, function (v3) { return v3.tickValue }) } else { e = v2; v = qG(m, e, true) } } return yx(Z, v2, { ticks: v, tickCategoryInterval: e }) } function xv(i) { var k = i.scale.getTicks(); var e = lQ(i); return { labels: Ef(k, function (v, m) { return { formattedLabel: e(v, m), rawLabel: i.scale.getLabel(v), tickValue: v } }) } } function l7(e, i) { return hM(e)[i] || (hM(e)[i] = []) } function pD(e, m) { for (var k = 0; k < e.length; k++) { if (e[k].key === m) { return e[k].value } } } function yx(e, i, k) { e.push({ key: i, value: k }); return k } function eE(i) { var e = hM(i).autoInterval; return e != null ? e : (hM(i).autoInterval = i.calculateCategoryInterval()) } function f5(k) { var It = kt(k); var v1 = lQ(k); var Ip = (It.axisRotate - It.labelRotate) / 180 * Math.PI; var Iv = k.scale; var Iq = Iv.getExtent(); var e = Iv.count(); if (Iq[1] - Iq[0] < 1) { return 0 } var v2 = 1; if (e > 40) { v2 = Math.max(1, Math.floor(e / 40)) } var v3 = Iq[0]; var v = k.dataToCoord(v3 + 1) - k.dataToCoord(v3); var Z = Math.abs(v * Math.cos(Ip)); var In = Math.abs(v * Math.sin(Ip)); var Iu = 0; var m = 0; for (; v3 <= Iq[1]; v3 += v2) { var Io = 0; var Im = 0; var i = Gr(v1(v3), It.font, "center", "top"); Io = i.width * 1.3; Im = i.height * 1.3; Iu = Math.max(Iu, Io, 7); m = Math.max(m, Im, 7) } var Ik = Iu / Z; var Ir = m / In; isNaN(Ik) && (Ik = Infinity); isNaN(Ir) && (Ir = Infinity); var Is = Math.max(0, Math.floor(Math.min(Ik, Ir))); var Il = hM(k.model); var Ij = Il.lastAutoInterval; var Iw = Il.lastTickCount; if (Ij != null && Iw != null && Math.abs(Ij - Is) <= 1 && Math.abs(Iw - e) <= 1 && Ij > Is) { Is = Ij } else { Il.lastTickCount = e; Il.lastAutoInterval = Is } return Is } function kt(e) { var i = e.getLabelModel(); return { axisRotate: e.getRotate ? e.getRotate() : (e.isHorizontal && !e.isHorizontal()) ? 90 : 0, labelRotate: i.get("rotate") || 0, font: i.getFont() } } function qG(k, v3, m) { var v2 = lQ(k); var Il = k.scale; var Ik = Il.getExtent(); var Im = k.getLabelModel(); var In = []; var i = Math.max((v3 || 0) + 1, 1); var Z = Ik[0]; var e = Il.count(); if (Z !== 0 && i > 1 && e / i > 2) { Z = Math.round(Math.ceil(Z / i) * i) } var v1 = { min: Im.get("showMinLabel"), max: Im.get("showMaxLabel") }; if (v1.min && Z !== Ik[0]) { Ij(Ik[0]) } var v = Z; for (; v <= Ik[1]; v += i) { Ij(v) } if (v1.max && v !== Ik[1]) { Ij(Ik[1]) } function Ij(Io) { In.push(m ? Io : { formattedLabel: v2(Io), rawLabel: Il.getLabel(Io), tickValue: Io }) } return In } function pq(v, k, i) { var Z = v.scale; var m = lQ(v); var e = []; o9(Z.getTicks(), function (v1) { var v2 = Z.getLabel(v1); if (k(v1, v2)) { e.push(i ? v1 : { formattedLabel: m(v1), rawLabel: v2, tickValue: v1 }) } }); return e } function pT(i) { var e = i.get("interval"); return e == null ? "auto" : e } var fU = [0, 1]; var BS = function (i, k, e) { this.dim = i; this.scale = k; this._extent = e || [0, 0]; this.inverse = false; this.onBand = false }; BS.prototype = {
    constructor: BS, contain: function (m) { var k = this._extent; var i = Math.min(k[0], k[1]); var e = Math.max(k[0], k[1]); return m >= i && m <= e }, containData: function (e) { return this.contain(this.dataToCoord(e)) }, getExtent: function () { return this._extent.slice() }, getPixelPrecision: function (e) { return ya(e || this.scale.getExtent(), this._extent) }, setExtent: function (k, e) { var i = this._extent; i[0] = k; i[1] = e }, dataToCoord: function (i, m) { var e = this._extent; var k = this.scale; i = k.normalize(i); if (this.onBand && k.type === "ordinal") { e = e.slice(); Dk(e, k.count()) } return EQ(i, fU, e, m) }, coordToData: function (v, m) { var i = this._extent; var k = this.scale; if (this.onBand && k.type === "ordinal") { i = i.slice(); Dk(i, k.count()) } var e = EQ(v, i, fU, m); return this.scale.scale(e) }, pointToData: function (e, i) { }, getTicksCoords: function (k) {
      k = k || {}; var Z = k.tickModel || this.getTickModel(); var e = mx(this, Z); var m = e.ticks; var i = Ef(m, function (v1) { return { coord: this.dataToCoord(v1), tickValue: v1 } }, this); var v = Z.get("alignWithLabel");
      Fh(this, i, e.tickCategoryInterval, v, k.clamp); return i
    }, getViewLabels: function () { return x9(this).labels }, getLabelModel: function () { return this.model.getModel("axisLabel") }, getTickModel: function () { return this.model.getModel("axisTick") }, getBandWidth: function () { var m = this._extent; var k = this.scale.getExtent(); var e = k[1] - k[0] + (this.onBand ? 1 : 0); e === 0 && (e = 1); var i = Math.abs(m[1] - m[0]); return Math.abs(i) / e }, isHorizontal: null, getRotate: null, calculateCategoryInterval: function () { return f5(this) }
  }; function Dk(m, i) { var k = m[1] - m[0]; var e = i; var v = k / e / 2; m[0] += v; m[1] -= v } function Fh(k, Ij, v2, e, v1) { var v3 = Ij.length; if (!k.onBand || e || !v3) { return } var m = k.getExtent(); var Ik; if (v3 === 1) { Ij[0].coord = m[0]; Ik = Ij[1] = { coord: m[0] } } else { var i = (Ij[1].coord - Ij[0].coord); o9(Ij, function (Im) { Im.coord -= i / 2; var Il = Il || 0; if (Il % 2 > 0) { Im.coord -= i / ((Il + 1) * 2) } }); Ik = { coord: Ij[v3 - 1].coord + i }; Ij.push(Ik) } var v = m[0] > m[1]; if (Z(Ij[0].coord, m[0])) { v1 ? (Ij[0].coord = m[0]) : Ij.shift() } if (v1 && Z(m[0], Ij[0].coord)) { Ij.unshift({ coord: m[0] }) } if (Z(m[1], Ik.coord)) { v1 ? (Ik.coord = m[1]) : Ij.pop() } if (v1 && Z(Ik.coord, m[1])) { Ij.push({ coord: m[1] }) } function Z(Im, Il) { return v ? Im > Il : Im < Il } } var ko = bK; var k6 = {}; o9(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function (e) { k6[e] = xh[e] }); var tY = {}; o9(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function (e) { tY[e] = yf[e] }); nU.extend({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function (k, e) { if (ok) { var i = k.coordinateSystem; if (i !== "polar" && i !== "cartesian2d") { throw new Error("Line not support coordinateSystem besides cartesian and polar") } } return a(this.getSource(), this) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, hoverAnimation: true, clipOverflow: true, label: { position: "top" }, lineStyle: { width: 2, type: "solid" }, step: false, smooth: false, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: true, showAllSymbol: "auto", connectNulls: false, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: Infinity } }); function dX(v1, m) { var v = v1.mapDimension("defaultedLabel", true); var e = v.length; if (e === 1) { return i5(v1, m, v[0]) } else { if (e) { var Z = []; for (var k = 0; k < v.length; k++) { var v2 = i5(v1, m, v[k]); Z.push(v2) } return Z.join(" ") } } } function lO(k, e, i) { B8.call(this); this.updateData(k, e, i) } var Dy = lO.prototype; var Fx = lO.getSymbolSize = function (k, e) { var i = k.getItemVisual(e, "symbolSize"); return i instanceof Array ? i.slice() : [+i, +i] }; function nm(e) { return [e[0] / 2, e[1] / 2] } function yG(i, e) { this.parent.drift(i, e) } Dy._createSymbol = function (v1, Z, k, v, i) { this.removeAll(); var m = Z.getItemVisual(k, "color"); var e = t9(v1, -1, -1, 2, 2, m, i); e.attr({ z2: 100, culling: true, scale: nm(v) }); e.drift = yG; this._symbolType = v1; this.add(e) }; Dy.stopSymbolAnimation = function (e) { this.childAt(0).stopAnimation(e) }; Dy.getSymbolPath = function () { return this.childAt(0) }; Dy.getScale = function () { return this.childAt(0).scale }; Dy.highlight = function () { this.childAt(0).trigger("emphasis") }; Dy.downplay = function () { this.childAt(0).trigger("normal") }; Dy.setZ = function (i, k) { var e = this.childAt(0); e.zlevel = i; e.z = k }; Dy.setDraggable = function (i) { var e = this.childAt(0); e.draggable = i; e.cursor = i ? "move" : "pointer" }; Dy.updateData = function (m, Ij, v3) { this.silent = false; var Ik = m.getItemVisual(Ij, "symbol") || "circle"; var k = m.hostModel; var i = Fx(m, Ij); var Z = Ik !== this._symbolType; if (Z) { var v = m.getItemVisual(Ij, "symbolKeepAspect"); this._createSymbol(Ik, m, Ij, i, v) } else { var e = this.childAt(0); e.silent = false; oS(e, { scale: nm(i) }, k, Ij) } this._updateCommon(m, Ij, i, v3); if (Z) { var e = this.childAt(0); var v1 = v3 && v3.fadeIn; var v2 = { scale: e.scale.slice() }; v1 && (v2.style = { opacity: e.style.opacity }); e.scale = [0, 0]; v1 && (e.style.opacity = 0); jC(e, v2, k, Ij) } this._seriesModel = k }; var s8 = ["itemStyle"]; var hG = ["emphasis", "itemStyle"]; var dG = ["label"]; var BR = ["emphasis", "label"]; Dy._updateCommon = function (Iv, Il, It, Ik) {
    var Iu = this.childAt(0); var Im = Iv.hostModel; var Io = Iv.getItemVisual(Il, "color"); if (Iu.type !== "image") { Iu.useStyle({ strokeNoScale: true }) } var v3 = Ik && Ik.itemStyle; var k = Ik && Ik.hoverItemStyle; var Z = Ik && Ik.symbolRotate; var In = Ik && Ik.symbolOffset; var Ij = Ik && Ik.labelModel; var Is = Ik && Ik.hoverLabelModel; var v = Ik && Ik.hoverAnimation; var e = Ik && Ik.cursorStyle; if (!Ik || Iv.hasItemOption) { var Ip = (Ik && Ik.itemModel) ? Ik.itemModel : Iv.getItemModel(Il); v3 = Ip.getModel(s8).getItemStyle(["color"]); k = Ip.getModel(hG).getItemStyle(); Z = Ip.getShallow("symbolRotate"); In = Ip.getShallow("symbolOffset"); Ij = Ip.getModel(dG); Is = Ip.getModel(BR); v = Ip.getShallow("hoverAnimation"); e = Ip.getShallow("cursor") } else { k = b0({}, k) } var Iq = Iu.style; Iu.attr("rotation", (Z || 0) * Math.PI / 180 || 0);
    if (In) { Iu.attr("position", [zN(In[0], It[0]), zN(In[1], It[1])]) } e && Iu.attr("cursor", e); Iu.setColor(Io, Ik && Ik.symbolInnerColor); Iu.setStyle(v3); var m = Iv.getItemVisual(Il, "opacity"); if (m != null) { Iq.opacity = m } var v2 = Iv.getItemVisual(Il, "liftZ"); var i = Iu.__z2Origin; if (v2 != null) { if (i == null) { Iu.__z2Origin = Iu.z2; Iu.z2 += v2 } } else { if (i != null) { Iu.z2 = i; Iu.__z2Origin = null } } var Ir = Ik && Ik.useNameLabel; BD(Iq, k, Ij, Is, { labelFetcher: Im, labelDataIndex: Il, defaultText: v1, isRectText: true, autoColor: Io }); function v1(Iw, Ix) { return Ir ? Iv.getName(Iw) : dX(Iv, Iw) } Iu.off("mouseover").off("mouseout").off("emphasis").off("normal"); Iu.hoverStyle = k; yn(Iu); Iu.__symbolOriginalScale = nm(It); if (v && Im.isAnimationEnabled()) { Iu.on("mouseover", Fd).on("mouseout", k7).on("emphasis", Fd).on("normal", k7) }
  }; function Fd() { if (this.incremental || this.useHoverLayer || rW(this)) { return } var i = this.__symbolOriginalScale; var e = i[1] / i[0]; this.animateTo({ scale: [Math.max(i[0] * 1.1, i[0] + 3), Math.max(i[1] * 1.1, i[1] + 3 * e)] }, 400, "elasticOut") } function k7() { if (this.incremental || this.useHoverLayer || rW(this)) { return } this.animateTo({ scale: this.__symbolOriginalScale }, 400, "elasticOut") } Dy.fadeOut = function (i, k) { var e = this.childAt(0); this.silent = e.silent = true; !(k && k.keepLabel) && (e.style.text = null); oS(e, { style: { opacity: 0 }, scale: [0, 0] }, this._seriesModel, this.dataIndex, i) }; mr(lO, B8); function E9(e) { this.group = new B8(); this._symbolCtor = e || lO } var xQ = E9.prototype; function wD(m, i, e, k) { return i && !isNaN(i[0]) && !isNaN(i[1]) && !(k.isIgnore && k.isIgnore(e)) && !(k.clipShape && !k.clipShape.contain(i[0], i[1])) && m.getItemVisual(e, "symbol") !== "none" } xQ.updateData = function (v, k) { k = E1(k); var Z = this.group; var e = v.hostModel; var v1 = this._data; var m = this._symbolCtor; var i = wV(v); if (!v1) { Z.removeAll() } v.diff(v1).add(function (v3) { var v2 = v.getItemLayout(v3); if (wD(v, v2, v3, k)) { var Ij = new m(v, v3, i); Ij.attr("position", v2); v.setItemGraphicEl(v3, Ij); Z.add(Ij) } }).update(function (Ij, v3) { var Ik = v1.getItemGraphicEl(v3); var v2 = v.getItemLayout(Ij); if (!wD(v, v2, Ij, k)) { Z.remove(Ik); return } if (!Ik) { Ik = new m(v, Ij); Ik.attr("position", v2) } else { Ik.updateData(v, Ij, i); oS(Ik, { position: v2 }, e) } Z.add(Ik); v.setItemGraphicEl(Ij, Ik) }).remove(function (v2) { var v3 = v1.getItemGraphicEl(v2); v3 && v3.fadeOut(function () { Z.remove(v3) }) }).execute(); this._data = v }; xQ.isPersistent = function () { return true }; xQ.updateLayout = function () { var e = this._data; if (e) { e.eachItemGraphicEl(function (m, k) { var i = e.getItemLayout(k); m.attr("position", i) }) } }; xQ.incrementalPrepareUpdate = function (e) { this._seriesScope = wV(e); this._data = null; this.group.removeAll() }; xQ.incrementalUpdate = function (v1, Z, m) { m = E1(m); function k(v2) { if (!v2.isGroup) { v2.incremental = v2.useHoverLayer = true } } for (var i = v1.start; i < v1.end; i++) { var e = Z.getItemLayout(i); if (wD(Z, e, i, m)) { var v = new this._symbolCtor(Z, i, this._seriesScope); v.traverse(k); v.attr("position", e); this.group.add(v); Z.setItemGraphicEl(i, v) } } }; function E1(e) { if (e != null && !tJ(e)) { e = { isIgnore: e } } return e || {} } xQ.remove = function (e) { var k = this.group; var i = this._data; if (i && e) { i.eachItemGraphicEl(function (m) { m.fadeOut(function () { k.remove(m) }) }) } else { k.removeAll() } }; function wV(i) { var e = i.hostModel; return { itemStyle: e.getModel("itemStyle").getItemStyle(["color"]), hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(), symbolRotate: e.get("symbolRotate"), symbolOffset: e.get("symbolOffset"), hoverAnimation: e.get("hoverAnimation"), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label"), cursorStyle: e.get("cursor") } } function xd(v, Z, v1) { var i = v.getBaseAxis(); var Im = v.getOtherAxis(i); var m = lH(Im, v1); var k = i.dim; var v2 = Im.dim; var Ij = Z.mapDimension(v2); var In = Z.mapDimension(k); var e = v2 === "x" || v2 === "radius" ? 1 : 0; var Il = Ef(v.dimensions, function (Io) { return Z.mapDimension(Io) }); var v3; var Ik = Z.getCalculationInfo("stackResultDimension"); if (v3 |= lU(Z, Il[0])) { Il[0] = Ik } if (v3 |= lU(Z, Il[1])) { Il[1] = Ik } return { dataDimsForPoint: Il, valueStart: m, valueAxisDim: v2, baseAxisDim: k, stacked: !!v3, valueDim: Ij, baseDim: In, baseDataOffset: e, stackedOverDimension: Z.getCalculationInfo("stackedOverDimension") } } function lH(m, e) { var k = 0; var i = m.scale.getExtent(); if (e === "start") { k = i[0] } else { if (e === "end") { k = i[1] } else { if (i[0] > 0) { k = i[0] } else { if (i[1] < 0) { k = i[1] } } } } return k } function aj(i, v, v1, e) { var Z = NaN; if (i.stacked) { Z = v1.get(v1.getCalculationInfo("stackedOverDimension"), e) } if (isNaN(Z)) { Z = i.valueStart } var m = i.baseDataOffset; var k = []; k[m] = v1.get(i.baseDim, e); k[1 - m] = Z; return v.dataToPoint(k) } function il(k, i) { var e = []; i.diff(k).add(function (m) { e.push({ cmd: "+", idx: m }) }).update(function (v, m) { e.push({ cmd: "=", idx: m, idx1: v }) }).remove(function (m) { e.push({ cmd: "-", idx: m }) }).execute(); return e } var wn = function (IE, In, Ix, Im, IB, ID, v3, Iu) {
    var Io = il(IE, In); var Ip = []; var v2 = []; var Z = []; var IC = []; var Iw = []; var Is = []; var k = []; var v1 = xd(IB, In, v3); var v = xd(ID, IE, Iu); for (var Iy = 0; Iy < Io.length; Iy++) {
      var Iv = Io[Iy]; var IA = true; switch (Iv.cmd) {
        case "=": var Iz = IE.getItemLayout(Iv.idx); var It = In.getItemLayout(Iv.idx1); if (isNaN(Iz[0]) || isNaN(Iz[1])) { Iz = It.slice() } Ip.push(Iz); v2.push(It); Z.push(Ix[Iv.idx]); IC.push(Im[Iv.idx1]); k.push(In.getRawIndex(Iv.idx1));
          break; case "+": var Iq = Iv.idx; Ip.push(IB.dataToPoint([In.get(v1.dataDimsForPoint[0], Iq), In.get(v1.dataDimsForPoint[1], Iq)])); v2.push(In.getItemLayout(Iq).slice()); Z.push(aj(v1, IB, In, Iq)); IC.push(Im[Iq]); k.push(In.getRawIndex(Iq)); break; case "-": var Iq = Iv.idx; var Il = IE.getRawIndex(Iq); if (Il !== Iq) { Ip.push(IE.getItemLayout(Iq)); v2.push(ID.dataToPoint([IE.get(v.dataDimsForPoint[0], Iq), IE.get(v.dataDimsForPoint[1], Iq)])); Z.push(Ix[Iq]); IC.push(aj(v, ID, IE, Iq)); k.push(Il) } else { IA = false }
      }if (IA) { Iw.push(Iv); Is.push(Is.length) }
    } Is.sort(function (IF, i) { return k[IF] - k[i] }); var Ir = []; var Ik = []; var Ij = []; var e = []; var m = []; for (var Iy = 0; Iy < Is.length; Iy++) { var Iq = Is[Iy]; Ir[Iy] = Ip[Iq]; Ik[Iy] = v2[Iq]; Ij[Iy] = Z[Iq]; e[Iy] = IC[Iq]; m[Iy] = Iw[Iq] } return { current: Ir, next: Ik, stackedOnCurrent: Ij, stackedOnNext: e, status: m }
  }; var gs = Bu; var jb = D5; var vC = A6; var zY = yI; var G2 = []; var D9 = []; var D8 = []; function BQ(e) { return isNaN(e[0]) || isNaN(e[1]) } function vb(Ik, Ij, k, v, v3, Z, v2, m, i, v1, e) { if (v1 === "none" || !v1) { return dD.apply(this, arguments) } else { return ro.apply(this, arguments) } } function ro(In, Iq, m, Is, Il, Im, i, v, v3, Ij, e) { var v1 = 0; var v2 = m; for (var Io = 0; Io < Is; Io++) { var Ik = Iq[v2]; if (v2 >= Il || v2 < 0) { break } if (BQ(Ik)) { if (e) { v2 += Im; continue } break } if (v2 === m) { In[Im > 0 ? "moveTo" : "lineTo"](Ik[0], Ik[1]) } else { if (v3 > 0) { var Z = Iq[v1]; var Ip = Ij === "y" ? 1 : 0; var Ir = (Ik[Ip] - Z[Ip]) * v3; zY(D9, Z); D9[Ip] = Z[Ip] + Ir; zY(D8, Ik); D8[Ip] = Ik[Ip] - Ir; In.bezierCurveTo(D9[0], D9[1], D8[0], D8[1], Ik[0], Ik[1]) } else { In.lineTo(Ik[0], Ik[1]) } } v1 = v2; v2 += Im } return Io } function dD(Ip, Is, v, It, In, Io, m, Z, Ik, Il, i) { var v3 = 0; var Ij = v; for (var Iq = 0; Iq < It; Iq++) { var Im = Is[Ij]; if (Ij >= In || Ij < 0) { break } if (BQ(Im)) { if (i) { Ij += Io; continue } break } if (Ij === v) { Ip[Io > 0 ? "moveTo" : "lineTo"](Im[0], Im[1]); zY(D9, Im) } else { if (Ik > 0) { var Iv = Ij + Io; var e = Is[Iv]; if (i) { while (e && BQ(Is[Iv])) { Iv += Io; e = Is[Iv] } } var Iu = 0.5; var v2 = Is[v3]; var e = Is[Iv]; if (!e || BQ(e)) { zY(D8, Im) } else { if (BQ(e) && !i) { e = Im } BN(G2, e, v2); var Iw; var v1; if (Il === "x" || Il === "y") { var Ir = Il === "x" ? 0 : 1; Iw = Math.abs(Im[Ir] - v2[Ir]); v1 = Math.abs(Im[Ir] - e[Ir]) } else { Iw = DV(Im, v2); v1 = DV(Im, e) } Iu = v1 / (v1 + Iw); vC(D8, Im, G2, -Ik * (1 - Iu)) } gs(D9, D9, Z); jb(D9, D9, m); gs(D8, D8, Z); jb(D8, D8, m); Ip.bezierCurveTo(D9[0], D9[1], D8[0], D8[1], Im[0], Im[1]); vC(D9, Im, G2, Ik * Iu) } else { Ip.lineTo(Im[0], Im[1]) } } v3 = Ij; Ij += Io } return Iq } function kd(Z, m) { var v = [Infinity, Infinity]; var e = [-Infinity, -Infinity]; if (m) { for (var k = 0; k < Z.length; k++) { var v1 = Z[k]; if (v1[0] < v[0]) { v[0] = v1[0] } if (v1[1] < v[1]) { v[1] = v1[1] } if (v1[0] > e[0]) { e[0] = v1[0] } if (v1[1] > e[1]) { e[1] = v1[1] } } } return { min: m ? v : e, max: m ? e : v } } var iK = mm.extend({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: true, smoothMonotone: null, connectNulls: false }, style: { fill: null, stroke: "#000" }, brush: nk(mm.prototype.brush), buildPath: function (k, m) { var v1 = m.points; var Z = 0; var v = v1.length; var e = kd(v1, m.smoothConstraint); if (m.connectNulls) { for (; v > 0; v--) { if (!BQ(v1[v - 1])) { break } } for (; Z < v; Z++) { if (!BQ(v1[Z])) { break } } } while (Z < v) { Z += vb(k, v1, Z, v, v, 1, e.min, e.max, m.smooth, m.smoothMonotone, m.connectNulls) + 1 } } }); var i8 = mm.extend({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: true, smoothMonotone: null, connectNulls: false }, brush: nk(mm.prototype.brush), buildPath: function (Il, v1) { var Ij = v1.points; var Z = v1.stackedOnPoints; var v = 0; var v3 = Ij.length; var v2 = v1.smoothMonotone; var Ik = kd(Ij, v1.smoothConstraint); var e = kd(Z, v1.smoothConstraint); if (v1.connectNulls) { for (; v3 > 0; v3--) { if (!BQ(Ij[v3 - 1])) { break } } for (; v < v3; v++) { if (!BQ(Ij[v])) { break } } } while (v < v3) { var m = vb(Il, Ij, v, v3, v3, 1, Ik.min, Ik.max, v1.smooth, v2, v1.connectNulls); vb(Il, Z, v + m - 1, m, v3, -1, e.min, e.max, v1.stackedOnSmooth, v2, v1.connectNulls); v += m + 1; Il.closePath() } } }); function w8(k, e) { if (k.length !== e.length) { return } for (var m = 0; m < k.length; m++) { var Z = k[m]; var v = e[m]; if (Z[0] !== v[0] || Z[1] !== v[1]) { return } } return true } function zQ(e) { return typeof (e) === "number" ? e : (e ? 0.5 : 0) } function ne(m) { var k = m.getGlobalExtent(); if (m.onBand) { var e = m.getBandWidth() / 2 - 1; var i = k[1] > k[0] ? 1 : -1; k[0] += i * e; k[1] -= i * e } return k } function Ds(m, Z, k) { if (!k.valueDim) { return [] } var v = []; for (var i = 0, e = Z.count(); i < e; i++) { v.push(aj(k, m, Z, i)) } return v } function bk(v, v2, v1, k) { var i = ne(v.getAxis("x")); var v3 = ne(v.getAxis("y")); var Il = v.getBaseAxis().isHorizontal(); var Im = Math.min(i[0], i[1]); var Ik = Math.min(v3[0], v3[1]); var e = Math.max(i[0], i[1]) - Im; var In = Math.max(v3[0], v3[1]) - Ik; if (v1) { Im -= 0.5; e += 0.5; Ik -= 0.5; In += 0.5 } else { var Z = k.get("lineStyle.width") || 2; var m = k.get("clipOverflow") ? Z / 2 : Math.max(e, In); if (Il) { Ik -= m; In += m * 2 } else { Im -= m; e += m * 2 } } var Ij = new EH({ shape: { x: Im, y: Ik, width: e, height: In } }); if (v2) { Ij.shape[Il ? "width" : "height"] = 0; jC(Ij, { shape: { width: e, height: In } }, k) } return Ij } function AA(e, Z, v, i) {
    var Ij = e.getAngleAxis(); var k = e.getRadiusAxis(); var m = k.getExtent().slice(); m[0] > m[1] && m.reverse(); var v3 = Ij.getExtent(); var v2 = Math.PI / 180; if (v) { m[0] -= 0.5; m[1] += 0.5 } var v1 = new tx({ shape: { cx: FM(e.cx, 1), cy: FM(e.cy, 1), r0: FM(m[0], 1), r: FM(m[1], 1), startAngle: -v3[0] * v2, endAngle: -v3[1] * v2, clockwise: Ij.inverse } }); if (Z) { v1.shape.endAngle = -v3[0] * v2; jC(v1, { shape: { endAngle: -v3[1] * v2 } }, i) } return v1
  } function dE(i, k, m, e) { return i.type === "polar" ? AA(i, k, m, e) : bk(i, k, m, e) } function a5(v3, Z, m) { var k = Z.getBaseAxis(); var v2 = k.dim === "x" || k.dim === "radius" ? 0 : 1; var e = []; for (var v1 = 0; v1 < v3.length - 1; v1++) { var Im = v3[v1 + 1]; var Il = v3[v1]; e.push(Il); var v = []; switch (m) { case "end": v[v2] = Im[v2]; v[1 - v2] = Il[1 - v2]; e.push(v); break; case "middle": var Ik = (Il[v2] + Im[v2]) / 2; var Ij = []; v[v2] = Ij[v2] = Ik; v[1 - v2] = Il[1 - v2]; Ij[1 - v2] = Im[1 - v2]; e.push(v); e.push(Ij); break; default: v[v2] = Il[v2]; v[1 - v2] = Im[1 - v2]; e.push(v) } } v3[v1] && e.push(v3[v1]); return e } function cm(Is, v3) { var In = Is.getVisual("visualMeta"); if (!In || !In.length || !Is.count()) { return } if (v3.type !== "cartesian2d") { if (ok) { console.warn("Visual map on line style is only supported on cartesian2d.") } return } var Im; var Ir; for (var Io = In.length - 1; Io >= 0; Io--) { var Ik = In[Io].dimension; var Ij = Is.dimensions[Ik]; var v2 = Is.getDimensionInfo(Ij); Im = v2 && v2.coordDim; if (Im === "x" || Im === "y") { Ir = In[Io]; break } } if (!Ir) { if (ok) { console.warn("Visual map on line style only support x or y dimension.") } return } var Z = v3.getAxis(Im); var v1 = Ef(Ir.stops, function (i) { return { coord: Z.toGlobalCoord(Z.dataToCoord(i.value)), color: i.color } }); var k = v1.length; var Iq = Ir.outerColors.slice(); if (k && v1[0].coord > v1[k - 1].coord) { v1.reverse(); Iq.reverse() } var e = 10; var Il = v1[0].coord - e; var Ip = v1[k - 1].coord + e; var m = Ip - Il; if (m < 0.001) { return "transparent" } o9(v1, function (i) { i.offset = (i.coord - Il) / m }); v1.push({ offset: k ? v1[k - 1].offset : 0.5, color: Iq[1] || "transparent" }); v1.unshift({ offset: k ? v1[0].offset : 0.5, color: Iq[0] || "transparent" }); var v = new uD(0, 0, 0, 0, v1, true); v[Im] = Il; v[Im + "2"] = Ip; return v } function eQ(k, v1, m) { var i = k.get("showAllSymbol"); var e = i === "auto"; if (i && !e) { return } var v2 = m.getAxesByScale("ordinal")[0]; if (!v2) { return } if (e && hA(v2, v1)) { return } var v = v1.mapDimension(v2.dim); var Z = {}; o9(v2.getViewLabels(), function (v3) { Z[v3.tickValue] = 1 }); return function (v3) { return !Z.hasOwnProperty(v1.get(v, v3)) } } function hA(Z, v) { var v1 = Z.getExtent(); var k = Math.abs(v1[1] - v1[0]) / Z.scale.count(); isNaN(k) && (k = 0); var i = v.count(); var m = Math.max(1, Math.round(i / 5)); for (var e = 0; e < i; e += m) { if (lO.getSymbolSize(v, e)[Z.isHorizontal() ? 1 : 0] * 1.5 > k) { return false } } return true } dF.extend({
    type: "line", init: function () { var i = new B8(); var e = new E9(); this.group.add(e.group); this._symbolDraw = e; this._lineGroup = i }, render: function (Is, IB, Ip) { var v2 = Is.coordinateSystem; var v3 = this.group; var IA = Is.getData(); var It = Is.getModel("lineStyle"); var In = Is.getModel("areaStyle"); var Iv = IA.mapArray(IA.getItemLayout); var Ix = v2.type === "polar"; var Ij = this._coordSys; var Iw = this._symbolDraw; var Ir = this._polyline; var Il = this._polygon; var Iu = this._lineGroup; var i = Is.get("animation"); var k = !In.isEmpty(); var Im = In.get("origin"); var m = xd(v2, IA, Im); var Z = Ds(v2, IA, m); var Ik = Is.get("showSymbol"); var Io = Ik && !Ix && eQ(Is, IA, v2); var Iz = this._data; Iz && Iz.eachItemGraphicEl(function (ID, IC) { if (ID.__temp) { v3.remove(ID); Iz.setItemGraphicEl(IC, null) } }); if (!Ik) { Iw.remove() } v3.add(Iu); var v1 = !Ix && Is.get("step"); if (!(Ir && Ij.type === v2.type && v1 === this._step)) { Ik && Iw.updateData(IA, { isIgnore: Io, clipShape: dE(v2, false, true, Is) }); if (v1) { Iv = a5(Iv, v2, v1); Z = a5(Z, v2, v1) } Ir = this._newPolyline(Iv, v2, i); if (k) { Il = this._newPolygon(Iv, Z, v2, i) } Iu.setClipPath(dE(v2, true, false, Is)) } else { if (k && !Il) { Il = this._newPolygon(Iv, Z, v2, i) } else { if (Il && !k) { Iu.remove(Il); Il = this._polygon = null } } Iu.setClipPath(dE(v2, false, false, Is)); Ik && Iw.updateData(IA, { isIgnore: Io, clipShape: dE(v2, false, true, Is) }); IA.eachItemGraphicEl(function (IC) { IC.stopAnimation(true) }); if (!w8(this._stackedOnPoints, Z) || !w8(this._points, Iv)) { if (i) { this._updateAnimation(IA, Z, v2, Ip, v1, Im) } else { if (v1) { Iv = a5(Iv, v2, v1); Z = a5(Z, v2, v1) } Ir.setShape({ points: Iv }); Il && Il.setShape({ points: Iv, stackedOnPoints: Z }) } } } var v = cm(IA, v2) || IA.getVisual("color"); Ir.useStyle(De(It.getLineStyle(), { fill: "none", stroke: v, lineJoin: "bevel" })); var Iq = Is.get("smooth"); Iq = zQ(Is.get("smooth")); Ir.setShape({ smooth: Iq, smoothMonotone: Is.get("smoothMonotone"), connectNulls: Is.get("connectNulls") }); if (Il) { var Iy = IA.getCalculationInfo("stackedOnSeries"); var e = 0; Il.useStyle(De(In.getAreaStyle(), { fill: v, opacity: 0.7, lineJoin: "bevel" })); if (Iy) { e = zQ(Iy.get("smooth")) } Il.setShape({ smooth: Iq, stackedOnSmooth: e, smoothMonotone: Is.get("smoothMonotone"), connectNulls: Is.get("connectNulls") }) } this._data = IA; this._coordSys = v2; this._stackedOnPoints = Z; this._points = Iv; this._step = v1; this._valueOrigin = Im }, dispose: function () { }, highlight: function (i, e, m, v2) { var Z = i.getData(); var k = xe(Z, v2); if (!(k instanceof Array) && k != null && k >= 0) { var v = Z.getItemGraphicEl(k); if (!v) { var v1 = Z.getItemLayout(k); if (!v1) { return } v = new lO(Z, k); v.position = v1; v.setZ(i.get("zlevel"), i.get("z")); v.ignore = isNaN(v1[0]) || isNaN(v1[1]); v.__temp = true; Z.setItemGraphicEl(k, v); v.stopSymbolAnimation(true); this.group.add(v) } v.highlight() } else { dF.prototype.highlight.call(this, i, e, m, v2) } }, downplay: function (i, e, m, v1) {
      var Z = i.getData(); var k = xe(Z, v1); if (k != null && k >= 0) { var v = Z.getItemGraphicEl(k); if (v) { if (v.__temp) { Z.setItemGraphicEl(k, null); this.group.remove(v) } else { v.downplay() } } } else {
        dF.prototype.downplay.call(this, i, e, m, v1)
      }
    }, _newPolyline: function (i) { var e = this._polyline; if (e) { this._lineGroup.remove(e) } e = new iK({ shape: { points: i }, silent: true, z2: 10 }); this._lineGroup.add(e); this._polyline = e; return e }, _newPolygon: function (k, e) { var i = this._polygon; if (i) { this._lineGroup.remove(i) } i = new i8({ shape: { points: k, stackedOnPoints: e }, silent: true }); this._lineGroup.add(i); this._polygon = i; return i }, _updateAnimation: function (It, k, v, Il, Z, Ij) { var Im = this._polyline; var v2 = this._polygon; var Io = It.hostModel; var Ik = wn(this._data, It, this._stackedOnPoints, k, this._coordSys, v, this._valueOrigin, Ij); var Iq = Ik.current; var Ip = Ik.stackedOnCurrent; var In = Ik.next; var m = Ik.stackedOnNext; if (Z) { Iq = a5(Ik.current, v, Z); Ip = a5(Ik.stackedOnCurrent, v, Z); In = a5(Ik.next, v, Z); m = a5(Ik.stackedOnNext, v, Z) } Im.shape.__points = Ik.current; Im.shape.points = Iq; oS(Im, { shape: { points: In } }, Io); if (v2) { v2.setShape({ points: Iq, stackedOnPoints: Ip }); oS(v2, { shape: { points: In, stackedOnPoints: m } }, Io) } var v3 = []; var v1 = Ik.status; for (var Is = 0; Is < v1.length; Is++) { var Ir = v1[Is].cmd; if (Ir === "=") { var e = It.getItemGraphicEl(v1[Is].idx1); if (e) { v3.push({ el: e, ptIdx: Is }) } } } if (Im.animators && Im.animators.length) { Im.animators[0].during(function () { for (var Iu = 0; Iu < v3.length; Iu++) { var Iv = v3[Iu].el; Iv.attr("position", Im.shape.__points[v3[Iu].ptIdx]) } }) } }, remove: function (e) { var i = this.group; var k = this._data; this._lineGroup.removeAll(); this._symbolDraw.remove(true); k && k.eachItemGraphicEl(function (v, m) { if (v.__temp) { i.remove(v); k.setItemGraphicEl(m, null) } }); this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null }
  }); var ml = function (e, i, k) { return { seriesType: e, performRawSeries: true, reset: function (Z, v3, Ij) { var v1 = Z.getData(); var Il = Z.get("symbol") || i; var v = Z.get("symbolSize"); var v2 = Z.get("symbolKeepAspect"); v1.setVisual({ legendSymbol: k || Il, symbol: Il, symbolSize: v, symbolKeepAspect: v2 }); if (v3.isSeriesFiltered(Z)) { return } var m = typeof v === "function"; function Ik(Is, Im) { if (typeof v === "function") { var Ir = Z.getRawValue(Im); var It = Z.getDataParams(Im); Is.setItemVisual(Im, "symbolSize", v(Ir, It)) } if (Is.hasItemOption) { var Ip = Is.getItemModel(Im); var Iq = Ip.getShallow("symbol", true); var Io = Ip.getShallow("symbolSize", true); var In = Ip.getShallow("symbolKeepAspect", true); if (Iq != null) { Is.setItemVisual(Im, "symbol", Iq) } if (Io != null) { Is.setItemVisual(Im, "symbolSize", Io) } if (In != null) { Is.setItemVisual(Im, "symbolKeepAspect", In) } } } return { dataEach: (v1.hasItemOption || m) ? Ik : null } } } }; var qA = function (e) { return { seriesType: e, plan: Es(), reset: function (m) { var Z = m.getData(); var v = m.coordinateSystem; var Ij = m.pipelineContext; var k = Ij.large; if (!v) { return } var v3 = Ef(v.dimensions, function (Ik) { return Z.mapDimension(Ik) }).slice(0, 2); var v2 = v3.length; var v1 = Z.getCalculationInfo("stackResultDimension"); if (lU(Z, v3[0])) { v3[0] = v1 } if (lU(Z, v3[1])) { v3[1] = v1 } function i(Im, Io) { var Ik = Im.end - Im.start; var Iu = k && new Float32Array(Ik * v2); for (var Ip = Im.start, In = 0, Iq = [], Il = []; Ip < Im.end; Ip++) { var It; if (v2 === 1) { var Is = Io.get(v3[0], Ip); It = !isNaN(Is) && v.dataToPoint(Is, null, Il) } else { var Is = Iq[0] = Io.get(v3[0], Ip); var Ir = Iq[1] = Io.get(v3[1], Ip); It = !isNaN(Is) && !isNaN(Ir) && v.dataToPoint(Iq, null, Il) } if (k) { Iu[In++] = It ? It[0] : NaN; Iu[In++] = It ? It[1] : NaN } else { Io.setItemLayout(Ip, (It && It.slice()) || [NaN, NaN]) } } k && Io.setLayout("symbolPoints", Iu) } return v2 && { progress: i } } } }; var pO = { average: function (v) { var k = 0; var m = 0; for (var e = 0; e < v.length; e++) { if (!isNaN(v[e])) { k += v[e]; m++ } } return m === 0 ? NaN : k / m }, sum: function (m) { var k = 0; for (var e = 0; e < m.length; e++) { k += m[e] || 0 } return k }, max: function (m) { var e = -Infinity; for (var k = 0; k < m.length; k++) { m[k] > e && (e = m[k]) } return isFinite(e) ? e : NaN }, min: function (m) { var k = Infinity; for (var e = 0; e < m.length; e++) { m[e] < k && (k = m[e]) } return isFinite(k) ? k : NaN }, nearest: function (e) { return e[0] } }; var Ed = function (i, e) { return Math.round(i.length / 2) }; var xs = function (e) { return { seriesType: e, modifyOutputEnd: true, reset: function (k, v1, v2) { var v = k.getData(); var Z = k.get("sampling"); var m = k.coordinateSystem; if (m.type === "cartesian2d" && Z) { var i = m.getBaseAxis(); var Ik = m.getOtherAxis(i); var Il = i.getExtent(); var Im = Il[1] - Il[0]; var v3 = Math.round(v.count() / Im); if (v3 > 1) { var Ij; if (typeof Z === "string") { Ij = pO[Z] } else { if (typeof Z === "function") { Ij = Z } } if (Ij) { k.setData(v.downSample(v.mapDimension(Ik.dim), 1 / v3, Ij, Ed)) } } } } } }; function Ew(e) { return this._axes[e] } var bS = function (e) { this._axes = {}; this._dimList = []; this.name = e || "" }; bS.prototype = { constructor: bS, type: "cartesian", getAxis: function (e) { return this._axes[e] }, getAxes: function () { return Ef(this._dimList, Ew, this) }, getAxesByScale: function (e) { e = e.toLowerCase(); return q4(this.getAxes(), function (i) { return i.scale.type === e }) }, addAxis: function (e) { var i = e.dim; this._axes[i] = e; this._dimList.push(i) }, dataToCoord: function (e) { return this._dataCoordConvert(e, "dataToCoord") }, coordToData: function (e) { return this._dataCoordConvert(e, "coordToData") }, _dataCoordConvert: function (m, v2) { var e = this._dimList; var k = m instanceof Array ? [] : {}; for (var v = 0; v < e.length; v++) { var v1 = e[v]; var Z = this._axes[v1]; k[v1] = Z[v2](m[v1]) } return k } }; function Bi(e) { bS.call(this, e) } Bi.prototype = {
    constructor: Bi, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
    }, containPoint: function (e) { var k = this.getAxis("x"); var i = this.getAxis("y"); return k.contain(k.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1])) }, containData: function (e) { return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]) }, dataToPoint: function (v, e, k) { var m = this.getAxis("x"); var i = this.getAxis("y"); k = k || []; k[0] = m.toGlobalCoord(m.dataToCoord(v[0])); k[1] = i.toGlobalCoord(i.dataToCoord(v[1])); return k }, clampData: function (Z, k) { var v = this.getAxis("x").scale; var m = this.getAxis("y").scale; var v2 = v.getExtent(); var i = m.getExtent(); var e = v.parse(Z[0]); var v1 = m.parse(Z[1]); k = k || []; k[0] = Math.min(Math.max(Math.min(v2[0], v2[1]), e), Math.max(v2[0], v2[1])); k[1] = Math.min(Math.max(Math.min(i[0], i[1]), v1), Math.max(i[0], i[1])); return k }, pointToData: function (e, k) { var m = this.getAxis("x"); var i = this.getAxis("y"); k = k || []; k[0] = m.coordToData(m.toLocalCoord(e[0])); k[1] = i.coordToData(i.toLocalCoord(e[1])); return k }, getOtherAxis: function (e) { return this.getAxis(e.dim === "x" ? "y" : "x") }
  }; mr(Bi, bS); var CX = function (m, v, k, i, e) { BS.call(this, m, v, k); this.type = i || "value"; this.position = e || "bottom" }; CX.prototype = { constructor: CX, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal: function () { var e = this.position; return e === "top" || e === "bottom" }, getGlobalExtent: function (i) { var e = this.getExtent(); e[0] = this.toGlobalCoord(e[0]); e[1] = this.toGlobalCoord(e[1]); i && e[0] > e[1] && e.reverse(); return e }, getOtherAxis: function () { this.grid.getOtherAxis() }, pointToData: function (e, i) { return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), i) }, toLocalCoord: null, toGlobalCoord: null }; mr(CX, BS); var BE = { show: true, zlevel: 0, z: 0, inverse: false, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: false, triggerEvent: false, tooltip: { show: false }, axisPointer: {}, axisLine: { show: true, onZero: true, onZeroAxisIndex: null, lineStyle: { color: "#333", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: true, inside: false, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: true, inside: false, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: true, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: false, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } }; var bH = {}; bH.categoryAxis = v4({ boundaryGap: true, deduplication: null, splitLine: { show: false }, axisTick: { alignWithLabel: false, interval: "auto" }, axisLabel: { interval: "auto" } }, BE); bH.valueAxis = v4({ boundaryGap: [0, 0], splitNumber: 5 }, BE); bH.timeAxis = De({ scale: true, min: "dataMin", max: "dataMax" }, bH.valueAxis); bH.logAxis = De({ scale: true, logBase: 10 }, bH.valueAxis); var Ib = ["value", "category", "time", "log"]; var mR = function (m, e, i, k) { o9(Ib, function (v) { e.extend({ type: m + "Axis." + v, mergeDefaultAndTheme: function (v1, Z) { var v3 = this.layoutMode; var Ij = v3 ? g2(v1) : {}; var v2 = Z.getTheme(); v4(v1, v2.get(v + "Axis")); v4(v1, this.getDefaultOption()); v1.type = i(m, v1); if (v3) { he(v1, Ij, v3) } }, optionUpdated: function () { var Z = this.option; if (Z.type === "category") { this.__ordinalMeta = lP.createByAxisModel(this) } }, getCategories: function (v1) { var Z = this.option; if (Z.type === "category") { if (v1) { return Z.data } return this.__ordinalMeta.categories } }, getOrdinalMeta: function () { return this.__ordinalMeta }, defaultOption: aa([{}, bH[v + "Axis"], k], true) }) }); aH.registerSubTypeDefaulter(m + "Axis", sv(i, m)) }; var dg = aH.extend({ type: "cartesian2dAxis", axis: null, init: function () { dg.superApply(this, "init", arguments); this.resetRange() }, mergeOption: function () { dg.superApply(this, "mergeOption", arguments); this.resetRange() }, restoreData: function () { dg.superApply(this, "restoreData", arguments); this.resetRange() }, getCoordSysModel: function () { return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0] } }); function uH(i, e) { return e.type || (e.data ? "category" : "value") } v4(dg.prototype, nB); var aG = { offset: 0 }; mR("x", dg, uH, aG); mR("y", dg, uH, aG); aH.extend({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: false, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: false, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } }); function zl(i, k, e) { return i.getCoordSysModel() === k } function pY(k, e, i) { this._coordsMap = {}; this._coordsList = []; this._axesMap = {}; this._axesList = []; this._initCartesian(k, e, i); this.model = k } var Ez = pY.prototype; Ez.type = "grid"; Ez.axisPointerEnabled = true; Ez.getRect = function () { return this._rect }; Ez.update = function (e, k) { var i = this._axesMap; this._updateScale(e, this.model); o9(i.x, function (m) { nL(m.scale, m.model) }); o9(i.y, function (m) { nL(m.scale, m.model) }); o9(i.x, function (m) { su(i, "y", m) }); o9(i.y, function (m) { su(i, "x", m) }); this.resize(this.model, k) }; function su(Z, m, i) { i.getAxesOnZeroOf = function () { return k ? [k] : [] }; var v1 = Z[m]; var k; var v3 = i.model; var v = v3.get("axisLine.onZero"); var e = v3.get("axisLine.onZeroAxisIndex"); if (!v) { return } if (e != null) { if (Hm(v1[e])) { k = v1[e] } return } for (var v2 in v1) { if (v1.hasOwnProperty(v2) && Hm(v1[v2])) { k = v1[v2]; break } } } function Hm(e) {
    return e && e.type !== "category" && e.type !== "time" && A9(e)
  } Ez.resize = function (v, k, e) { var i = kV(v.getBoxLayoutParams(), { width: k.getWidth(), height: k.getHeight() }); this._rect = i; var m = this._axesList; Z(); if (!e && v.get("containLabel")) { o9(m, function (v2) { if (!v2.model.get("axisLabel.inside")) { var v1 = eB(v2); if (v1) { var Ij = v2.isHorizontal() ? "height" : "width"; var v3 = v2.model.get("axisLabel.margin"); i[Ij] -= v1[Ij] + v3; if (v2.position === "top") { i.y += v1.height + v3 } else { if (v2.position === "left") { i.x += v1.width + v3 } } } } }); Z() } function Z() { o9(m, function (v3) { var Ij = v3.isHorizontal(); var v2 = Ij ? [0, i.width] : [0, i.height]; var v1 = v3.inverse ? 1 : 0; v3.setExtent(v2[v1], v2[1 - v1]); Fj(v3, Ij ? i.x : i.y) }) } }; Ez.getAxis = function (e, k) { var m = this._axesMap[e]; if (m != null) { if (k == null) { for (var i in m) { if (m.hasOwnProperty(i)) { return m[i] } } } return m[k] } }; Ez.getAxes = function () { return this._axesList.slice() }; Ez.getCartesian = function (e, Z) { if (e != null && Z != null) { var v = "x" + e + "y" + Z; return this._coordsMap[v] } if (tJ(e)) { Z = e.yAxisIndex; e = e.xAxisIndex } for (var m = 0, k = this._coordsList; m < k.length; m++) { if (k[m].getAxis("x").index === e || k[m].getAxis("y").index === Z) { return k[m] } } }; Ez.getCartesians = function () { return this._coordsList.slice() }; Ez.convertToPixel = function (e, m, i) { var k = this._findConvertTarget(e, m); return k.cartesian ? k.cartesian.dataToPoint(i) : k.axis ? k.axis.toGlobalCoord(k.axis.dataToCoord(i)) : null }; Ez.convertFromPixel = function (e, m, i) { var k = this._findConvertTarget(e, m); return k.cartesian ? k.cartesian.pointToData(i) : k.axis ? k.axis.coordToData(k.axis.toLocalCoord(i)) : null }; Ez._findConvertTarget = function (v2, i) { var m = i.seriesModel; var v = i.xAxisModel || (m && m.getReferringComponents("xAxis")[0]); var v3 = i.yAxisModel || (m && m.getReferringComponents("yAxis")[0]); var Ij = i.gridModel; var Z = this._coordsList; var v1; var k; if (m) { v1 = m.coordinateSystem; eP(Z, v1) < 0 && (v1 = null) } else { if (v && v3) { v1 = this.getCartesian(v.componentIndex, v3.componentIndex) } else { if (v) { k = this.getAxis("x", v.componentIndex) } else { if (v3) { k = this.getAxis("y", v3.componentIndex) } else { if (Ij) { var e = Ij.coordinateSystem; if (e === this) { v1 = this._coordsList[0] } } } } } } return { cartesian: v1, axis: k } }; Ez.containPoint = function (e) { var i = this._coordsList[0]; if (i) { return i.containPoint(e) } }; Ez._initCartesian = function (Z, i, v) { var m = { left: false, right: false, top: false, bottom: false }; var k = { x: {}, y: {} }; var v1 = { x: 0, y: 0 }; i.eachComponent("xAxis", e("x"), this); i.eachComponent("yAxis", e("y"), this); if (!v1.x || !v1.y) { this._axesMap = {}; this._axesList = []; return } this._axesMap = k; o9(k.x, function (v3, v2) { o9(k.y, function (Ij, Il) { var Ik = "x" + v2 + "y" + Il; var Im = new Bi(Ik); Im.grid = this; Im.model = Z; this._coordsMap[Ik] = Im; this._coordsList.push(Im); Im.addAxis(v3); Im.addAxis(Ij) }, this) }, this); function e(v2) { return function (Il, v3) { if (!zl(Il, Z, i)) { return } var Ik = Il.get("position"); if (v2 === "x") { if (Ik !== "top" && Ik !== "bottom") { Ik = "bottom"; if (m[Ik]) { Ik = Ik === "top" ? "bottom" : "top" } } } else { if (Ik !== "left" && Ik !== "right") { Ik = "left"; if (m[Ik]) { Ik = Ik === "left" ? "right" : "left" } } } m[Ik] = true; var Im = new CX(v2, nq(Il), [0, 0], Il.get("type"), Ik); var Ij = Im.type === "category"; Im.onBand = Ij && Il.get("boundaryGap"); Im.inverse = Il.get("inverse"); Il.axis = Im; Im.model = Il; Im.grid = this; Im.index = v3; this._axesList.push(Im); k[v2][v3] = Im; v1[v2]++ } } }; Ez._updateScale = function (e, i) { o9(this._axesList, function (m) { m.scale.setExtent(Infinity, -Infinity) }); e.eachSeries(function (v) { if (xL(v)) { var v2 = lo(v, e); var Z = v2[0]; var v1 = v2[1]; if (!zl(Z, i, e) || !zl(v1, i, e)) { return } var Ik = this.getCartesian(Z.componentIndex, v1.componentIndex); var Ij = v.getData(); var v3 = Ik.getAxis("x"); var m = Ik.getAxis("y"); if (Ij.type === "list") { k(Ij, v3, v); k(Ij, m, v) } } }, this); function k(Z, v, m) { o9(Z.mapDimension(v.dim, true), function (v1) { v.scale.unionExtentFromData(Z, jB(Z, v1)) }) } }; Ez.getTooltipAxes = function (i) { var k = []; var e = []; o9(this.getCartesians(), function (Z) { var v = (i != null && i !== "auto") ? Z.getAxis(i) : Z.getBaseAxis(); var m = Z.getOtherAxis(v); eP(k, v) < 0 && k.push(v); eP(e, m) < 0 && e.push(m) }); return { baseAxes: k, otherAxes: e } }; function Fj(k, e) { var m = k.getExtent(); var i = m[0] + m[1]; k.toGlobalCoord = k.dim === "x" ? function (v) { return v + e } : function (v) { return i - v + e }; k.toLocalCoord = k.dim === "x" ? function (v) { return v - e } : function (v) { return i - v + e } } var p0 = ["xAxis", "yAxis"]; function lo(i, e) { return Ef(p0, function (k) { var m = i.getReferringComponents(k)[0]; if (ok) { if (!m) { throw new Error(k + ' "' + gu(i.get(k + "Index"), i.get(k + "Id"), 0) + '" not found') } } return m }) } function xL(e) { return e.get("coordinateSystem") === "cartesian2d" } pY.create = function (e, i) { var k = []; e.eachComponent("grid", function (Z, m) { var v = new pY(Z, e, i); v.name = "grid_" + m; v.resize(Z, i, true); Z.coordinateSystem = v; k.push(v) }); e.eachSeries(function (m) { if (!xL(m)) { return } var v3 = lo(m, e); var v = v3[0]; var v1 = v3[1]; var v2 = v.getCoordSysModel(); if (ok) { if (!v2) { throw new Error('Grid "' + gu(v.get("gridIndex"), v.get("gridId"), 0) + '" not found') } if (v.getCoordSysModel() !== v1.getCoordSysModel()) { throw new Error("xAxis and yAxis must use the same grid") } } var Z = v2.coordinateSystem; m.coordinateSystem = Z.getCartesian(v.componentIndex, v1.componentIndex) }); return k }; pY.dimensions = pY.prototype.dimensions = Bi.prototype.dimensions; fz.register("cartesian2d", pY); var yE = Math.PI;
  function v6(e) { var i = { componentType: e.mainType }; i[e.mainType + "Index"] = e.componentIndex; return i } var da = function (k, i) { this.opt = i; this.axisModel = k; De(i, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: true }); this.group = new B8(); var e = new B8({ position: i.position.slice(), rotation: i.rotation }); e.updateTransform(); this._transform = e.transform; this._dumbGroup = e }; da.prototype = { constructor: da, hasBuilder: function (e) { return !!wG[e] }, add: function (e) { wG[e].call(this) }, getGroup: function () { return this.group } }; var wG = { axisLine: function () { var e = this.opt; var v3 = this.axisModel; if (!v3.get("axisLine.show")) { return } var Il = this.axisModel.axis.getExtent(); var v = this._transform; var v2 = [Il[0], 0]; var Z = [Il[1], 0]; if (v) { aY(v2, v2, v); aY(Z, Z, v) } var m = b0({ lineCap: "round" }, v3.getModel("axisLine.lineStyle").getLineStyle()); this.group.add(new zB(dn({ anid: "line", shape: { x1: v2[0], y1: v2[1], x2: Z[0], y2: Z[1] }, style: m, strokeContainThreshold: e.strokeContainThreshold || 5, silent: true, z2: 1 }))); var Ij = v3.get("axisLine.symbol"); var k = v3.get("axisLine.symbolSize"); var v1 = v3.get("axisLine.symbolOffset") || 0; if (typeof v1 === "number") { v1 = [v1, v1] } if (Ij != null) { if (typeof Ij === "string") { Ij = [Ij, Ij] } if (typeof k === "string" || typeof k === "number") { k = [k, k] } var i = k[0]; var Ik = k[1]; o9([{ rotate: e.rotation + Math.PI / 2, offset: v1[0], r: 0 }, { rotate: e.rotation - Math.PI / 2, offset: v1[1], r: Math.sqrt((v2[0] - Z[0]) * (v2[0] - Z[0]) + (v2[1] - Z[1]) * (v2[1] - Z[1])) }], function (Im, In) { if (Ij[In] !== "none" && Ij[In] != null) { var Ip = t9(Ij[In], -i / 2, -Ik / 2, i, Ik, m.stroke, true); var Io = Im.r + Im.offset; var Iq = [v2[0] + Io * Math.cos(e.rotation), v2[1] - Io * Math.sin(e.rotation)]; Ip.attr({ rotation: Im.rotate, position: Iq, silent: true }); this.group.add(Ip) } }, this) } }, axisTickLabel: function () { var m = this.axisModel; var k = this.opt; var i = jl(this, m, k); var e = u1(this, m, k); GF(m, e, i) }, axisName: function () { var i = this.opt; var Z = this.axisModel; var Iv = gu(i.axisName, Z.get("name")); if (!Iv) { return } var In = Z.get("nameLocation"); var Ij = i.nameDirection; var v = Z.getModel("nameTextStyle"); var Il = Z.get("nameGap") || 0; var v2 = this.axisModel.axis.getExtent(); var v3 = v2[0] > v2[1] ? -1 : 1; var k = [In === "start" ? v2[0] - v3 * Il : In === "end" ? v2[1] + v3 * Il : (v2[0] + v2[1]) / 2, nX(In) ? i.labelOffset + Ij * Il : 0]; var m; var v1 = Z.get("nameRotate"); if (v1 != null) { v1 = v1 * yE / 180 } var Iq; if (nX(In)) { m = nG(i.rotation, v1 != null ? v1 : i.rotation, Ij) } else { m = nr(i, In, v1 || 0, v2); Iq = i.axisNameAvailableWidth; if (Iq != null) { Iq = Math.abs(Iq / Math.sin(m.rotation)); !isFinite(Iq) && (Iq = null) } } var Ik = v.getFont(); var Iu = Z.get("nameTruncate", true) || {}; var e = Iu.ellipsis; var Io = gu(i.nameTruncateMaxWidth, Iu.maxWidth, Iq); var Is = (e != null && Io != null) ? hc(Iv, Io, Ik, e, { minChar: 2, placeholder: Iu.placeholder }) : Iv; var Ir = Z.get("tooltip", true); var Ip = Z.mainType; var It = { componentType: Ip, name: Iv, $vars: ["name"] }; It[Ip + "Index"] = Z.componentIndex; var Im = new iR({ anid: "name", __fullText: Iv, __truncatedText: Is, position: k, rotation: m.rotation, silent: a8(Z), z2: 1, tooltip: (Ir && Ir.show) ? b0({ content: Iv, formatter: function () { return Iv }, formatterParams: It }, Ir) : null }); pe(Im.style, v, { text: Is, textFont: Ik, textFill: v.getTextColor() || Z.get("axisLine.lineStyle.color"), textAlign: m.textAlign, textVerticalAlign: m.textVerticalAlign }); if (Z.get("triggerEvent")) { Im.eventData = v6(Z); Im.eventData.targetType = "axisName"; Im.eventData.name = Iv } this._dumbGroup.add(Im); Im.updateTransform(); this.group.add(Im); Im.decomposeTransform() } }; var nG = da.innerTextLayout = function (Z, i, v) { var m = ru(i - Z); var k; var e; if (uM(m)) { e = v > 0 ? "top" : "bottom"; k = "center" } else { if (uM(m - yE)) { e = v > 0 ? "bottom" : "top"; k = "center" } else { e = "middle"; if (m > 0 && m < yE) { k = v > 0 ? "right" : "left" } else { k = v > 0 ? "left" : "right" } } } return { rotation: m, textAlign: k, textVerticalAlign: e } }; function nr(i, v3, v, v2) { var m = ru(v - i.rotation); var k; var v1; var Z = v2[0] > v2[1]; var e = (v3 === "start" && !Z) || (v3 !== "start" && Z); if (uM(m - yE / 2)) { v1 = e ? "bottom" : "top"; k = "center" } else { if (uM(m - yE * 1.5)) { v1 = e ? "top" : "bottom"; k = "center" } else { v1 = "middle"; if (m < yE * 1.5 && m > yE / 2) { k = e ? "left" : "right" } else { k = e ? "right" : "left" } } } return { rotation: m, textAlign: k, textVerticalAlign: v1 } } function a8(i) { var e = i.get("tooltip"); return i.get("silent") || !(i.get("triggerEvent") || (e && e.show)) } function GF(Ik, Il, e) { var Im = Ik.get("axisLabel.showMinLabel"); var Ij = Ik.get("axisLabel.showMaxLabel"); Il = Il || []; e = e || []; var v = Il[0]; var v2 = Il[1]; var v3 = Il[Il.length - 1]; var Z = Il[Il.length - 2]; var i = e[0]; var v1 = e[1]; var m = e[e.length - 1]; var k = e[e.length - 2]; if (Im === false) { sA(v); sA(i) } else { if (zy(v, v2)) { if (Im) { sA(v2); sA(v1) } else { sA(v); sA(i) } } } if (Ij === false) { sA(v3); sA(m) } else { if (zy(Z, v3)) { if (Ij) { sA(Z); sA(k) } else { sA(v3); sA(m) } } } } function sA(e) { e && (e.ignore = true) } function zy(Z, m, i) { var v = Z && Z.getBoundingRect().clone(); var e = m && m.getBoundingRect().clone(); if (!v || !e) { return } var k = lN([]); ki(k, k, -Z.rotation); v.applyTransform(l([], k, Z.getLocalTransform())); e.applyTransform(l([], k, m.getLocalTransform())); return v.intersect(e) } function nX(e) { return e === "middle" || e === "center" } function jl(v3, Io, m) {
    var v1 = Io.axis; if (!Io.get("axisTick.show") || v1.scale.isBlank()) { return } var Ip = Io.getModel("axisTick"); var Ij = Ip.getModel("lineStyle"); var Z = Ip.get("length");
    var Ik = v1.getTicksCoords(); var In = []; var Im = []; var Il = v3._transform; var k = []; for (var v2 = 0; v2 < Ik.length; v2++) { var e = Ik[v2].coord; In[0] = e; In[1] = 0; Im[0] = e; Im[1] = m.tickDirection * Z; if (Il) { aY(In, In, Il); aY(Im, Im, Il) } var v = new zB(dn({ anid: "tick_" + Ik[v2].tickValue, shape: { x1: In[0], y1: In[1], x2: Im[0], y2: Im[1] }, style: De(Ij.getLineStyle(), { stroke: Io.get("axisLine.lineStyle.color") }), z2: 2, silent: true })); v3.group.add(v); k.push(v) } return k
  } function u1(Z, Ik, e) { var i = Ik.axis; var v3 = gu(e.axisLabelShow, Ik.get("axisLabel.show")); if (!v3 || i.scale.isBlank()) { return } var In = Ik.getModel("axisLabel"); var v2 = In.get("margin"); var k = i.getViewLabels(); var Il = (gu(e.labelRotate, In.get("rotate")) || 0) * yE / 180; var Im = nG(e.rotation, Il, e.labelDirection); var v = Ik.getCategories(true); var Ij = []; var m = a8(Ik); var v1 = Ik.get("triggerEvent"); o9(k, function (Ip, It) { var Ir = Ip.tickValue; var Is = Ip.formattedLabel; var Iq = Ip.rawLabel; var Iv = In; if (v && v[Ir] && v[Ir].textStyle) { Iv = new fv(v[Ir].textStyle, In, Ik.ecModel) } var Iw = Iv.getTextColor() || Ik.get("axisLine.lineStyle.color"); var Io = i.dataToCoord(Ir); var Iu = [Io, e.labelOffset + e.labelDirection * v2]; var Ix = new iR({ anid: "label_" + Ir, position: Iu, rotation: Im.rotation, silent: m, z2: 10 }); pe(Ix.style, Iv, { text: Is, textAlign: Iv.getShallow("align", true) || Im.textAlign, textVerticalAlign: Iv.getShallow("verticalAlign", true) || Iv.getShallow("baseline", true) || Im.textVerticalAlign, textFill: typeof Iw === "function" ? Iw(i.type === "category" ? Iq : i.type === "value" ? Ir + "" : Ir, It) : Iw }); if (v1) { Ix.eventData = v6(Ik); Ix.eventData.targetType = "axisLabel"; Ix.eventData.value = Iq } Z._dumbGroup.add(Ix); Ix.updateTransform(); Ij.push(Ix); Z.group.add(Ix); Ix.decomposeTransform() }); return Ij } var o1 = o9; var um = sv; function ij(i, k) { var e = { axesInfo: {}, seriesInvolved: false, coordSysAxesInfo: {}, coordSysMap: {} }; eS(e, i, k); e.seriesInvolved && Hj(e, i); return e } function eS(i, e, v) { var m = e.getComponent("tooltip"); var v1 = e.getComponent("axisPointer"); var Z = v1.get("link", true) || []; var k = []; o1(v.getCoordinateSystems(), function (Im) { if (!Im.axisPointerEnabled) { return } var Ij = GD(Im.model); var Ik = i.coordSysAxesInfo[Ij] = {}; i.coordSysMap[Ij] = Im; var Il = Im.model; var In = Il.getModel("tooltip", m); o1(Im.getAxes(), um(v2, false, null)); if (Im.getTooltipAxes && m && In.get("show")) { var Ip = In.get("trigger") === "axis"; var Io = In.get("axisPointer.type") === "cross"; var v3 = Im.getTooltipAxes(In.get("axisPointer.axis")); if (Ip || Io) { o1(v3.baseAxes, um(v2, Io ? "cross" : true, Ip)) } if (Io) { o1(v3.otherAxes, um(v2, "cross", false)) } } function v2(Ir, It, Is) { var Ix = Is.model.getModel("axisPointer", v1); var IA = Ix.get("show"); if (!IA || (IA === "auto" && !Ir && !eU(Ix))) { return } if (It == null) { It = Ix.get("triggerTooltip") } Ix = Ir ? nz(Is, In, v1, e, Ir, It) : Ix; var Iu = Ix.get("snap"); var Iz = GD(Is.model); var Iw = It || Iu || Is.type === "category"; var Iv = i.axesInfo[Iz] = { key: Iz, axis: Is, coordSys: Im, axisPointerModel: Ix, triggerTooltip: It, involveSeries: Iw, snap: Iu, useHandle: eU(Ix), seriesModels: [] }; Ik[Iz] = Iv; i.seriesInvolved |= Iw; var Iy = E4(Z, Is); if (Iy != null) { var Iq = k[Iy] || (k[Iy] = { axesInfo: {} }); Iq.axesInfo[Iz] = Iv; Iq.mapper = Z[Iy].mapper; Iv.linkGroup = Iq } } }) } function nz(i, Z, v, v2, e, k) { var m = Z.getModel("axisPointer"); var v1 = {}; o1(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function (Il) { v1[Il] = C5(m.get(Il)) }); v1.snap = i.type !== "category" && !!k; if (m.get("type") === "cross") { v1.type = "line" } var Ik = v1.label || (v1.label = {}); Ik.show == null && (Ik.show = false); if (e === "cross") { var Ij = m.get("label.show"); Ik.show = Ij != null ? Ij : true; if (!k) { var v3 = v1.lineStyle = m.get("crossStyle"); v3 && De(Ik, v3.textStyle) } } return i.model.getModel("axisPointer", new fv(v1, v, v2)) } function Hj(i, e) { e.eachSeries(function (k) { var v = k.coordinateSystem; var m = k.get("tooltip.trigger", true); var Z = k.get("tooltip.show", true); if (!v || m === "none" || m === false || m === "item" || Z === false || k.get("axisPointer.show", true) === false) { return } o1(i.coordSysAxesInfo[GD(v.model)], function (v1) { var v2 = v1.axis; if (v.getAxis(v2.dim) === v2) { v1.seriesModels.push(k); v1.seriesDataCount == null && (v1.seriesDataCount = 0); v1.seriesDataCount += k.getData().count() } }) }, this) } function E4(v1, m) { var k = m.model; var Z = m.dim; for (var e = 0; e < v1.length; e++) { var v = v1[e] || {}; if (p8(v[Z + "AxisId"], k.id) || p8(v[Z + "AxisIndex"], k.componentIndex) || p8(v[Z + "AxisName"], k.name)) { return e } } } function p8(i, e) { return i === "all" || (GG(i) && eP(i, e) >= 0) || i === e } function qb(v2) { var i = Du(v2); if (!i) { return } var Z = i.axisPointerModel; var e = i.axis.scale; var v = Z.option; var k = Z.get("status"); var v1 = Z.get("value"); if (v1 != null) { v1 = e.parse(v1) } var m = eU(Z); if (k == null) { v.status = m ? "show" : "hide" } var v3 = e.getExtent().slice(); v3[0] > v3[1] && v3.reverse(); if (v1 == null || v1 > v3[1]) { v1 = v3[1] } if (v1 < v3[0]) { v1 = v3[0] } v.value = v1; if (m) { v.status = i.axis.scale.isBlank() ? "hide" : "show" } } function Du(e) { var i = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo; return i && i.axesInfo[GD(e)] } function sy(i) { var e = Du(i); return e && e.axisPointerModel } function eU(e) { return !!e.get("handle.show") } function GD(e) { return e.type + "||" + e.id } var f2 = qy({
    type: "axis", _axisPointer: null, axisPointerClass: null, render: function (i, e, k, m) {
      this.axisPointerClass && qb(i);
      f2.superApply(this, "render", arguments); Ei(this, i, e, k, m, true)
    }, updateAxisPointer: function (i, e, k, v, m) { Ei(this, i, e, k, v, false) }, remove: function (e, k) { var i = this._axisPointer; i && i.remove(k); f2.superApply(this, "remove", arguments) }, dispose: function (e, i) { l4(this, i); f2.superApply(this, "dispose", arguments) }
  }); function Ei(v, i, e, k, Z, v2) { var v1 = f2.getAxisPointerClass(v.axisPointerClass); if (!v1) { return } var m = sy(i); m ? (v._axisPointer || (v._axisPointer = new v1())).render(i, m, k, v2) : l4(v, k) } function l4(m, e, k) { var i = m._axisPointer; i && i.dispose(e, k); m._axisPointer = null } var Br = []; f2.registerAxisPointerClass = function (i, e) { if (ok) { if (Br[i]) { throw new Error("axisPointer " + i + " exists") } } Br[i] = e }; f2.getAxisPointerClass = function (e) { return e && Br[e] }; function ei(Ij, Ik, k) { k = k || {}; var i = Ij.coordinateSystem; var v = Ik.axis; var Ir = {}; var v3 = v.getAxesOnZeroOf()[0]; var e = v.position; var Il = v3 ? "onZero" : e; var In = v.dim; var m = i.getRect(); var Im = [m.x, m.x + m.width, m.y, m.y + m.height]; var Io = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }; var Z = Ik.get("offset") || 0; var Ip = In === "x" ? [Im[2] - Z, Im[3] + Z] : [Im[0] - Z, Im[1] + Z]; if (v3) { var v2 = v3.toGlobalCoord(v3.dataToCoord(0)); Ip[Io["onZero"]] = Math.max(Math.min(v2, Ip[1]), Ip[0]) } Ir.position = [In === "y" ? Ip[Io[Il]] : Im[0], In === "x" ? Ip[Io[Il]] : Im[3]]; Ir.rotation = Math.PI / 2 * (In === "x" ? 0 : 1); var v1 = { top: -1, bottom: 1, left: -1, right: 1 }; Ir.labelDirection = Ir.tickDirection = Ir.nameDirection = v1[e]; Ir.labelOffset = v3 ? Ip[Io[e]] - Ip[Io["onZero"]] : 0; if (Ik.get("axisTick.inside")) { Ir.tickDirection = -Ir.tickDirection } if (gu(k.labelInside, Ik.get("axisLabel.inside"))) { Ir.labelDirection = -Ir.labelDirection } var Iq = Ik.get("axisLabel.rotate"); Ir.labelRotate = Il === "top" ? -Iq : Iq; Ir.z2 = 1; return Ir } var F9 = ["axisLine", "axisTickLabel", "axisName"]; var jE = ["splitArea", "splitLine"]; var oh = f2.extend({ type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function (i, e, m, v2) { this.group.removeAll(); var k = this._axisGroup; this._axisGroup = new B8(); this.group.add(this._axisGroup); if (!i.get("show")) { return } var Z = i.getCoordSysModel(); var v = ei(Z, i); var v1 = new da(i, v); o9(F9, v1.add, v1); this._axisGroup.add(v1.getGroup()); o9(jE, function (v3) { if (i.get(v3 + ".show")) { this["_" + v3](i, Z) } }, this); E(k, this._axisGroup, i); oh.superCall(this, "render", i, e, m, v2) }, remove: function () { this._splitAreaColors = null }, _splitLine: function (In, Iq) { var v = In.axis; if (v.scale.isBlank()) { return } var m = In.getModel("splitLine"); var Ij = m.getModel("lineStyle"); var Ir = Ij.get("color"); Ir = GG(Ir) ? Ir : [Ir]; var e = Iq.coordinateSystem.getRect(); var Ik = v.isHorizontal(); var Ip = 0; var v3 = v.getTicksCoords({ tickModel: m }); var Io = []; var Im = []; var v2 = Ij.getLineStyle(); for (var v1 = 0; v1 < v3.length; v1++) { var k = v.toGlobalCoord(v3[v1].coord); if (Ik) { Io[0] = k; Io[1] = e.y; Im[0] = k; Im[1] = e.y + e.height } else { Io[0] = e.x; Io[1] = k; Im[0] = e.x + e.width; Im[1] = k } var Il = (Ip++) % Ir.length; var Z = v3[v1].tickValue; this._axisGroup.add(new zB(dn({ anid: Z != null ? "line_" + v3[v1].tickValue : null, shape: { x1: Io[0], y1: Io[1], x2: Im[0], y2: Im[1] }, style: De({ stroke: Ir[Il] }, v2), silent: true }))) } }, _splitArea: function (v1, Z) { var k = v1.axis; if (k.scale.isBlank()) { return } var Is = v1.getModel("splitArea"); var In = Is.getModel("areaStyle"); var e = In.get("color"); var Iv = Z.coordinateSystem.getRect(); var Im = k.getTicksCoords({ tickModel: Is, clamp: true }); if (!Im.length) { return } var v = e.length; var Iu = this._splitAreaColors; var Iw = CJ(); var m = 0; if (Iu) { for (var It = 0; It < Im.length; It++) { var Ir = Iu.get(Im[It].tickValue); if (Ir != null) { m = (Ir + (v - 1) * It) % v; break } } } var Ip = k.toGlobalCoord(Im[0].coord); var Il = In.getAreaStyle(); e = GG(e) ? e : [e]; for (var It = 1; It < Im.length; It++) { var Ij = k.toGlobalCoord(Im[It].coord); var Ik; var v3; var Iq; var Io; if (k.isHorizontal()) { Ik = Ip; v3 = Iv.y; Iq = Ij - Ik; Io = Iv.height; Ip = Ik + Iq } else { Ik = Iv.x; v3 = Ip; Iq = Iv.width; Io = Ij - v3; Ip = v3 + Io } var v2 = Im[It - 1].tickValue; v2 != null && Iw.set(v2, m); this._axisGroup.add(new EH({ anid: v2 != null ? "area_" + v2 : null, shape: { x: Ik, y: v3, width: Iq, height: Io }, style: De({ fill: e[m] }, Il), silent: true })); m = (m + 1) % v } this._splitAreaColors = Iw } }); oh.extend({ type: "xAxis" }); oh.extend({ type: "yAxis" }); qy({ type: "grid", render: function (i, e) { this.group.removeAll(); if (i.get("show")) { this.group.add(new EH({ shape: i.coordinateSystem.getRect(), style: De({ fill: i.get("backgroundColor") }, i.getItemStyle()), silent: true, z2: -1 })) } } }); y2(function (e) { if (e.xAxis && e.yAxis && !e.grid) { e.grid = {} } }); G(ml("line", "circle", "line")); pr(qA("line")); eb(B6.PROCESSOR.STATISTIC, xs("line")); var wN = nU.extend({ type: "series.__base_bar__", getInitialData: function (i, e) { return a(this.getSource(), this) }, getMarkerPosition: function (v) { var k = this.coordinateSystem; if (k) { var Z = k.dataToPoint(k.clampData(v)); var m = this.getData(); var v1 = m.getLayout("offset"); var i = m.getLayout("size"); var e = k.getBaseAxis().isHorizontal() ? 0 : 1; Z[e] += v1 + i / 2; return Z } return [NaN, NaN] }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, barMinHeight: 0, barMinAngle: 0, large: false, largeThreshold: 400, progressive: 3000, progressiveChunkMode: "mod", itemStyle: {}, emphasis: {} } }); wN.extend({
    type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect", getProgressive: function () {
      return this.get("large") ? this.get("progressive") : false
    }, getProgressiveThreshold: function () { var e = this.get("progressiveThreshold"); var i = this.get("largeThreshold"); if (i > e) { e = i } return e }
  }); function EL(e, i, v2, m, k, Z, v1) { var v3 = v2.getModel("label"); var v = v2.getModel("emphasis.label"); BD(e, i, v3, v, { labelFetcher: k, labelDataIndex: Z, defaultText: dX(k.getData(), Z), isRectText: true, autoColor: m }); mw(e); mw(i) } function mw(i, e) { if (i.textPosition === "outside") { i.textPosition = e } } var xC = yO([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]); var Ht = { getBarItemStyle: function (k) { var i = xC(this, k); if (this.getBorderLineDash) { var e = this.getBorderLineDash(); e && (i.lineDash = e) } return i } }; var Aq = ["itemStyle", "barBorderWidth"]; b0(fv.prototype, Ht); BL({ type: "bar", render: function (i, e, k) { this._updateDrawMode(i); var m = i.get("coordinateSystem"); if (m === "cartesian2d" || m === "polar") { this._isLargeDraw ? this._renderLarge(i, e, k) : this._renderNormal(i, e, k) } else { if (ok) { console.warn("Only cartesian2d and polar supported for bar.") } } return this.group }, incrementalPrepareRender: function (i, e, k) { this._clear(); this._updateDrawMode(i) }, incrementalRender: function (m, i, e, k) { this._incrementalRenderLarge(m, i) }, _updateDrawMode: function (i) { var e = i.pipelineContext.large; if (this._isLargeDraw == null || e ^ this._isLargeDraw) { this._isLargeDraw = e; this._clear() } }, _renderNormal: function (i, Z, v2) { var v3 = this.group; var k = i.getData(); var m = this._data; var v1 = i.coordinateSystem; var e = v1.getBaseAxis(); var Ij; if (v1.type === "cartesian2d") { Ij = e.isHorizontal() } else { if (v1.type === "polar") { Ij = e.dim === "angle" } } var v = i.isAnimationEnabled() ? i : null; k.diff(m).add(function (Ik) { if (!k.hasValue(Ik)) { return } var Im = k.getItemModel(Ik); var In = kY[v1.type](k, Ik, Im); var Il = aq[v1.type](k, Ik, Im, In, Ij, v); k.setItemGraphicEl(Ik, Il); v3.add(Il); Bs(Il, k, Ik, Im, In, i, Ij, v1.type === "polar") }).update(function (Ik, Io) { var Im = m.getItemGraphicEl(Io); if (!k.hasValue(Ik)) { v3.remove(Im); return } var Il = k.getItemModel(Ik); var In = kY[v1.type](k, Ik, Il); if (Im) { oS(Im, { shape: In }, v, Ik) } else { Im = aq[v1.type](k, Ik, Il, In, Ij, v, true) } k.setItemGraphicEl(Ik, Im); v3.add(Im); Bs(Im, k, Ik, Il, In, i, Ij, v1.type === "polar") }).remove(function (Ik) { var Il = m.getItemGraphicEl(Ik); if (v1.type === "cartesian2d") { Il && rm(Ik, v, Il) } else { Il && t7(Ik, v, Il) } }).execute(); this._data = k }, _renderLarge: function (i, e, k) { this._clear(); Hv(i, this.group) }, _incrementalRenderLarge: function (i, e) { Hv(e, this.group, true) }, dispose: V, remove: function (e) { this._clear(e) }, _clear: function (e) { var k = this.group; var i = this._data; if (e && e.get("animation") && i && !this._isLargeDraw) { i.eachItemGraphicEl(function (m) { if (m.type === "sector") { t7(m.dataIndex, e, m) } else { rm(m.dataIndex, e, m) } }) } else { k.removeAll() } this._data = null } }); var aq = { cartesian2d: function (i, v2, Ij, k, v1, m, Ik) { var Z = new EH({ shape: b0({}, k) }); if (m) { var v3 = Z.shape; var v = v1 ? "height" : "width"; var e = {}; v3[v] = 0; e[v] = k[v]; yf[Ik ? "updateProps" : "initProps"](Z, { shape: e }, m, v2) } return Z }, polar: function (v, v3, Ik, Z, m, v1, Il) { var e = Z.startAngle < Z.endAngle; var k = new tx({ shape: De({ clockwise: e }, Z) }); if (v1) { var Ij = k.shape; var v2 = m ? "r" : "endAngle"; var i = {}; Ij[v2] = m ? 0 : Z.startAngle; i[v2] = Z[v2]; yf[Il ? "updateProps" : "initProps"](k, { shape: i }, v1, v3) } return k } }; function rm(i, e, k) { k.style.text = null; oS(k, { shape: { width: 0 } }, e, i, function () { k.parent && k.parent.remove(k) }) } function t7(i, e, k) { k.style.text = null; oS(k, { shape: { r: k.shape.r0 } }, e, i, function () { k.parent && k.parent.remove(k) }) } var kY = { cartesian2d: function (Z, e, k) { var v = Z.getItemLayout(e); var v1 = vs(k, v); var m = v.width > 0 ? 1 : -1; var i = v.height > 0 ? 1 : -1; return { x: v.x + m * v1 / 2, y: v.y + i * v1 / 2, width: v.width - m * v1, height: v.height - i * v1 } }, polar: function (m, e, i) { var k = m.getItemLayout(e); return { cx: k.cx, cy: k.cy, r0: k.r0, r: k.r, startAngle: k.startAngle, endAngle: k.endAngle } } }; function Bs(e, Z, Ik, Im, v1, k, Ij, In) { var m = Z.getItemVisual(Ik, "color"); var v2 = Z.getItemVisual(Ik, "opacity"); var v = Im.getModel("itemStyle"); var i = Im.getModel("emphasis.itemStyle").getBarItemStyle(); if (!In) { e.setShape("r", v.get("barBorderRadius") || 0) } e.useStyle(De({ fill: m, opacity: v2 }, v.getBarItemStyle())); var Il = Im.getShallow("cursor"); Il && e.attr("cursor", Il); var v3 = Ij ? (v1.height > 0 ? "bottom" : "top") : (v1.width > 0 ? "left" : "right"); if (!In) { EL(e.style, i, Im, m, k, Ik, v3) } yn(e, i) } function vs(i, k) { var e = i.get(Aq) || 0; return Math.min(e, Math.abs(k.width), Math.abs(k.height)) } var ai = mm.extend({ type: "largeBar", shape: { points: [] }, buildPath: function (e, m) { var Z = m.points; var v1 = this.__startPoint; var k = this.__valueIdx; for (var v = 0; v < Z.length; v += 2) { v1[this.__valueIdx] = Z[v + k]; e.moveTo(v1[0], v1[1]); e.lineTo(Z[v], Z[v + 1]) } } }); function Hv(i, v1, Z) { var v = i.getData(); var m = []; var e = v.getLayout("valueAxisHorizontal") ? 1 : 0; m[1 - e] = v.getLayout("valueAxisStart"); var k = new ai({ shape: { points: v.getLayout("largePoints") }, incremental: !!Z, __startPoint: m, __valueIdx: e }); v1.add(k); Gi(k, i, v) } function Gi(i, e, m) {
    var v = m.getVisual("borderColor") || m.getVisual("color"); var k = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]); i.useStyle(k); i.style.fill = null;
    i.style.stroke = v; i.style.lineWidth = m.getLayout("barWidth")
  } pr(sv(bA, "bar")); pr(Hn); G({ seriesType: "bar", reset: function (e) { e.getData().setVisual("legendSymbol", "roundRect") } }); var xi = function (e, i, Z) { i = GG(i) && { coordDimensions: i } || b0({}, i); var v = e.getSource(); var k = yw(v, i); var m = new xt(k, e); m.initData(v, Z); return m }; var EU = { updateSelectedMap: function (e) { this._targetList = GG(e) ? e.slice() : []; this._selectTargetMap = xc(e || [], function (i, k) { i.set(k.name, k); return i }, CJ()) }, select: function (e, m) { var i = m != null ? this._targetList[m] : this._selectTargetMap.get(e); var k = this.get("selectedMode"); if (k === "single") { this._selectTargetMap.each(function (v) { v.selected = false }) } i && (i.selected = true) }, unSelect: function (e, k) { var i = k != null ? this._targetList[k] : this._selectTargetMap.get(e); i && (i.selected = false) }, toggleSelected: function (e, k) { var i = k != null ? this._targetList[k] : this._selectTargetMap.get(e); if (i != null) { this[i.selected ? "unSelect" : "select"](e, k); return i.selected } }, isSelected: function (e, k) { var i = k != null ? this._targetList[k] : this._selectTargetMap.get(e); return i && i.selected } }; var y6 = B3({ type: "series.pie", init: function (e) { y6.superApply(this, "init", arguments); this.legendDataProvider = function () { return this.getRawData() }; this.updateSelectedMap(this._createSelectableList()); this._defaultLabelLine(e) }, mergeOption: function (e) { y6.superCall(this, "mergeOption", e); this.updateSelectedMap(this._createSelectableList()) }, getInitialData: function (i, e) { return xi(this, ["value"]) }, _createSelectableList: function () { var m = this.getRawData(); var Z = m.mapDimension("value"); var v = []; for (var k = 0, e = m.count(); k < e; k++) { v.push({ name: m.getName(k), value: m.get(Z, k), selected: Gz(m, k, "selected") }) } return v }, getDataParams: function (i) { var k = this.getData(); var m = y6.superCall(this, "getDataParams", i); var e = []; k.each(k.mapDimension("value"), function (v) { e.push(v) }); m.percent = au(e, i, k.hostModel.get("percentPrecision")); m.$vars.push("percent"); return m }, _defaultLabelLine: function (i) { DA(i, "labelLine", ["show"]); var e = i.labelLine; var k = i.emphasis.labelLine; e.show = e.show && i.label.show; k.show = k.show && i.emphasis.label.show }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: true, hoverAnimation: true, center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, minAngle: 0, selectedOffset: 10, hoverOffset: 10, avoidLabelOverlap: true, percentPrecision: 2, stillShowZeroSum: true, label: { rotate: false, show: true, position: "outer" }, labelLine: { show: true, length: 15, length2: 15, smooth: false, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1 }, animationType: "expansion", animationEasing: "cubicOut" } }); Gq(y6, EU); function wP(m, e, Z, v) { var v1 = e.getData(); var k = this.dataIndex; var i = v1.getName(k); var v2 = e.get("selectedOffset"); v.dispatchAction({ type: "pieToggleSelect", from: m, name: i, seriesId: e.id }); v1.each(function (v3) { BT(v1.getItemGraphicEl(v3), v1.getItemLayout(v3), e.isSelected(v1.getName(v3)), v2, Z) }) } function BT(i, v1, e, m, v2) { var k = (v1.startAngle + v1.endAngle) / 2; var Ij = Math.cos(k); var v3 = Math.sin(k); var v = e ? m : 0; var Z = [Ij * v, v3 * v]; v2 ? i.animate().when(200, { position: Z }).start("bounceOut") : i.attr("position", Z) } function H9(Z, k) { B8.call(this); var v = new tx({ z2: 2 }); var m = new z7(); var v1 = new iR(); this.add(v); this.add(m); this.add(v1); this.updateData(Z, k, true); function i() { m.ignore = m.hoverIgnore; v1.ignore = v1.hoverIgnore } function e() { m.ignore = m.normalIgnore; v1.ignore = v1.normalIgnore } this.on("emphasis", i).on("normal", e).on("mouseover", i).on("mouseout", e) } var ow = H9.prototype; ow.updateData = function (v, v3, v2) { var i = this.childAt(0); var k = v.hostModel; var Im = v.getItemModel(v3); var v1 = v.getItemLayout(v3); var Ik = b0({}, v1); Ik.label = null; if (v2) { i.setShape(Ik); var e = k.getShallow("animationType"); if (e === "scale") { i.shape.r = v1.r0; jC(i, { shape: { r: v1.r } }, k, v3) } else { i.shape.endAngle = v1.startAngle; oS(i, { shape: { endAngle: v1.endAngle } }, k, v3) } } else { oS(i, { shape: Ik }, k, v3) } var Ij = v.getItemVisual(v3, "color"); i.useStyle(De({ lineJoin: "bevel", fill: Ij }, Im.getModel("itemStyle").getItemStyle())); i.hoverStyle = Im.getModel("emphasis.itemStyle").getItemStyle(); var Il = Im.getShallow("cursor"); Il && i.attr("cursor", Il); BT(this, v.getItemLayout(v3), k.isSelected(null, v3), k.get("selectedOffset"), k.get("animation")); function m() { i.stopAnimation(true); i.animateTo({ shape: { r: v1.r + k.get("hoverOffset") } }, 300, "elasticOut") } function Z() { i.stopAnimation(true); i.animateTo({ shape: { r: v1.r } }, 300, "elasticOut") } i.off("mouseover").off("mouseout").off("emphasis").off("normal"); if (Im.get("hoverAnimation") && k.isAnimationEnabled()) { i.on("mouseover", m).on("mouseout", Z).on("emphasis", m).on("normal", Z) } this._updateLabel(v, v3); yn(this) }; ow._updateLabel = function (v1, Ij) {
    var Z = this.childAt(1); var k = this.childAt(2); var m = v1.hostModel; var Il = v1.getItemModel(Ij); var v3 = v1.getItemLayout(Ij); var In = v3.label; var Ik = v1.getItemVisual(Ij, "color"); oS(Z, { shape: { points: In.linePoints || [[In.x, In.y], [In.x, In.y], [In.x, In.y]] } }, m, Ij); oS(k, { style: { x: In.x, y: In.y } }, m, Ij); k.attr({ rotation: In.rotation, origin: [In.x, In.y], z2: 10 }); var Im = Il.getModel("label"); var v2 = Il.getModel("emphasis.label"); var v = Il.getModel("labelLine"); var i = Il.getModel("emphasis.labelLine");
    var Ik = v1.getItemVisual(Ij, "color"); BD(k.style, k.hoverStyle = {}, Im, v2, { labelFetcher: v1.hostModel, labelDataIndex: Ij, defaultText: v1.getName(Ij), autoColor: Ik, useInsideStyle: !!In.inside }, { textAlign: In.textAlign, textVerticalAlign: In.verticalAlign, opacity: v1.getItemVisual(Ij, "opacity") }); k.ignore = k.normalIgnore = !Im.get("show"); k.hoverIgnore = !v2.get("show"); Z.ignore = Z.normalIgnore = !v.get("show"); Z.hoverIgnore = !i.get("show"); Z.setStyle({ stroke: Ik, opacity: v1.getItemVisual(Ij, "opacity") }); Z.setStyle(v.getModel("lineStyle").getLineStyle()); Z.hoverStyle = i.getModel("lineStyle").getLineStyle(); var e = v.get("smooth"); if (e && e === true) { e = 0.4 } Z.setShape({ smooth: e })
  }; mr(H9, B8); var CZ = dF.extend({ type: "pie", init: function () { var e = new B8(); this._sectorGroup = e }, render: function (m, v1, v3, Il) { if (Il && (Il.from === this.uid)) { return } var v = m.getData(); var Z = this._data; var In = this.group; var v2 = v1.get("animation"); var Io = !Z; var k = m.get("animationType"); var i = sv(wP, this.uid, m, v2, v3); var Ik = m.get("selectedMode"); v.diff(Z).add(function (Ip) { var Iq = new H9(v, Ip); if (Io && k !== "scale") { Iq.eachChild(function (Ir) { Ir.stopAnimation(true) }) } Ik && Iq.on("click", i); v.setItemGraphicEl(Ip, Iq); In.add(Iq) }).update(function (Ir, Iq) { var Ip = Z.getItemGraphicEl(Iq); Ip.updateData(v, Ir); Ip.off("click"); Ik && Ip.on("click", i); In.add(Ip); v.setItemGraphicEl(Ir, Ip) }).remove(function (Ip) { var Iq = Z.getItemGraphicEl(Ip); In.remove(Iq) }).execute(); if (v2 && Io && v.count() > 0 && k !== "scale") { var Ij = v.getItemLayout(0); var e = Math.max(v3.getWidth(), v3.getHeight()) / 2; var Im = km(In.removeClipPath, In); In.setClipPath(this._createClipPath(Ij.cx, Ij.cy, e, Ij.startAngle, Ij.clockwise, Im, m)) } this._data = v }, dispose: function () { }, _createClipPath: function (i, v2, v1, v, m, e, k) { var Z = new tx({ shape: { cx: i, cy: v2, r0: 0, r: v1, startAngle: v, endAngle: v, clockwise: m } }); jC(Z, { shape: { endAngle: v + (m ? 1 : -1) * Math.PI * 2 } }, k, e); return Z }, containPoint: function (i, v) { var v1 = v.getData(); var Z = v1.getItemLayout(0); if (Z) { var m = i[0] - Z.cx; var k = i[1] - Z.cy; var e = Math.sqrt(m * m + k * k); return e <= Z.r && e >= Z.r0 } } }); var eZ = function (e, i) { o9(i, function (k) { k.update = "updateView"; b1(k, function (Z, m) { var v = {}; m.eachComponent({ mainType: "series", subType: e, query: Z }, function (v1) { if (v1[k.method]) { v1[k.method](Z.name, Z.dataIndex) } var v2 = v1.getData(); v2.each(function (v3) { var Ij = v2.getName(v3); v[Ij] = v1.isSelected(Ij) || false }) }); return { name: Z.name, selected: v } }) }) }; var eN = function (e) { return { getTargetSeries: function (i) { var m = {}; var k = CJ(); i.eachSeriesByType(e, function (v) { v.__paletteScope = m; k.set(v.uid, v) }); return k }, reset: function (k, i) { var Z = k.getRawData(); var v = {}; var m = k.getData(); m.each(function (v1) { var v2 = m.getRawIndex(v1); v[v2] = v1 }); Z.each(function (Ik) { var v2 = v[Ik]; var v3 = v2 != null && m.getItemVisual(v2, "color", true); if (!v3) { var Ij = Z.getItemModel(Ik); var v1 = Ij.get("itemStyle.color") || k.getColorFromPalette(Z.getName(Ik) || (Ik + ""), k.__paletteScope, Z.count()); Z.setItemVisual(Ik, "color", v1); if (v2 != null) { m.setItemVisual(v2, "color", v1) } } else { Z.setItemVisual(Ik, "color", v3) } }) } } }; function lR(Io, Ij, v3, e, v1, Il, v2) { Io.sort(function (Ir, i) { return Ir.y - i.y }); function Im(Iu, i, It, Is) { for (var Ir = Iu; Ir < i; Ir++) { Io[Ir].y += It; if (Ir > Iu && Ir + 1 < i && Io[Ir + 1].y > Io[Ir].y + Io[Ir].height) { Z(Ir, It / 2); return } } Z(i - 1, It / 2) } function Z(i, Is) { for (var Ir = i; Ir >= 0; Ir--) { Io[Ir].y -= Is; if (Ir > 0 && Io[Ir].y > Io[Ir - 1].y + Io[Ir - 1].height) { break } } } function Iq(IC, ID, Iz, Ix, Ir, Iv) { var Is = Iv > 0 ? ID ? Number.MAX_VALUE : 0 : ID ? Number.MAX_VALUE : 0; for (var IB = 0, Iw = IC.length; IB < Iw; IB++) { if (IC[IB].position === "center") { continue } var Iy = Math.abs(IC[IB].y - Ix); var Iu = IC[IB].len; var It = IC[IB].len2; var IA = (Iy < Ir + Iu) ? Math.sqrt((Ir + Iu + It) * (Ir + Iu + It) - Iy * Iy) : Math.abs(IC[IB].x - Iz); if (ID && IA >= Is) { IA = Is - 10 } if (!ID && IA <= Is) { IA = Is + 10 } IC[IB].x = Iz + IA * Iv; Is = IA } } var m = 0; var Ip; var In = Io.length; var k = []; var v = []; for (var Ik = 0; Ik < In; Ik++) { Ip = Io[Ik].y - m; if (Ip < 0) { Im(Ik, In, -Ip, v1) } m = Io[Ik].y + Io[Ik].height } if (v2 - m < 0) { Z(In - 1, m - v2) } for (var Ik = 0; Ik < In; Ik++) { if (Io[Ik].y >= v3) { v.push(Io[Ik]) } else { k.push(Io[Ik]) } } Iq(k, false, Ij, v3, e, v1); Iq(v, true, Ij, v3, e, v1) } function hf(Ij, Z, v, e, v3, m) { var v2 = []; var k = []; for (var v1 = 0; v1 < Ij.length; v1++) { if (Ij[v1].x < Z) { v2.push(Ij[v1]) } else { k.push(Ij[v1]) } } lR(k, Z, v, e, 1, v3, m); lR(v2, Z, v, e, -1, v3, m); for (var v1 = 0; v1 < Ij.length; v1++) { var Il = Ij[v1].linePoints; if (Il) { var Ik = Il[1][0] - Il[2][0]; if (Ij[v1].x < Z) { Il[2][0] = Ij[v1].x + 3 } else { Il[2][0] = Ij[v1].x - 3 } Il[1][1] = Il[2][1] = Ij[v1].y; Il[1][0] = Il[2][0] + Ik } } } var FX = function (m, e, v1, i) {
    var Z = m.getData(); var v2 = []; var v; var k; var v3 = false; Z.each(function (Iz) {
      var II = Z.getItemLayout(Iz); var IE = Z.getItemModel(Iz); var It = IE.getModel("label"); var Ij = It.get("position") || IE.get("emphasis.label.position"); var IC = IE.getModel("labelLine"); var Is = IC.get("length"); var Im = IC.get("length2"); var Iu = (II.startAngle + II.endAngle) / 2; var Iw = Math.cos(Iu); var Iv = Math.sin(Iu); var IB; var IA; var Ir; var Ip; v = II.cx; k = II.cy; var Iq = Ij === "inside" || Ij === "inner"; if (Ij === "center") { IB = II.cx; IA = II.cy; Ip = "center" } else {
        var IH = (Iq ? (II.r + II.r0) / 2 * Iw : II.r * Iw) + v; var Io = (Iq ? (II.r + II.r0) / 2 * Iv : II.r * Iv) + k; IB = IH + Iw * 3; IA = Io + Iv * 3; if (!Iq) {
          var IG = IH + Iw * (Is + e - II.r); var In = Io + Iv * (Is + e - II.r);
          var IF = IG + ((Iw < 0 ? -1 : 1) * Im); var Il = In; IB = IF + (Iw < 0 ? -5 : 5); IA = Il; Ir = [[IH, Io], [IG, In], [IF, Il]]
        } Ip = Iq ? "center" : (Iw > 0 ? "left" : "right")
      } var Iy = It.getFont(); var ID = It.get("rotate") ? (Iw < 0 ? -Iu + Math.PI : -Iu) : 0; var Ix = m.getFormattedLabel(Iz, "normal") || Z.getName(Iz); var Ik = Gr(Ix, Iy, Ip, "top"); v3 = !!ID; II.label = { x: IB, y: IA, position: Ij, height: Ik.height, len: Is, len2: Im, linePoints: Ir, textAlign: Ip, verticalAlign: "middle", rotation: ID, inside: Iq }; if (!Iq) { v2.push(II.label) }
    }); if (!v3 && m.get("avoidLabelOverlap")) { hf(v2, v, k, e, v1, i) }
  }; var GZ = Math.PI * 2; var xE = Math.PI / 180; var bd = function (i, e, k, m) { e.eachSeriesByType(i, function (It) { var ID = It.getData(); var v3 = ID.mapDimension("value"); var IC = It.get("center"); var Ij = It.get("radius"); if (!GG(Ij)) { Ij = [0, Ij] } if (!GG(IC)) { IC = [IC, IC] } var Iw = k.getWidth(); var Ip = k.getHeight(); var Io = Math.min(Iw, Ip); var v1 = zN(IC[0], Iw); var Z = zN(IC[1], Ip); var Iz = zN(Ij[0], Io / 2); var In = zN(Ij[1], Io / 2); var Iy = -It.get("startAngle") * xE; var Ix = It.get("minAngle") * xE; var Is = 0; ID.each(v3, function (IE) { !isNaN(IE) && Is++ }); var v = ID.getSum(v3); var Ir = Math.PI / (v || Is) * 2; var IA = It.get("clockwise"); var Iv = It.get("roseType"); var Ik = It.get("stillShowZeroSum"); var Il = ID.getDataExtent(v3); Il[0] = 0; var Iu = GZ; var v2 = 0; var Im = Iy; var Iq = IA ? 1 : -1; ID.each(v3, function (IG, IE) { var IH; if (isNaN(IG)) { ID.setItemLayout(IE, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: IA, cx: v1, cy: Z, r0: Iz, r: Iv ? NaN : In }); return } if (Iv !== "area") { IH = (v === 0 && Ik) ? Ir : (IG * Ir) } else { IH = GZ / Is } if (IH < Ix) { IH = Ix; Iu -= Ix } else { v2 += IG } var IF = Im + Iq * IH; ID.setItemLayout(IE, { angle: IH, startAngle: Im, endAngle: IF, clockwise: IA, cx: v1, cy: Z, r0: Iz, r: Iv ? EQ(IG, Il, [Iz, In]) : In }); Im = IF }); if (Iu < GZ && Is) { if (Iu <= 0.001) { var IB = GZ / Is; ID.each(v3, function (IG, IE) { if (!isNaN(IG)) { var IF = ID.getItemLayout(IE); IF.angle = IB; IF.startAngle = Iy + Iq * IE * IB; IF.endAngle = Iy + Iq * (IE + 1) * IB } }) } else { Ir = Iu / v2; Im = Iy; ID.each(v3, function (IG, IE) { if (!isNaN(IG)) { var IF = ID.getItemLayout(IE); var IH = IF.angle === Ix ? Ix : IG * Ir; IF.startAngle = Im; IF.endAngle = Im + Iq * IH; Im += Iq * IH } }) } } FX(It, In, Iw, Ip) }) }; var D7 = function (e) { return { seriesType: e, reset: function (m, i) { var k = i.findComponents({ mainType: "legend" }); if (!k || !k.length) { return } var v = m.getData(); v.filterSelf(function (Z) { var v1 = v.getName(Z); for (var v2 = 0; v2 < k.length; v2++) { if (!k[v2].isSelected(v1)) { return false } } return true }) } } }; eZ("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]); G(eN("pie")); pr(sv(bd, "pie")); eb(D7("pie")); nU.extend({ type: "series.scatter", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], getInitialData: function (i, e) { return a(this.getSource(), this) }, brushSelector: "point", getProgressive: function () { var e = this.option.progressive; if (e == null) { return this.option.large ? 5000 : this.get("progressive") } return e }, getProgressiveThreshold: function () { var e = this.option.progressiveThreshold; if (e == null) { return this.option.large ? 10000 : this.get("progressiveThreshold") } return e }, defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: true, hoverAnimation: true, symbolSize: 10, large: false, largeThreshold: 2000, itemStyle: { opacity: 0.8 } } }); var fJ = 4; var ji = Hw({ shape: { points: null }, symbolProxy: null, buildPath: function (Ik, k) { var v1 = k.points; var Il = k.size; var v2 = this.symbolProxy; var Z = v2.shape; var Ij = Ik.getContext ? Ik.getContext() : Ik; var v3 = Ij && Il[0] < fJ; if (v3) { return } for (var e = 0; e < v1.length;) { var v = v1[e++]; var m = v1[e++]; if (isNaN(v) || isNaN(m)) { continue } Z.x = v - Il[0] / 2; Z.y = m - Il[1] / 2; Z.width = Il[0]; Z.height = Il[1]; v2.buildPath(Ik, Z, true) } }, afterBrush: function (k) { var m = this.shape; var v2 = m.points; var v1 = m.size; var v = v1[0] < fJ; if (!v) { return } this.setTransform(k); for (var Z = 0; Z < v2.length;) { var e = v2[Z++]; var v3 = v2[Z++]; if (isNaN(e) || isNaN(v3)) { continue } k.fillRect(e - v1[0] / 2, v3 - v1[1] / 2, v1[0], v1[1]) } this.restoreTransform(k) }, findDataIndex: function (v1, Z) { var v = this.shape; var Ik = v.points; var Il = v.size; var v3 = Math.max(Il[0], 4); var m = Math.max(Il[1], 4); for (var Ij = Ik.length / 2 - 1; Ij >= 0; Ij--) { var k = Ij * 2; var e = Ik[k] - v3 / 2; var v2 = Ik[k + 1] - m / 2; if (v1 >= e && Z >= v2 && v1 <= e + v3 && Z <= v2 + m) { return Ij } } return -1 } }); function s1() { this.group = new B8() } var pX = s1.prototype; pX.isPersistent = function () { return !this._incremental }; pX.updateData = function (e) { this.group.removeAll(); var i = new ji({ rectHover: true, cursor: "default" }); i.setShape({ points: e.getLayout("symbolPoints") }); this._setCommon(i, e); this.group.add(i); this._incremental = null }; pX.updateLayout = function (i) { if (this._incremental) { return } var e = i.getLayout("symbolPoints"); this.group.eachChild(function (v) { if (v.startIndex != null) { var k = (v.endIndex - v.startIndex) * 2; var m = v.startIndex * 4 * 2; e = new Float32Array(e.buffer, m, k) } v.setShape("points", e) }) }; pX.incrementalPrepareUpdate = function (e) { this.group.removeAll(); this._clearIncremental(); if (e.count() > 2000000) { if (!this._incremental) { this._incremental = new zL({ silent: true }) } this.group.add(this._incremental) } else { this._incremental = null } }; pX.incrementalUpdate = function (i, e) {
    var k; if (this._incremental) {
      k = new ji(); this._incremental.addDisplayable(k, true)
    } else { k = new ji({ rectHover: true, cursor: "default", startIndex: i.start, endIndex: i.end }); k.incremental = true; this.group.add(k) } k.setShape({ points: e.getLayout("symbolPoints") }); this._setCommon(k, e, !!this._incremental)
  }; pX._setCommon = function (v1, v, i) { var Z = v.hostModel; var m = v.getVisual("symbolSize"); v1.setShape("size", (m instanceof Array) ? m : [m, m]); v1.symbolProxy = t9(v.getVisual("symbol"), 0, 0, 0, 0); v1.setColor = v1.symbolProxy.setColor; var e = v1.shape.size[0] < fJ; v1.useStyle(Z.getModel("itemStyle").getItemStyle(e ? ["color", "shadowBlur", "shadowColor"] : ["color"])); var k = v.getVisual("color"); if (k) { v1.setColor(k) } if (!i) { v1.seriesIndex = Z.seriesIndex; v1.on("mousemove", function (v3) { v1.dataIndex = null; var v2 = v1.findDataIndex(v3.offsetX, v3.offsetY); if (v2 >= 0) { v1.dataIndex = v2 + (v1.startIndex || 0) } }) } }; pX.remove = function () { this._clearIncremental(); this._incremental = null; this.group.removeAll() }; pX._clearIncremental = function () { var e = this._incremental; if (e) { e.clearDisplaybles() } }; BL({ type: "scatter", render: function (i, e, m) { var v = i.getData(); var k = this._updateSymbolDraw(v, i); k.updateData(v); this._finished = true }, incrementalPrepareRender: function (i, e, m) { var v = i.getData(); var k = this._updateSymbolDraw(v, i); k.incrementalPrepareUpdate(v); this._finished = false }, incrementalRender: function (k, i, e) { this._symbolDraw.incrementalUpdate(k, i.getData()); this._finished = k.end === i.getData().count() }, updateTransform: function (i, e, m) { var v = i.getData(); this.group.dirty(); if (!this._finished || v.count() > 10000 || !this._symbolDraw.isPersistent()) { return { update: true } } else { var k = qA().reset(i); if (k.progress) { k.progress({ start: 0, end: v.count() }, v) } this._symbolDraw.updateLayout(v) } }, _updateSymbolDraw: function (v, i) { var k = this._symbolDraw; var m = i.pipelineContext; var e = m.large; if (!k || e !== this._isLargeDraw) { k && k.remove(); k = this._symbolDraw = e ? new s1() : new E9(); this._isLargeDraw = e; this.group.removeAll() } this.group.add(k.group); return k }, remove: function (e, i) { this._symbolDraw && this._symbolDraw.remove(true); this._symbolDraw = null }, dispose: function () { } }); G(ml("scatter", "circle")); pr(qA("scatter")); function sF(i, k, e) { BS.call(this, i, k, e); this.type = "value"; this.angle = 0; this.name = ""; this.model } mr(sF, BS); function nH(k, e, i) { this._model = k; this.dimensions = []; this._indicatorAxes = Ef(k.getIndicatorModels(), function (Z, m) { var v1 = "indicator_" + m; var v = new sF(v1, new Cz()); v.name = Z.get("name"); v.model = Z; Z.axis = v; this.dimensions.push(v1); return v }, this); this.resize(k, i); this.cx; this.cy; this.r; this.r0; this.startAngle } nH.prototype.getIndicatorAxes = function () { return this._indicatorAxes }; nH.prototype.dataToPoint = function (k, i) { var e = this._indicatorAxes[i]; return this.coordToPoint(e.dataToCoord(k), i) }; nH.prototype.coordToPoint = function (Z, k) { var i = this._indicatorAxes[k]; var m = i.angle; var e = this.cx + Z * Math.cos(m); var v = this.cy - Z * Math.sin(m); return [e, v] }; nH.prototype.pointToData = function (Ik) { var Il = Ik[0] - this.cx; var Ij = Ik[1] - this.cy; var Z = Math.sqrt(Il * Il + Ij * Ij); Il /= Z; Ij /= Z; var v1 = Math.atan2(-Ij, Il); var v = Infinity; var k; var m = -1; for (var e = 0; e < this._indicatorAxes.length; e++) { var v3 = this._indicatorAxes[e]; var v2 = Math.abs(v1 - v3.angle); if (v2 < v) { k = v3; m = e; v = v2 } } return [m, +(k && k.coodToData(Z))] }; nH.prototype.resize = function (Z, v) { var i = Z.get("center"); var m = v.getWidth(); var k = v.getHeight(); var v1 = Math.min(m, k) / 2; this.cx = zN(i[0], m); this.cy = zN(i[1], k); this.startAngle = Z.get("startAngle") * Math.PI / 180; var e = Z.get("radius"); if (typeof e === "string" || typeof e === "number") { e = [0, e] } this.r0 = zN(e[0], v1); this.r = zN(e[1], v1); o9(this._indicatorAxes, function (v3, v2) { v3.setExtent(this.r0, this.r); var Ij = (this.startAngle + v2 * Math.PI * 2 / this._indicatorAxes.length); Ij = Math.atan2(Math.sin(Ij), Math.cos(Ij)); v3.angle = Ij }, this) }; nH.prototype.update = function (e, m) { var k = this._indicatorAxes; var v = this._model; o9(k, function (v1) { v1.scale.setExtent(Infinity, -Infinity) }); e.eachSeriesByType("radar", function (v3, v1) { if (v3.get("coordinateSystem") !== "radar" || e.getComponent("radar", v3.get("radarIndex")) !== v) { return } var v2 = v3.getData(); o9(k, function (Ij) { Ij.scale.unionExtentFromData(v2, v2.mapDimension(Ij.dim)) }) }, this); var Z = v.get("splitNumber"); function i(v2) { var v1 = Math.pow(10, Math.floor(Math.log(v2) / Math.LN10)); var v3 = v2 / v1; if (v3 === 2) { v3 = 5 } else { v3 *= 2 } return v3 * v1 } o9(k, function (Io, Ip) { var Im = FD(Io.scale, Io.model); nL(Io.scale, Io.model); var Ir = Io.model; var v3 = Io.scale; var Is = Ir.getMin(); var Ij = Ir.getMax(); var v2 = v3.getInterval(); if (Is != null && Ij != null) { v3.setExtent(+Is, +Ij); v3.setInterval((Ij - Is) / Z) } else { if (Is != null) { var In; do { In = Is + v2 * Z; v3.setExtent(+Is, In); v3.setInterval(v2); v2 = i(v2) } while (In < Im[1] && isFinite(In) && isFinite(Im[1])) } else { if (Ij != null) { var Il; do { Il = Ij - v2 * Z; v3.setExtent(Il, +Ij); v3.setInterval(v2); v2 = i(v2) } while (Il > Im[0] && isFinite(Il) && isFinite(Im[0])) } else { var Ik = v3.getTicks().length - 1; if (Ik > Z) { v2 = i(v2) } var v1 = Math.round((Im[0] + Im[1]) / 2 / v2) * v2; var Iq = Math.round(Z / 2); v3.setExtent(FM(v1 - Iq * v2), FM(v1 + (Z - Iq) * v2)); v3.setInterval(v2) } } } }) }; nH.dimensions = []; nH.create = function (e, k) {
    var i = []; e.eachComponent("radar", function (v) {
      var m = new nH(v, e, k); i.push(m); v.coordinateSystem = m
    }); e.eachSeriesByType("radar", function (m) { if (m.get("coordinateSystem") === "radar") { m.coordinateSystem = i[m.get("radarIndex") || 0] } }); return i
  }; fz.register("radar", nH); var r1 = bH.valueAxis; function zw(i, e) { return De({ show: e }, i) } var G6 = p2({ type: "radar", optionUpdated: function () { var v = this.get("boundaryGap"); var e = this.get("splitNumber"); var Z = this.get("scale"); var i = this.get("axisLine"); var v3 = this.get("axisTick"); var k = this.get("axisLabel"); var m = this.get("name"); var Il = this.get("name.show"); var Ij = this.get("name.formatter"); var v2 = this.get("nameGap"); var Ik = this.get("triggerEvent"); var v1 = Ef(this.get("indicator") || [], function (Im) { if (Im.max != null && Im.max > 0 && !Im.min) { Im.min = 0 } else { if (Im.min != null && Im.min < 0 && !Im.max) { Im.max = 0 } } var Ip = m; if (Im.color != null) { Ip = De({ color: Im.color }, m) } Im = v4(C5(Im), { boundaryGap: v, splitNumber: e, scale: Z, axisLine: i, axisTick: v3, axisLabel: k, name: Im.text, nameLocation: "end", nameGap: v2, nameTextStyle: Ip, triggerEvent: Ik }, false); if (!Il) { Im.name = "" } if (typeof Ij === "string") { var Io = Im.name; Im.name = Ij.replace("{value}", Io != null ? Io : "") } else { if (typeof Ij === "function") { Im.name = Ij(Im.name, Im) } } var In = b0(new fv(Im, null, this.ecModel), nB); In.mainType = "radar"; In.componentIndex = this.componentIndex; return In }, this); this.getIndicatorModels = function () { return v1 } }, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, name: { show: true }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: false, shape: "polygon", axisLine: v4({ lineStyle: { color: "#bbb" } }, r1.axisLine), axisLabel: zw(r1.axisLabel, false), axisTick: zw(r1.axisTick, false), splitLine: zw(r1.splitLine, true), splitArea: zw(r1.splitArea, true), indicator: [] } }); var ET = ["axisLine", "axisTickLabel", "axisName"]; qy({ type: "radar", render: function (k, e, i) { var m = this.group; m.removeAll(); this._buildAxes(k); this._buildSplitLineAndArea(k) }, _buildAxes: function (k) { var i = k.coordinateSystem; var e = i.getIndicatorAxes(); var m = Ef(e, function (v) { var Z = new da(v.model, { position: [i.cx, i.cy], rotation: v.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 }); return Z }); o9(m, function (v) { o9(ET, v.add, v); this.group.add(v.getGroup()) }, this) }, _buildSplitLineAndArea: function (Ij) { var Ir = Ij.coordinateSystem; var Ix = Ir.getIndicatorAxes(); if (!Ix.length) { return } var e = Ij.get("shape"); var IB = Ij.getModel("splitLine"); var It = Ij.getModel("splitArea"); var Io = IB.getModel("lineStyle"); var In = It.getModel("areaStyle"); var Iw = IB.get("show"); var Z = It.get("show"); var v2 = Io.get("color"); var Iy = In.get("color"); v2 = GG(v2) ? v2 : [v2]; Iy = GG(Iy) ? Iy : [Iy]; var Ip = []; var Iz = []; function Im(ID, IC, i) { var IE = i % IC.length; ID[IE] = ID[IE] || []; return IE } if (e === "circle") { var IA = Ix[0].getTicksCoords(); var v1 = Ir.cx; var k = Ir.cy; for (var Iv = 0; Iv < IA.length; Iv++) { if (Iw) { var v3 = Im(Ip, v2, Iv); Ip[v3].push(new GI({ shape: { cx: v1, cy: k, r: IA[Iv].coord } })) } if (Z && Iv < IA.length - 1) { var v3 = Im(Iz, Iy, Iv); Iz[v3].push(new r3({ shape: { cx: v1, cy: k, r0: IA[Iv].coord, r: IA[Iv + 1].coord } })) } } } else { var Il; var v = Ef(Ix, function (ID, i) { var IC = ID.getTicksCoords(); Il = Il == null ? IC.length - 1 : Math.min(IC.length - 1, Il); return Ef(IC, function (IE) { return Ir.coordToPoint(IE.coord, i) }) }); var Iq = []; for (var Iv = 0; Iv <= Il; Iv++) { var Iu = []; for (var Is = 0; Is < Ix.length; Is++) { Iu.push(v[Is][Iv]) } if (Iu[0]) { Iu.push(Iu[0].slice()) } else { if (ok) { console.error("Can't draw value axis " + Iv) } } if (Iw) { var v3 = Im(Ip, v2, Iv); Ip[v3].push(new z7({ shape: { points: Iu } })) } if (Z && Iq) { var v3 = Im(Iz, Iy, Iv - 1); Iz[v3].push(new ia({ shape: { points: Iu.concat(Iq) } })) } Iq = Iu.slice().reverse() } } var m = Io.getLineStyle(); var Ik = In.getAreaStyle(); o9(Iz, function (IC, i) { this.group.add(q8(IC, { style: De({ stroke: "none", fill: Iy[i % Iy.length] }, Ik), silent: true })) }, this); o9(Ip, function (IC, i) { this.group.add(q8(IC, { style: De({ fill: "none", stroke: v2[i % v2.length] }, m), silent: true })) }, this) } }); var oV = nU.extend({ type: "series.radar", dependencies: ["radar"], init: function (e) { oV.superApply(this, "init", arguments); this.legendDataProvider = function () { return this.getRawData() } }, getInitialData: function (i, e) { return xi(this, { generateCoord: "indicator_", generateCoordCount: Infinity }) }, formatTooltip: function (k) { var v = this.getData(); var i = this.coordinateSystem; var m = i.getIndicatorAxes(); var e = this.getData().getName(k); return mv(e === "" ? this.name : e) + "<br/>" + Ef(m, function (v1, Z) { var v2 = v.get(v.mapDimension(v1.dim), k); return mv(v1.name + " : " + v2) }).join("<br />") }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "radar", legendHoverLink: true, radarIndex: 0, lineStyle: { width: 2, type: "solid" }, label: { position: "top" }, symbol: "emptyCircle", symbolSize: 4 } }); function rc(e) { if (!GG(e)) { e = [+e, +e] } return e } BL({
    type: "radar", render: function (m, v2, v3) {
      var e = m.coordinateSystem; var Ij = this.group; var Z = m.getData(); var v1 = this._data; function i(Io, Il) { var Ip = Io.getItemVisual(Il, "symbol") || "circle"; var Im = Io.getItemVisual(Il, "color"); if (Ip === "none") { return } var In = rc(Io.getItemVisual(Il, "symbolSize")); var Ik = t9(Ip, -1, -1, 2, 2, Im); Ik.attr({ style: { strokeNoScale: true }, z2: 100, scale: [In[0] / 2, In[1] / 2] }); return Ik } function v(In, Io, Iq, Ip, Il, Ir) {
        Iq.removeAll(); for (var Im = 0; Im < Io.length - 1; Im++) {
          var Ik = i(Ip, Il); if (Ik) {
            Ik.__dimIdx = Im; if (In[Im]) {
              Ik.attr("position", In[Im]);
              yf[Ir ? "initProps" : "updateProps"](Ik, { position: Io[Im] }, m, Il)
            } else { Ik.attr("position", Io[Im]) } Iq.add(Ik)
          }
        }
      } function k(Ik) { return Ef(Ik, function (Il) { return [e.cx, e.cy] }) } Z.diff(v1).add(function (Ik) { var In = Z.getItemLayout(Ik); if (!In) { return } var Im = new ia(); var Il = new z7(); var Ip = { shape: { points: In } }; Im.shape.points = k(In); Il.shape.points = k(In); jC(Im, Ip, m, Ik); jC(Il, Ip, m, Ik); var Iq = new B8(); var Io = new B8(); Iq.add(Il); Iq.add(Im); Iq.add(Io); v(Il.shape.points, In, Io, Z, Ik, true); Z.setItemGraphicEl(Ik, Iq) }).update(function (In, Im) { var Iq = v1.getItemGraphicEl(Im); var Ik = Iq.childAt(0); var Il = Iq.childAt(1); var Ip = Iq.childAt(2); var Io = { shape: { points: Z.getItemLayout(In) } }; if (!Io.shape.points) { return } v(Ik.shape.points, Io.shape.points, Ip, Z, In, false); oS(Ik, Io, m); oS(Il, Io, m); Z.setItemGraphicEl(In, Iq) }).remove(function (Ik) { Ij.remove(v1.getItemGraphicEl(Ik)) }).execute(); Z.eachItemGraphicEl(function (Io, Iy) { var Iz = Z.getItemModel(Iy); var Iw = Io.childAt(0); var Iv = Io.childAt(1); var Il = Io.childAt(2); var Ip = Z.getItemVisual(Iy, "color"); Ij.add(Io); Iw.useStyle(De(Iz.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: Ip })); Iw.hoverStyle = Iz.getModel("emphasis.lineStyle").getLineStyle(); var Ix = Iz.getModel("areaStyle"); var It = Iz.getModel("emphasis.areaStyle"); var Im = Ix.isEmpty() && Ix.parentModel.isEmpty(); var Iu = It.isEmpty() && It.parentModel.isEmpty(); Iu = Iu && Im; Iv.ignore = Im; Iv.useStyle(De(Ix.getAreaStyle(), { fill: Ip, opacity: 0.7 })); Iv.hoverStyle = It.getAreaStyle(); var Is = Iz.getModel("itemStyle").getItemStyle(["color"]); var Ik = Iz.getModel("emphasis.itemStyle").getItemStyle(); var IA = Iz.getModel("label"); var Ir = Iz.getModel("emphasis.label"); Il.eachChild(function (IB) { IB.setStyle(Is); IB.hoverStyle = C5(Ik); BD(IB.style, IB.hoverStyle, IA, Ir, { labelFetcher: Z.hostModel, labelDataIndex: Iy, labelDimIndex: IB.__dimIdx, defaultText: Z.get(Z.dimensions[IB.__dimIdx], Iy), autoColor: Ip, isRectText: true }) }); function In() { Iv.attr("ignore", Iu) } function Iq() { Iv.attr("ignore", Im) } Io.off("mouseover").off("mouseout").off("normal").off("emphasis"); Io.on("emphasis", In).on("mouseover", In).on("normal", Iq).on("mouseout", Iq); yn(Io) }); this._data = Z
    }, remove: function () { this.group.removeAll(); this._data = null }, dispose: function () { }
  }); var Cm = function (e) { e.eachSeriesByType("radar", function (m) { var v2 = m.getData(); var v1 = []; var Z = m.coordinateSystem; if (!Z) { return } function k(Ij, i) { v1[i] = v1[i] || []; v1[i][v] = Z.dataToPoint(Ij, v) } var v3 = Z.getIndicatorAxes(); for (var v = 0; v < v3.length; v++) { v2.each(v2.mapDimension(v3[v].dim), k) } v2.each(function (i) { v1[i][0] && v1[i].push(v1[i][0].slice()); v2.setItemLayout(i, v1[i]) }) }) }; var kB = function (k) { var i = k.polar; if (i) { if (!GG(i)) { i = [i] } var e = []; o9(i, function (v, m) { if (v.indicator) { if (v.type && !v.shape) { v.shape = v.type } k.radar = k.radar || []; if (!GG(k.radar)) { k.radar = [k.radar] } k.radar.push(v) } else { e.push(v) } }); k.polar = e } o9(k.series, function (m) { if (m && m.type === "radar" && m.polarIndex) { m.radarIndex = m.polarIndex } }) }; G(eN("radar")); G(ml("radar", "circle")); pr(Cm); eb(D7("radar")); y2(kB); var zz = aY; function rC() { bJ.call(this) } Gq(rC, bJ); function Cl(e) { this.name = e; this.zoomLimit; bJ.call(this); this._roamTransformable = new rC(); this._rawTransformable = new rC(); this._center; this._zoom } Cl.prototype = {
    constructor: Cl, type: "view", dimensions: ["x", "y"], setBoundingRect: function (i, m, k, e) { this._rect = new CH(i, m, k, e); return this._rect }, getBoundingRect: function () { return this._rect }, setViewRect: function (i, m, k, e) { this.transformTo(i, m, k, e); this._viewRect = new CH(i, m, k, e) }, transformTo: function (i, Z, m, e) { var v = this.getBoundingRect(); var k = this._rawTransformable; k.transform = v.calculateTransform(new CH(i, Z, m, e)); k.decomposeTransform(); this._updateTransform() }, setCenter: function (e) { if (!e) { return } this._center = e; this._updateCenterAndZoom() }, setZoom: function (i) { i = i || 1; var e = this.zoomLimit; if (e) { if (e.max != null) { i = Math.min(e.max, i) } if (e.min != null) { i = Math.max(e.min, i) } } this._zoom = i; this._updateCenterAndZoom() }, getDefaultCenter: function () { var i = this.getBoundingRect(); var e = i.x + i.width / 2; var k = i.y + i.height / 2; return [e, k] }, getCenter: function () { return this._center || this.getDefaultCenter() }, getZoom: function () { return this._zoom || 1 }, getRoamTransform: function () { return this._roamTransformable.getLocalTransform() }, _updateCenterAndZoom: function () { var m = this._rawTransformable.getLocalTransform(); var i = this._roamTransformable; var v = this.getDefaultCenter(); var e = this.getCenter(); var k = this.getZoom(); e = aY([], e, m); v = aY([], v, m); i.origin = e; i.position = [v[0] - e[0], v[1] - e[1]]; i.scale = [k, k]; this._updateTransform() }, _updateTransform: function () { var e = this._roamTransformable; var i = this._rawTransformable; i.parent = e; e.updateTransform(); i.updateTransform(); zt(this.transform || (this.transform = []), i.transform || CB()); this._rawTransform = i.getLocalTransform(); this.invTransform = this.invTransform || []; fG(this.invTransform, this.transform); this.decomposeTransform() }, getViewRect: function () { return this._viewRect }, getViewRectAfterRoam: function () { var e = this.getBoundingRect().clone(); e.applyTransform(this.transform); return e }, dataToPoint: function (m, k, i) {
      var e = k ? this._rawTransform : this.transform;
      i = i || []; return e ? zz(i, m, e) : yI(i, m)
    }, pointToData: function (e) { var i = this.invTransform; return i ? zz([], e, i) : [e[0], e[1]] }, convertToPixel: sv(gM, "dataToPoint"), convertFromPixel: sv(gM, "pointToData"), containPoint: function (e) { return this.getViewRectAfterRoam().contain(e[0], e[1]) }
  }; Gq(Cl, bJ); function gM(k, e, Z, v) { var i = Z.seriesModel; var m = i ? i.coordinateSystem : null; return m === this ? m[k](v) : null } var gW = [126, 25]; var DM = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]]; for (var Af = 0; Af < DM.length; Af++) { for (var Hd = 0; Hd < DM[Af].length; Hd++) { DM[Af][Hd][0] /= 10.5; DM[Af][Hd][1] /= -10.5 / 0.75; DM[Af][Hd][0] += gW[0]; DM[Af][Hd][1] += gW[1] } } var oy = function (e, i) { if (e === "china") { i.push(new vT("", Ef(DM, function (k) { return { type: "polygon", exterior: k } }), gW)) } }; var kr = { "": [32, 80], "": [0, -10], "": [10, 5], "": [-10, 10], "": [5, 5] }; var bE = function (e, m) { if (e === "china") { var k = kr[m.name]; if (k) { var i = m.center; i[0] += k[0] / 10.5; i[1] += -k[1] / (10.5 / 0.75) } } }; var hB = { "Russia": [100, 60], "United States": [-99, 38], "United States of America": [-99, 38] }; var Hy = function (e, k) { if (e === "world") { var m = hB[k.name]; if (m) { var i = k.center; i[0] = m[0]; i[1] = m[1] } } }; var DL = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]]; var Gh = function (e, i) { if (e === "china" && i.name === "") { i.geometries.push({ type: "polygon", exterior: DL[0] }) } }; var hL = fK(); var bp = { load: function (k, m) { var i = hL(m).parsed; if (i) { return i } var v1 = m.specialAreas || {}; var Z = m.geoJSON; var v2; try { v2 = Z ? bK(Z) : [] } catch (v) { throw new Error("Invalid geoJson format\n" + v.message) } o9(v2, function (e) { var v3 = e.name; bE(k, e); Hy(k, e); Gh(k, e); var Ij = v1[v3]; if (Ij) { e.transformTo(Ij.left, Ij.top, Ij.width, Ij.height) } }); oy(k, v2); return (hL(m).parsed = { regions: v2, boundingRect: HE(v2) }) } }; function HE(v) { var m; for (var k = 0; k < v.length; k++) { var e = v[k].getBoundingRect(); m = m || e.clone(); m.union(e) } return m } var hK = fK(); var m7 = { load: function (e, k) { var i = hK(k).originRoot; if (i) { return { root: i, boundingRect: hK(k).boundingRect } } var m = rd(k); hK(k).originRoot = m.root; hK(k).boundingRect = m.boundingRect; return m }, makeGraphic: function (k, Z, v2) { var v1 = hK(Z); var v = v1.rootMap || (v1.rootMap = CJ()); var e = v.get(v2); if (e) { return e } var m = v1.originRoot; var i = v1.boundingRect; if (!v1.originRootHostKey) { v1.originRootHostKey = v2; e = m } else { e = rd(Z, i).root } return v.set(v2, e) }, removeGraphic: function (e, k, v) { var m = hK(k); var i = m.rootMap; i && i.removeKey(v); if (v === m.originRootHostKey) { m.originRootHostKey = null } } }; function rd(i, k) { var m = i.svgXML; var Il; var Ij; try { Il = m && D3(m, { ignoreViewBox: true, ignoreRootClip: true }) || {}; Ij = Il.root; bM(Ij != null) } catch (v2) { throw new Error("Invalid svg format\n" + v2.message) } var Ik = Il.width; var v1 = Il.height; var Z = Il.viewBoxRect; if (!k) { k = (Ik == null || v1 == null) ? Ij.getBoundingRect() : new CH(0, 0, 0, 0); if (Ik != null) { k.width = Ik } if (v1 != null) { k.height = v1 } } if (Z) { var v = AN(Z, k.width, k.height); var v3 = Ij; Ij = new B8(); Ij.add(v3); v3.scale = v.scale; v3.position = v.position } Ij.setClipPath(new EH({ shape: k.plain() })); return { root: Ij, boundingRect: k } } var zZ = { geoJSON: bp, svg: m7 }; var p = { load: function (m, Z) { var v1 = []; var v = CJ(); var e = CJ(); var k; var i = qp(m); o9(i, function (v2) { var v3 = zZ[v2.type].load(m, v2); o9(v3.regions, function (Ik) { var Il = Ik.name; if (Z && Z.hasOwnProperty(Il)) { Ik = Ik.cloneShallow(Il = Z[Il]) } v1.push(Ik); v.set(Il, Ik); e.set(Il, Ik.center) }); var Ij = v3.boundingRect; if (Ij) { k ? k.union(Ij) : (k = Ij.clone()) } }); return { regions: v1, regionsMap: v, nameCoordMap: e, boundingRect: k || new CH(0, 0, 0, 0) } }, makeGraphic: mQ("makeGraphic"), removeGraphic: mQ("removeGraphic") }; function mQ(e) { return function (m, v) { var i = qp(m); var k = []; o9(i, function (Z) { var v1 = zZ[Z.type][e]; v1 && k.push(v1(m, Z, v)) }); return k } } function ua(e) { if (ok) { console.error("Map " + e + " not exists. You can download map file on http://echarts.baidu.com/download-map.html") } } function qp(i) { var e = DS.retrieveMap(i) || []; if (ok) { if (!e.length) { ua(i) } } return e } function yU(e, i, m) { Cl.call(this, e); this.map = i; var k = p.load(i, m); this._nameCoordMap = k.nameCoordMap; this._regionsMap = k.nameCoordMap; this.regions = k.regions; this._rect = k.boundingRect } yU.prototype = {
    constructor: yU, type: "geo", dimensions: ["lng", "lat"], containCoord: function (m) { var k = this.regions; for (var e = 0; e < k.length; e++) { if (k[e].contain(m)) { return true } } return false }, transformTo: function (i, v2, k, e) {
      var v = this.getBoundingRect(); var m = this.invertLng; v = v.clone(); if (m) {
        v.y = -v.y - v.height
      } var v1 = this._rawTransformable; v1.transform = v.calculateTransform(new CH(i, v2, k, e)); v1.decomposeTransform(); if (m) { var Z = v1.scale; Z[1] = -Z[1] } v1.updateTransform(); this._updateTransform()
    }, getRegion: function (e) { return this._regionsMap.get(e) }, getRegionByCoord: function (m) { var k = this.regions; for (var e = 0; e < k.length; e++) { if (k[e].contain(m)) { return k[e] } } }, addGeoCoord: function (e, i) { this._nameCoordMap.set(e, i) }, getGeoCoord: function (e) { return this._nameCoordMap.get(e) }, getBoundingRect: function () { return this._rect }, dataToPoint: function (k, i, e) { if (typeof k === "string") { k = this.getGeoCoord(k) } if (k) { return Cl.prototype.dataToPoint.call(this, k, i, e) } }, convertToPixel: sv(kE, "dataToPoint"), convertFromPixel: sv(kE, "pointToData")
  }; Gq(yU, Cl); function kE(k, e, v1, Z) { var m = v1.geoModel; var i = v1.seriesModel; var v = m ? m.coordinateSystem : i ? (i.coordinateSystem || (i.getReferringComponents("geo")[0] || {}).coordinateSystem) : null; return v === this ? v[k](Z) : null } function gg(Ij, Ik) { var m = Ij.get("boundingCoords"); if (m != null) { var Z = m[0]; var v = m[1]; if (isNaN(Z[0]) || isNaN(Z[1]) || isNaN(v[0]) || isNaN(v[1])) { if (ok) { console.error("Invalid boundingCoords") } } else { this.setBoundingRect(Z[0], Z[1], v[0] - Z[0], v[1] - Z[1]) } } var Il = this.getBoundingRect(); var v1; var i = Ij.get("layoutCenter"); var In = Ij.get("layoutSize"); var v3 = Ik.getWidth(); var k = Ik.getHeight(); var e = Il.width / Il.height * this.aspectScale; var Im = false; if (i && In) { i = [zN(i[0], v3), zN(i[1], k)]; In = zN(In, Math.min(v3, k)); if (!isNaN(i[0]) && !isNaN(i[1]) && !isNaN(In)) { Im = true } else { if (ok) { console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.") } } } var v2; if (Im) { var v2 = {}; if (e > 1) { v2.width = In; v2.height = In / e } else { v2.height = In; v2.width = In * e } v2.y = i[1] - v2.height / 2; v2.x = i[0] - v2.width / 2 } else { v1 = Ij.getBoxLayoutParams(); v1.aspect = e; v2 = kV(v1, { width: v3, height: k }) } this.setViewRect(v2.x, v2.y, v2.width, v2.height); this.setCenter(Ij.get("center")); this.setZoom(Ij.get("zoom")) } function yH(i, e) { o9(e.get("geoCoord"), function (m, k) { i.addGeoCoord(k, m) }) } var h0 = { dimensions: yU.prototype.dimensions, create: function (e, m) { var k = []; e.eachComponent("geo", function (v2, v) { var v1 = v2.get("map"); var Ij = new yU(v1 + v, v1, v2.get("nameMap")); Ij.zoomLimit = v2.get("scaleLimit"); k.push(Ij); yH(Ij, v2); v2.coordinateSystem = Ij; Ij.model = v2; var Ik = v2.get("aspectScale"); var v3 = true; var Z = DS.retrieveMap(v1); if (Z && Z[0] && Z[0].type === "svg") { Ik == null && (Ik = 1); v3 = false } else { Ik == null && (Ik = 0.75) } Ij.aspectScale = Ik; Ij.invertLng = v3; Ij.resize = gg; Ij.resize(v2, m) }); e.eachSeries(function (v) { var v1 = v.get("coordinateSystem"); if (v1 === "geo") { var Z = v.get("geoIndex") || 0; v.coordinateSystem = k[Z] } }); var i = {}; e.eachSeriesByType("map", function (v) { if (!v.getHostGeoModel()) { var Z = v.getMapType(); i[Z] = i[Z] || []; i[Z].push(v) } }); o9(i, function (v2, v) { var v1 = Ef(v2, function (v3) { return v3.get("nameMap") }); var Z = new yU(v, v, aa(v1)); Z.zoomLimit = gu.apply(null, Ef(v2, function (v3) { return v3.get("scaleLimit") })); k.push(Z); Z.resize = gg; Z.resize(v2[0], m); o9(v2, function (v3) { v3.coordinateSystem = Z; yH(Z, v3) }) }); return k }, getFilledRegions: function (k, v, v2) { var e = (k || []).slice(); var v1 = CJ(); for (var m = 0; m < e.length; m++) { v1.set(e[m].name, e[m]) } var Z = p.load(v, v2); o9(Z.regions, function (v3) { var i = v3.name; !v1.get(i) && e.push({ name: i }) }); return e } }; wA("geo", h0); var k8 = nU.extend({ type: "series.map", dependencies: ["geo"], layoutMode: "box", needsDrawMap: false, seriesGroup: [], init: function (e) { k8.superApply(this, "init", arguments); this.updateSelectedMap(this._createSelectableList()) }, getInitialData: function (e) { return xi(this, ["value"]) }, mergeOption: function (e) { k8.superApply(this, "mergeOption", arguments); this.updateSelectedMap(this._createSelectableList()) }, _createSelectableList: function () { var m = this.getRawData(); var Z = m.mapDimension("value"); var v = []; for (var k = 0, e = m.count(); k < e; k++) { v.push({ name: m.getName(k), value: m.get(Z, k), selected: Gz(m, k, "selected") }) } v = h0.getFilledRegions(v, this.getMapType(), this.option.nameMap); return v }, getHostGeoModel: function () { var e = this.option.geoIndex; return e != null ? this.dependentModels.geo[e] : null }, getMapType: function () { return (this.getHostGeoModel() || this).option.map }, _fillOption: function (i, e) { }, getRawValue: function (e) { var i = this.getData(); return i.get(i.mapDimension("value"), e) }, getRegionModel: function (i) { var e = this.getData(); return e.getItemModel(e.indexOfName(i)) }, formatTooltip: function (Ij) { var m = this.getData(); var v = j7(this.getRawValue(Ij)); var e = m.getName(Ij); var v3 = this.seriesGroup; var v1 = []; for (var Z = 0; Z < v3.length; Z++) { var k = v3[Z].originalData.indexOfName(e); var v2 = m.mapDimension("value"); if (!isNaN(v3[Z].originalData.get(v2, k))) { v1.push(mv(v3[Z].name)) } } return v1.join(", ") + "<br />" + mv(e + " : " + v) }, getTooltipPosition: function (i) { if (i != null) { var e = this.getData().getName(i); var m = this.coordinateSystem; var k = m.getRegion(e); return k && m.dataToPoint(k.center) } }, setZoom: function (e) { this.option.zoom = e }, setCenter: function (e) { this.option.center = e }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: 0.75, showLegendSymbol: true, dataRangeHoverLink: true, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", areaColor: "#eee" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { areaColor: "rgba(255,215,0,0.8)" } } } });
  Gq(k8, EU); var jd = "\0_ec_interaction_mutex"; function hs(m, i, k) { var e = aZ(m); e[i] = k } function bl(v, k, m) { var i = aZ(v); var e = i[k]; if (e === m) { i[k] = null } } function iL(i, e) { return !!aZ(i)[e] } function aZ(e) { return e[jd] || (e[jd] = {}) } b1({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, function () { }); function ad(v) { this.pointerChecker; this._zr = v; this._opt = {}; var k = km; var Z = k(EI, this); var v1 = k(ux, this); var m = k(zq, this); var i = k(aE, this); var e = k(He, this); Gc.call(this); this.setPointerChecker = function (v2) { this.pointerChecker = v2 }; this.enable = function (v3, v2) { this.disable(); this._opt = De(C5(v2) || {}, { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true }); if (v3 == null) { v3 = true } if (v3 === true || (v3 === "move" || v3 === "pan")) { v.on("mousedown", Z); v.on("mousemove", v1); v.on("mouseup", m) } if (v3 === true || (v3 === "scale" || v3 === "zoom")) { v.on("mousewheel", i); v.on("pinch", e) } }; this.disable = function () { v.off("mousedown", Z); v.off("mousemove", v1); v.off("mouseup", m); v.off("mousewheel", i); v.off("pinch", e) }; this.dispose = this.disable; this.isDragging = function () { return this._dragging }; this.isPinching = function () { return this._pinching } } Gq(ad, Gc); function EI(k) { if (dQ(k) || (k.target && k.target.draggable)) { return } var i = k.offsetX; var m = k.offsetY; if (this.pointerChecker && this.pointerChecker(k, i, m)) { this._x = i; this._y = m; this._dragging = true } } function ux(v1) { if (dQ(v1) || !cy("moveOnMouseMove", v1, this._opt) || !this._dragging || v1.gestureEvent === "pinch" || iL(this._zr, "globalPan")) { return } var i = v1.offsetX; var v2 = v1.offsetY; var Z = this._x; var v = this._y; var m = i - Z; var k = v2 - v; this._x = i; this._y = v2; this._opt.preventDefaultMouseMove && GP(v1.event); E7(this, "pan", "moveOnMouseMove", v1, { dx: m, dy: k, oldX: Z, oldY: v, newX: i, newY: v2 }) } function zq(i) { if (!dQ(i)) { this._dragging = false } } function aE(v1) { var v = cy("zoomOnMouseWheel", v1, this._opt); var v3 = cy("moveOnMouseWheel", v1, this._opt); var k = v1.wheelDelta; var Ij = Math.abs(k); var Il = v1.offsetX; var Ik = v1.offsetY; if (k === 0 || (!v && !v3)) { return } if (v) { var v2 = Ij > 3 ? 1.4 : Ij > 1 ? 1.2 : 1.1; var m = k > 0 ? v2 : 1 / v2; jP(this, "zoom", "zoomOnMouseWheel", v1, { scale: m, originX: Il, originY: Ik }) } if (v3) { var Z = Math.abs(k); var i = (k > 0 ? 1 : -1) * (Z > 3 ? 0.4 : Z > 1 ? 0.15 : 0.05); jP(this, "scrollMove", "moveOnMouseWheel", v1, { scrollDelta: i, originX: Il, originY: Ik }) } } function He(i) { if (iL(this._zr, "globalPan")) { return } var k = i.pinchScale > 1 ? 1.1 : 1 / 1.1; jP(this, "zoom", null, i, { scale: k, originX: i.pinchX, originY: i.pinchY }) } function jP(i, k, v, Z, m) { if (i.pointerChecker && i.pointerChecker(Z, m.originX, m.originY)) { GP(Z.event); E7(i, k, v, Z, m) } } function E7(i, k, v, Z, m) { m.isAvailableBehavior = km(cy, null, v, Z); i.trigger(k, m) } function cy(m, v, k) { var i = k[m]; return !m || (i && (!wb(i) || v.event[i + "Key"])) } function FR(v, i, e) { var k = v.target; var m = k.position; m[0] += i; m[1] += e; k.dirty() } function zE(Il, e, Ik, v3) { var v1 = Il.target; var Z = Il.zoomLimit; var v2 = v1.position; var i = v1.scale; var v = Il.zoom = Il.zoom || 1; v *= e; if (Z) { var k = Z.min || 0; var Ij = Z.max || Infinity; v = Math.max(Math.min(Ij, v), k) } var m = v / Il.zoom; Il.zoom = v; v2[0] -= (Ik - v2[0]) * (m - 1); v2[1] -= (v3 - v2[1]) * (m - 1); i[0] *= m; i[1] *= m; v1.dirty() } var eL = { "axisPointer": 1, "tooltip": 1, "brush": 1 }; function CS(Z, v, i) { var k = v.getComponentByElement(Z.topTarget); var m = k && k.coordinateSystem; return k && k !== i && !eL[k.mainType] && (m && m.model !== i) } function jR(i, m) { var k = i.getItemStyle(); var e = i.get("areaColor"); if (e != null) { k.fill = e } return k } function fa(k, e, v, m, i) { v.off("click"); v.off("mousedown"); if (e.get("selectedMode")) { v.on("mousedown", function () { k._mouseDownFlag = true }); v.on("click", function (v2) { if (!k._mouseDownFlag) { return } k._mouseDownFlag = false; var Z = v2.target; while (!Z.__regions) { Z = Z.parent } if (!Z) { return } var v1 = { type: (e.mainType === "geo" ? "geo" : "map") + "ToggleSelect", batch: Ef(Z.__regions, function (v3) { return { name: v3.name, from: i.uid } }) }; v1[e.mainType + "Id"] = e.id; m.dispatchAction(v1); e8(e, v) }) } } function e8(e, i) { i.eachChild(function (k) { o9(k.__regions, function (m) { k.trigger(e.isSelected(m.name) ? "emphasis" : "normal") }) }) } function Cj(i, e) { var k = new B8(); this.uid = l8("ec_map_draw"); this._controller = new ad(i.getZr()); this._controllerHost = { target: e ? k : null }; this.group = k; this._updateGroup = e; this._mouseDownFlag; this._mapName; this._initialized; k.add(this._regionsGroup = new B8()); k.add(this._backgroundGroup = new B8()) } Cj.prototype = {
    constructor: Cj, draw: function (Il, v2, v3, k, Ik) {
      var v = Il.mainType === "geo"; var v1 = Il.getData && Il.getData(); v && v2.eachComponent({ mainType: "series", subType: "map" }, function (Ir) { if (!v1 && Ir.getHostGeoModel() === Il) { v1 = Ir.getData() } }); var Z = Il.coordinateSystem; this._updateBackground(Z); var In = this._regionsGroup; var Im = this.group; var m = Z.scale; var i = { position: Z.position, scale: m }; if (!In.childAt(0) || Ik) { Im.attr(i) } else { oS(Im, i, Il) } In.removeAll(); var Io = ["itemStyle"]; var Iq = ["emphasis", "itemStyle"]; var e = ["label"]; var Ip = ["emphasis", "label"]; var Ij = CJ(); o9(Z.regions, function (Iw) {
        var It = Ij.get(Iw.name) || Ij.set(Iw.name, new B8()); var ID = new jr({ shape: { paths: [] } }); It.add(ID); var II = Il.getRegionModel(Iw.name) || Il; var Is = II.getModel(Io); var Ir = II.getModel(Iq); var IA = jR(Is, m); var Iu = jR(Ir, m); var IC = II.getModel(e);
        var IE = II.getModel(Ip); var IF; if (v1) { IF = v1.indexOfName(Iw.name); var Ix = v1.getItemVisual(IF, "color", true); if (Ix) { IA.fill = Ix } } o9(Iw.geometries, function (IM) { if (IM.type !== "polygon") { return } ID.shape.paths.push(new ia({ shape: { points: IM.exterior } })); for (var IL = 0; IL < (IM.interiors ? IM.interiors.length : 0); IL++) { ID.shape.paths.push(new ia({ shape: { points: IM.interiors[IL] } })) } }); ID.setStyle(IA); ID.style.strokeNoScale = true; ID.culling = true; var IH = IC.get("show"); var Iv = IE.get("show"); var IB = v1 && isNaN(v1.get(v1.mapDimension("value"), IF)); var IJ = v1 && v1.getItemLayout(IF); if ((v || IB && (IH || Iv)) || (IJ && IJ.showLabel)) { var Iy = !v ? IF : Iw.name; var IK; if (!v1 || IF >= 0) { IK = Il } var IG = new iR({ position: Iw.center.slice(), scale: [1 / m[0], 1 / m[1]], z2: 10, silent: true }); BD(IG.style, IG.hoverStyle = {}, IC, IE, { labelFetcher: IK, labelDataIndex: Iy, defaultText: Iw.name, useInsideStyle: false }, { textAlign: "center", textVerticalAlign: "middle" }); It.add(IG) } if (v1) { v1.setItemGraphicEl(IF, It) } else { var II = Il.getRegionModel(Iw.name); ID.eventData = { componentType: "geo", geoIndex: Il.componentIndex, name: Iw.name, region: (II && II.option) || {} } } var Iz = It.__regions || (It.__regions = []); Iz.push(Iw); yn(It, Iu, { hoverSilentOnTouch: !!Il.get("selectedMode") }); In.add(It)
      }); this._updateController(Il, v2, v3); fa(this, Il, In, v3, k); e8(Il, In)
    }, remove: function () { this._regionsGroup.removeAll(); this._backgroundGroup.removeAll(); this._controller.dispose(); this._mapName && p.removeGraphic(this._mapName, this.uid); this._mapName = null; this._controllerHost = {} }, _updateBackground: function (i) { var e = i.map; if (this._mapName !== e) { o9(p.makeGraphic(e, this.uid), function (k) { this._backgroundGroup.add(k) }, this) } this._mapName = e }, _updateController: function (i, e, v) { var Z = i.coordinateSystem; var k = this._controller; var v2 = this._controllerHost; v2.zoomLimit = i.get("scaleLimit"); v2.zoom = Z.getZoom(); k.enable(i.get("roam") || false); var v1 = i.mainType; function m() { var v3 = { type: "geoRoam", componentType: v1 }; v3[v1 + "Id"] = i.id; return v3 } k.off("pan").on("pan", function (v3) { this._mouseDownFlag = false; FR(v2, v3.dx, v3.dy); v.dispatchAction(b0(m(), { dx: v3.dx, dy: v3.dy })) }, this); k.off("zoom").on("zoom", function (v3) { this._mouseDownFlag = false; zE(v2, v3.scale, v3.originX, v3.originY); v.dispatchAction(b0(m(), { zoom: v3.scale, originX: v3.originX, originY: v3.originY })); if (this._updateGroup) { var Ij = this.group.scale; this._regionsGroup.traverse(function (Ik) { if (Ik.type === "text") { Ik.attr("scale", [1 / Ij[0], 1 / Ij[1]]) } }) } }, this); k.setPointerChecker(function (Ij, v3, Ik) { return Z.getViewRectAfterRoam().contain(v3, Ik) && !CS(Ij, v, i) }) }
  }; BL({ type: "map", render: function (i, e, m, Z) { if (Z && Z.type === "mapToggleSelect" && Z.from === this.uid) { return } var v = this.group; v.removeAll(); if (i.getHostGeoModel()) { return } if (!(Z && Z.type === "geoRoam" && Z.componentType === "series" && Z.seriesId === i.id)) { if (i.needsDrawMap) { var k = this._mapDraw || new Cj(m, true); v.add(k.group); k.draw(i, e, m, this, Z); this._mapDraw = k } else { this._mapDraw && this._mapDraw.remove(); this._mapDraw = null } } else { var k = this._mapDraw; k && v.add(k.group) } i.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(i, e, m) }, remove: function () { this._mapDraw && this._mapDraw.remove(); this._mapDraw = null; this.group.removeAll() }, dispose: function () { this._mapDraw && this._mapDraw.remove(); this._mapDraw = null }, _renderSymbols: function (i, e, k) { var m = i.originalData; var v = this.group; m.each(m.mapDimension("value"), function (Iq, Ir) { if (isNaN(Iq)) { return } var In = m.getItemLayout(Ir); if (!In || !In.point) { return } var Is = In.point; var Ik = In.offset; var Z = new GI({ style: { fill: i.getData().getVisual("color") }, shape: { cx: Is[0] + Ik * 9, cy: Is[1], r: 3 }, silent: true, z2: !Ik ? 10 : 8 }); if (!Ik) { var Io = i.mainSeries.getData(); var v1 = m.getName(Ir); var v3 = Io.indexOfName(v1); var Iu = m.getItemModel(Ir); var Iv = Iu.getModel("label"); var Ip = Iu.getModel("emphasis.label"); var It = Io.getItemGraphicEl(v3); var Im = kb(i.getFormattedLabel(Ir, "normal"), v1); var v2 = kb(i.getFormattedLabel(Ir, "emphasis"), Im); var Ij = function () { var Iw = pe({}, Ip, { text: Ip.get("show") ? v2 : null }, { isRectText: true, useInsideStyle: false }, true); Z.style.extendFrom(Iw); Z.__mapOriginalZ2 = Z.z2; Z.z2 += 1 }; var Il = function () { pe(Z.style, Iv, { text: Iv.get("show") ? Im : null, textPosition: Iv.getShallow("position") || "bottom" }, { isRectText: true, useInsideStyle: false }); if (Z.__mapOriginalZ2 != null) { Z.z2 = Z.__mapOriginalZ2; Z.__mapOriginalZ2 = null } }; It.on("mouseover", Ij).on("mouseout", Il).on("emphasis", Ij).on("normal", Il); Il() } v.add(Z) }) } }); function bD(v2, Ij, v) { var i = v2.getZoom(); var e = v2.getCenter(); var Il = Ij.zoom; var Ik = v2.dataToPoint(e); if (Ij.dx != null && Ij.dy != null) { Ik[0] -= Ij.dx; Ik[1] -= Ij.dy; var e = v2.pointToData(Ik); v2.setCenter(e) } if (Il != null) { if (v) { var m = v.min || 0; var v3 = v.max || Infinity; Il = Math.max(Math.min(i * Il, v3), m) / i } v2.scale[0] *= Il; v2.scale[1] *= Il; var k = v2.position; var v1 = (Ij.originX - k[0]) * (Il - 1); var Z = (Ij.originY - k[1]) * (Il - 1); k[0] -= v1; k[1] -= Z; v2.updateTransform(); var e = v2.pointToData(Ik); v2.setCenter(e); v2.setZoom(Il * i) } return { center: v2.getCenter(), zoom: v2.getZoom() } } b1({ type: "geoRoam", event: "geoRoam", update: "updateTransform" }, function (k, e) {
    var i = k.componentType || "series"; e.eachComponent({ mainType: i, query: k }, function (m) {
      var Z = m.coordinateSystem;
      if (Z.type !== "geo") { return } var v = bD(Z, k, m.get("scaleLimit")); m.setCenter && m.setCenter(v.center); m.setZoom && m.setZoom(v.zoom); if (i === "series") { o9(m.seriesGroup, function (v1) { v1.setCenter(v.center); v1.setZoom(v.zoom) }) }
    })
  }); var GV = function (e) { var i = {}; e.eachSeriesByType("map", function (Z) { var m = Z.getMapType(); if (Z.getHostGeoModel() || i[m]) { return } var v = {}; o9(Z.seriesGroup, function (v2) { var v3 = v2.coordinateSystem; var v1 = v2.originalData; if (v2.get("showLegendSymbol") && e.getComponent("legend")) { v1.each(v1.mapDimension("value"), function (Im, Ik) { var Il = v1.getName(Ik); var In = v3.getRegion(Il); if (!In || isNaN(Im)) { return } var Io = v[Il] || 0; var Ij = v3.dataToPoint(In.center); v[Il] = Io + 1; v1.setItemLayout(Ik, { point: Ij, offset: Io }) }) } }); var k = Z.getData(); k.each(function (v1) { var v2 = k.getName(v1); var v3 = k.getItemLayout(v1) || {}; v3.showLabel = !v[v2]; k.setItemLayout(v1, v3) }); i[m] = true }) }; var gU = function (e) { e.eachSeriesByType("map", function (m) { var v = m.get("color"); var Z = m.getModel("itemStyle"); var i = Z.get("areaColor"); var k = Z.get("color") || v[m.seriesIndex % v.length]; m.getData().setVisual({ "areaColor": i, "color": k }) }) }; function pF(e, k) { var i = {}; o9(e, function (m) { m.each(m.mapDimension("value"), function (v1, v) { var Z = "ec-" + m.getName(v); i[Z] = i[Z] || []; if (!isNaN(v1)) { i[Z].push(v1) } }) }); return e[0].map(e[0].mapDimension("value"), function (Ij, Ik) { var v2 = "ec-" + e[0].getName(Ik); var Z = 0; var m = Infinity; var v3 = -Infinity; var v1 = i[v2].length; for (var v = 0; v < v1; v++) { m = Math.min(m, i[v2][v]); v3 = Math.max(v3, i[v2][v]); Z += i[v2][v] } var Il; if (k === "min") { Il = m } else { if (k === "max") { Il = v3 } else { if (k === "average") { Il = Z / v1 } else { Il = Z } } } return v1 === 0 ? NaN : Il }) } var es = function (e) { var i = {}; e.eachSeriesByType("map", function (k) { var v = k.getHostGeoModel(); var m = v ? "o" + v.id : "i" + k.getMapType(); (i[m] = i[m] || []).push(k) }); o9(i, function (v, m) { var Z = pF(Ef(v, function (v1) { return v1.getData() }), v[0].get("mapValueCalculation")); for (var k = 0; k < v.length; k++) { v[k].originalData = v[k].getData() } for (var k = 0; k < v.length; k++) { v[k].seriesGroup = v; v[k].needsDrawMap = k === 0 && !v[k].getHostGeoModel(); v[k].setData(Z.cloneShallow()); v[k].mainSeries = v[0] } }) }; var ky = function (e) { var i = []; o9(e.series, function (k) { if (k && k.type === "map") { i.push(k); k.map = k.map || k.mapType; De(k, k.mapLocation) } }) }; pr(GV); G(gU); eb(B6.PROCESSOR.STATISTIC, es); y2(ky); eZ("map", [{ type: "mapToggleSelect", event: "mapselectchanged", method: "toggleSelected" }, { type: "mapSelect", event: "mapselected", method: "select" }, { type: "mapUnSelect", event: "mapunselected", method: "unSelect" }]); var o0 = o9; var jD = "\0__link_datas"; var tn = "\0__link_mainData"; function BK(k) { var i = k.mainData; var e = k.datas; if (!e) { e = { main: i }; k.datasAttr = { main: "data" } } k.datas = k.mainData = null; jh(i, e, k); o0(e, function (m) { o0(i.TRANSFERABLE_METHODS, function (v) { m.wrapMethod(v, sv(HV, k)) }) }); i.wrapMethod("cloneShallow", sv(qK, k)); o0(i.CHANGABLE_METHODS, function (m) { i.wrapMethod(m, sv(GC, k)) }); bM(e[i.dataType] === i) } function HV(k, i) { if (mh(this)) { var e = b0({}, this[jD]); e[this.dataType] = i; jh(i, e, k) } else { jm(i, this.dataType, this[tn], k) } return i } function GC(i, e) { i.struct && i.struct.update(this); return e } function qK(i, e) { o0(e[jD], function (m, k) { m !== e && jm(m.cloneShallow(), k, e, i) }); return e } function p7(i) { var e = this[tn]; return (i == null || e == null) ? e : e[jD][i] } function mh(e) { return e[tn] === e } function jh(i, e, k) { i[jD] = {}; o0(e, function (v, m) { jm(v, m, i, k) }) } function jm(m, i, e, k) { e[jD][i] = m; m[tn] = e; m.dataType = i; if (k.struct) { m[k.structAttr] = k.struct; k.struct[k.datasAttr[i]] = m } m.getLinkedData = p7 } var kq = function (e, i) { this.name = e || ""; this.depth = 0; this.height = 0; this.parentNode = null; this.dataIndex = -1; this.children = []; this.viewChildren = []; this.hostTree = i }; kq.prototype = {
    constructor: kq, isRemoved: function () { return this.dataIndex < 0 }, eachNode: function (v, k, v2) { if (typeof v === "function") { v2 = k; k = v; v = null } v = v || {}; if (wb(v)) { v = { order: v } } var e = v.order || "preorder"; var v1 = this[v.attr || "children"]; var m; e === "preorder" && (m = k.call(v2, this)); for (var Z = 0; !m && Z < v1.length; Z++) { v1[Z].eachNode(v, k, v2) } e === "postorder" && k.call(v2, this) }, updateDepthAndHeight: function (m) { var e = 0; this.depth = m; for (var k = 0; k < this.children.length; k++) { var v = this.children[k]; v.updateDepthAndHeight(m + 1); if (v.height > e) { e = v.height } } this.height = e + 1 }, getNodeById: function (Z) { if (this.getId() === Z) { return this } for (var v = 0, m = this.children, e = m.length; v < e; v++) { var k = m[v].getNodeById(Z); if (k) { return k } } }, contains: function (Z) { if (Z === this) { return true } for (var v = 0, m = this.children, e = m.length; v < e; v++) { var k = m[v].contains(Z); if (k) { return k } } }, getAncestors: function (e) { var i = []; var k = e ? this : this.parentNode; while (k) { i.push(k); k = k.parentNode } i.reverse(); return i }, getValue: function (i) { var e = this.hostTree.data; return e.get(e.getDimension(i || "value"), this.dataIndex) }, setLayout: function (i, e) { this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, i, e) }, getLayout: function () { return this.hostTree.data.getItemLayout(this.dataIndex) }, getModel: function (m) {
      if (this.dataIndex < 0) { return } var k = this.hostTree; var e = k.data.getItemModel(this.dataIndex); var v = this.getLevelModel(); var i; if (!v && (this.children.length === 0 || (this.children.length !== 0 && this.isExpand === false))) {
        i = this.getLeavesModel()
      } return e.getModel(m, (v || i || k.hostModel).getModel(m))
    }, getLevelModel: function () { return (this.hostTree.levelModels || [])[this.depth] }, getLeavesModel: function () { return this.hostTree.leavesModel }, setVisual: function (e, i) { this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, i) }, getVisual: function (i, e) { return this.hostTree.data.getItemVisual(this.dataIndex, i, e) }, getRawIndex: function () { return this.hostTree.data.getRawIndex(this.dataIndex) }, getId: function () { return this.hostTree.data.getId(this.dataIndex) }, isAncestorOf: function (i) { var e = i.parentNode; while (e) { if (e === this) { return true } e = e.parentNode } return false }, isDescendantOf: function (e) { return e !== this && e.isAncestorOf(this) }
  }; function nA(i, k, e) { this.root; this.data; this._nodes = []; this.hostModel = i; this.levelModels = Ef(k || [], function (m) { return new fv(m, i, i.ecModel) }); this.leavesModel = new fv(e || {}, i, i.ecModel) } nA.prototype = { constructor: nA, type: "tree", eachNode: function (i, e, k) { this.root.eachNode(i, e, k) }, getNodeByDataIndex: function (i) { var e = this.data.getRawIndex(i); return this._nodes[e] }, getNodeByName: function (e) { return this.root.getNodeByName(e) }, update: function () { var v = this.data; var k = this._nodes; for (var m = 0, e = k.length; m < e; m++) { k[m].dataIndex = -1 } for (var m = 0, e = v.count(); m < e; m++) { k[v.getRawIndex(m)].dataIndex = m } }, clearLayouts: function () { this.data.clearItemLayouts() } }; nA.createTree = function (v1, k, Z) { var v3 = new nA(k, Z.levels, Z.leaves); var m = []; var v2 = 1; i(v1); function i(Ik, Ij) { var Io = Ik.value; v2 = Math.max(v2, GG(Io) ? Io.length : 1); m.push(Ik); var In = new kq(Ik.name, v3); Ij ? bi(In, Ij) : (v3.root = In); v3._nodes.push(In); var Im = Ik.children; if (Im) { for (var Il = 0; Il < Im.length; Il++) { i(Im[Il], In) } } } v3.root.updateDepthAndHeight(0); var e = yw(m, { coordDimensions: ["value"], dimensionsCount: v2 }); var v = new xt(e, k); v.initData(m); BK({ mainData: v, struct: v3, structAttr: "tree" }); v3.update(); return v3 }; function bi(k, i) { var e = i.children; if (k.parentNode === i) { return } e.push(k); k.parentNode = i } nU.extend({ type: "series.tree", layoutInfo: null, layoutMode: "box", getInitialData: function (Z) { var i = { name: Z.name, children: Z.data }; var v2 = Z.leaves || {}; var m = {}; m.leaves = v2; var e = nA.createTree(i, this, m); var k = 0; e.eachNode("preorder", function (v3) { if (v3.depth > k) { k = v3.depth } }); var v1 = Z.expandAndCollapse; var v = (v1 && Z.initialTreeDepth >= 0) ? Z.initialTreeDepth : k; e.root.eachNode("preorder", function (Ij) { var v3 = Ij.hostTree.data.getRawDataItem(Ij.dataIndex); Ij.isExpand = (v3 && v3.collapsed != null) ? !v3.collapsed : Ij.depth <= v }); return e.data }, getOrient: function () { var e = this.get("orient"); if (e === "horizontal") { e = "LR" } else { if (e === "vertical") { e = "TB" } } return e }, setZoom: function (e) { this.option.zoom = e }, setCenter: function (e) { this.option.center = e }, formatTooltip: function (m) { var e = this.getData().tree; var i = e.root.children[0]; var v = e.getNodeByDataIndex(m); var Z = v.getValue(); var k = v.name; while (v && (v !== i)) { k = v.parentNode.name + "." + k; v = v.parentNode } return mv(k + ((isNaN(Z) || Z == null) ? "" : " : " + Z)) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", left: "12%", top: "12%", right: "12%", bottom: "12%", layout: "orthogonal", roam: false, nodeScaleRatio: 0.4, center: null, zoom: 1, orient: "LR", symbol: "emptyCircle", symbolSize: 7, expandAndCollapse: true, initialTreeDepth: 2, lineStyle: { color: "#ccc", width: 1.5, curveness: 0.5 }, itemStyle: { color: "lightsteelblue", borderColor: "#c23531", borderWidth: 1.5 }, label: { show: true, color: "#555" }, leaves: { label: { show: true } }, animationEasing: "linear", animationDuration: 700, animationDurationUpdate: 1000 } }); function nD(e) { e.hierNode = { defaultAncestor: null, ancestor: e, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null }; var k = [e]; var Z; var v; while (Z = k.pop()) { v = Z.children; if (Z.isExpand && v.length) { var v2 = v.length; for (var m = v2 - 1; m >= 0; m--) { var v1 = v[m]; v1.hierNode = { defaultAncestor: null, ancestor: v1, prelim: 0, modifier: 0, change: 0, shift: 0, i: m, thread: null }; k.push(v1) } } } } function C4(m, k) { var i = m.isExpand ? m.children : []; var v = m.parentNode.children; var e = m.hierNode.i ? v[m.hierNode.i - 1] : null; if (i.length) { dA(m); var Z = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2; if (e) { m.hierNode.prelim = e.hierNode.prelim + k(m, e); m.hierNode.modifier = m.hierNode.prelim - Z } else { m.hierNode.prelim = Z } } else { if (e) { m.hierNode.prelim = e.hierNode.prelim + k(m, e) } } m.parentNode.hierNode.defaultAncestor = BA(m, e, m.parentNode.hierNode.defaultAncestor || v[0], k) } function af(e) { var i = e.hierNode.prelim + e.parentNode.hierNode.modifier; e.setLayout({ x: i }, true); e.hierNode.modifier += e.parentNode.hierNode.modifier } function B7(e) { return arguments.length ? e : E6 } function j2(e, k) { var i = {}; e -= Math.PI / 2; i.x = k * Math.cos(e); i.y = k * Math.sin(e); return i } function wl(e, i) { return kV(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }) } function dA(k) { var i = k.children; var Z = i.length; var e = 0; var v = 0; while (--Z >= 0) { var m = i[Z]; m.hierNode.prelim += e; m.hierNode.modifier += e; v += m.hierNode.change; e += m.hierNode.shift + v } } function BA(m, k, v3, v) {
    if (k) {
      var Ik = m; var Im = m; var e = Im.parentNode.children[0]; var v2 = k; var Il = Ik.hierNode.modifier; var v1 = Im.hierNode.modifier; var Ij = e.hierNode.modifier; var Z = v2.hierNode.modifier; while (v2 = yd(v2), Im = Fb(Im), v2 && Im) {
        Ik = yd(Ik);
        e = Fb(e); Ik.hierNode.ancestor = m; var i = v2.hierNode.prelim + Z - Im.hierNode.prelim - v1 + v(v2, Im); if (i > 0) { xm(vt(v2, m, v3), m, i); v1 += i; Il += i } Z += v2.hierNode.modifier; v1 += Im.hierNode.modifier; Il += Ik.hierNode.modifier; Ij += e.hierNode.modifier
      } if (v2 && !yd(Ik)) { Ik.hierNode.thread = v2; Ik.hierNode.modifier += Z - Il } if (Im && !Fb(e)) { e.hierNode.thread = Im; e.hierNode.modifier += v1 - Ij; v3 = m }
    } return v3
  } function yd(i) { var e = i.children; return e.length && i.isExpand ? e[e.length - 1] : i.hierNode.thread } function Fb(i) { var e = i.children; return e.length && i.isExpand ? e[0] : i.hierNode.thread } function vt(k, i, e) { return k.hierNode.ancestor.parentNode === i.parentNode ? k.hierNode.ancestor : e } function xm(k, i, e) { var m = e / (i.hierNode.i - k.hierNode.i); i.hierNode.change -= m; i.hierNode.shift += e; i.hierNode.modifier += e; i.hierNode.prelim += e; k.hierNode.change += m } function E6(i, e) { return i.parentNode === e.parentNode ? 1 : 2 } BL({ type: "tree", init: function (e, i) { this._oldTree; this._mainGroup = new B8(); this._controller = new ad(i.getZr()); this._controllerHost = { target: this.group }; this.group.add(this._mainGroup) }, render: function (i, Z, v1, v3) { var k = i.getData(); var e = i.layoutInfo; var Ij = this._mainGroup; var v = i.get("layout"); if (v === "radial") { Ij.attr("position", [e.x + e.width / 2, e.y + e.height / 2]) } else { Ij.attr("position", [e.x, e.y]) } this._updateViewCoordSys(i); this._updateController(i, Z, v1); var m = this._data; var v2 = { expandAndCollapse: i.get("expandAndCollapse"), layout: v, orient: i.getOrient(), curvature: i.get("lineStyle.curveness"), symbolRotate: i.get("symbolRotate"), symbolOffset: i.get("symbolOffset"), hoverAnimation: i.get("hoverAnimation"), useNameLabel: true, fadeIn: true }; k.diff(m).add(function (Ik) { if (ss(k, Ik)) { gL(k, Ik, null, Ij, i, v2) } }).update(function (Il, Ik) { var Im = m.getItemGraphicEl(Ik); if (!ss(k, Il)) { Im && fy(m, Ik, Im, Ij, i, v2); return } gL(k, Il, Im, Ij, i, v2) }).remove(function (Ik) { var Il = m.getItemGraphicEl(Ik); if (Il) { fy(m, Ik, Il, Ij, i, v2) } }).execute(); this._nodeScaleRatio = i.get("nodeScaleRatio"); this._updateNodeAndLinkScale(i); if (v2.expandAndCollapse === true) { k.eachItemGraphicEl(function (Il, Ik) { Il.off("click").on("click", function () { v1.dispatchAction({ type: "treeExpandAndCollapse", seriesId: i.id, dataIndex: Ik }) }) }) } this._data = k }, _updateViewCoordSys: function (i) { var Z = i.getData(); var m = []; Z.each(function (v1) { var v2 = Z.getItemLayout(v1); if (v2 && !isNaN(v2.x) && !isNaN(v2.y)) { m.push([+v2.x, +v2.y]) } }); var k = []; var e = []; oI(m, k, e); if (e[0] - k[0] === 0) { e[0] += 1; k[0] -= 1 } if (e[1] - k[1] === 0) { e[1] += 1; k[1] -= 1 } var v = i.coordinateSystem = new Cl(); v.zoomLimit = i.get("scaleLimit"); v.setBoundingRect(k[0], k[1], e[0] - k[0], e[1] - k[1]); v.setCenter(i.get("center")); v.setZoom(i.get("zoom")); this.group.attr({ position: v.position, scale: v.scale }); this._viewCoordSys = v }, _updateController: function (k, e, m) { var i = this._controller; var Z = this._controllerHost; var v = this.group; i.setPointerChecker(function (v3, v1, Ij) { var v2 = v.getBoundingRect(); v2.applyTransform(v.transform); return v2.contain(v1, Ij) && !CS(v3, m, k) }); i.enable(k.get("roam")); Z.zoomLimit = k.get("scaleLimit"); Z.zoom = k.coordinateSystem.getZoom(); i.off("pan").off("zoom").on("pan", function (v1) { FR(Z, v1.dx, v1.dy); m.dispatchAction({ seriesId: k.id, type: "treeRoam", dx: v1.dx, dy: v1.dy }) }, this).on("zoom", function (v1) { zE(Z, v1.scale, v1.originX, v1.originY); m.dispatchAction({ seriesId: k.id, type: "treeRoam", zoom: v1.scale, originX: v1.originX, originY: v1.originY }); this._updateNodeAndLinkScale(k) }, this) }, _updateNodeAndLinkScale: function (e) { var m = e.getData(); var i = this._getNodeGlobalScale(e); var k = [i, i]; m.eachItemGraphicEl(function (Z, v) { Z.attr("scale", k) }) }, _getNodeGlobalScale: function (k) { var m = k.coordinateSystem; if (m.type !== "view") { return 1 } var v1 = this._nodeScaleRatio; var i = m.scale; var e = (i && i[0]) || 1; var Z = m.getZoom(); var v = (Z - 1) * v1 + 1; return v / e }, dispose: function () { this._controller && this._controller.dispose(); this._controllerHost = {} }, remove: function () { this._mainGroup.removeAll(); this._data = null } }); function ss(k, e) { var i = k.getItemLayout(e); return i && !isNaN(i.x) && !isNaN(i.y) && k.getItemVisual(e, "symbol") !== "none" } function ie(k, i, e) { e.itemModel = i; e.itemStyle = i.getModel("itemStyle").getItemStyle(); e.hoverItemStyle = i.getModel("emphasis.itemStyle").getItemStyle(); e.lineStyle = i.getModel("lineStyle").getLineStyle(); e.labelModel = i.getModel("label"); e.hoverLabelModel = i.getModel("emphasis.label"); if (k.isExpand === false && k.children.length !== 0) { e.symbolInnerColor = e.itemStyle.fill } else { e.symbolInnerColor = "#fff" } return e } function gL(Ix, Iw, Is, v1, Ik, v3) {
    var Ip = !Is; var Im = Ix.tree.getNodeByDataIndex(Iw); var In = Im.getModel(); var v3 = ie(Im, In, v3); var e = Ix.tree.root; var Il = Im.parentNode === e ? Im : Im.parentNode || Im; var Z = Ix.getItemGraphicEl(Il.dataIndex); var v2 = Il.getLayout(); var Iv = Z ? { x: Z.position[0], y: Z.position[1], rawX: Z.__radialOldRawX, rawY: Z.__radialOldRawY } : v2; var Ij = Im.getLayout(); if (Ip) { Is = new lO(Ix, Iw, v3); Is.attr("position", [Iv.x, Iv.y]) } else { Is.updateData(Ix, Iw, v3) } Is.__radialOldRawX = Is.__radialRawX; Is.__radialOldRawY = Is.__radialRawY; Is.__radialRawX = Ij.rawX; Is.__radialRawY = Ij.rawY; v1.add(Is); Ix.setItemGraphicEl(Iw, Is); oS(Is, { position: [Ij.x, Ij.y] }, Ik); var It = Is.getSymbolPath();
    if (v3.layout === "radial") { var Iq = e.children[0]; var Io = Iq.getLayout(); var i = Iq.children.length; var Iu; var m; if (Ij.x === Io.x && Im.isExpand === true) { var Ir = {}; Ir.x = (Iq.children[0].getLayout().x + Iq.children[i - 1].getLayout().x) / 2; Ir.y = (Iq.children[0].getLayout().y + Iq.children[i - 1].getLayout().y) / 2; Iu = Math.atan2(Ir.y - Io.y, Ir.x - Io.x); if (Iu < 0) { Iu = Math.PI * 2 + Iu } m = Ir.x < Io.x; if (m) { Iu = Iu - Math.PI } } else { Iu = Math.atan2(Ij.y - Io.y, Ij.x - Io.x); if (Iu < 0) { Iu = Math.PI * 2 + Iu } if (Im.children.length === 0 || (Im.children.length !== 0 && Im.isExpand === false)) { m = Ij.x < Io.x; if (m) { Iu = Iu - Math.PI } } else { m = Ij.x > Io.x; if (!m) { Iu = Iu - Math.PI } } } var k = m ? "left" : "right"; It.setStyle({ textPosition: k, textRotation: -Iu, textOrigin: "center", verticalAlign: "middle" }) } if (Im.parentNode && Im.parentNode !== e) { var v = Is.__edge; if (!v) { v = Is.__edge = new gX({ shape: kI(v3, Iv, Iv), style: De({ opacity: 0, strokeNoScale: true }, v3.lineStyle) }) } oS(v, { shape: kI(v3, v2, Ij), style: { opacity: 1 } }, Ik); v1.add(v) }
  } function fy(v, v2, Z, Ik, m, v3) { var k = v.tree.getNodeByDataIndex(v2); var v1 = v.tree.root; var Il = k.getModel(); var v3 = ie(k, Il, v3); var e = k.parentNode === v1 ? k : k.parentNode || k; var Ij; while (Ij = e.getLayout(), Ij == null) { e = e.parentNode === v1 ? e : e.parentNode || e } oS(Z, { position: [Ij.x + 1, Ij.y + 1] }, m, function () { Ik.remove(Z); v.setItemGraphicEl(v2, null) }); Z.fadeOut(null, { keepLabel: true }); var i = Z.__edge; if (i) { oS(i, { shape: kI(v3, Ij, Ij), style: { opacity: 0 } }, m, function () { Ik.remove(i) }) } } function kI(Io, Ip, k) { var v3; var v; var v1; var m; var Z = Io.orient; var i; var e; var In; var Il; if (Io.layout === "radial") { i = Ip.rawX; In = Ip.rawY; e = k.rawX; Il = k.rawY; var Im = j2(i, In); var Ik = j2(i, In + (Il - In) * Io.curvature); var Ij = j2(e, Il + (In - Il) * Io.curvature); var v2 = j2(e, Il); return { x1: Im.x, y1: Im.y, x2: v2.x, y2: v2.y, cpx1: Ik.x, cpy1: Ik.y, cpx2: Ij.x, cpy2: Ij.y } } i = Ip.x; In = Ip.y; e = k.x; Il = k.y; if (Z === "LR" || Z === "RL") { v3 = i + (e - i) * Io.curvature; v = In; v1 = e + (i - e) * Io.curvature; m = Il } if (Z === "TB" || Z === "BT") { v3 = i; v = In + (Il - In) * Io.curvature; v1 = e; m = Il + (In - Il) * Io.curvature } return { x1: i, y1: In, x2: e, y2: Il, cpx1: v3, cpy1: v, cpx2: v1, cpy2: m } } b1({ type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update" }, function (i, e) { e.eachComponent({ mainType: "series", subType: "tree", query: i }, function (m) { var v = i.dataIndex; var k = m.getData().tree; var Z = k.getNodeByDataIndex(v); Z.isExpand = !Z.isExpand }) }); b1({ type: "treeRoam", event: "treeRoam", update: "none" }, function (i, e) { e.eachComponent({ mainType: "series", subType: "tree", query: i }, function (k) { var v = k.coordinateSystem; var m = bD(v, i); k.setCenter && k.setCenter(m.center); k.setZoom && k.setZoom(m.zoom) }) }); function lJ(e, v3, v1) { var k = [e]; var Z = []; var v2; while (v2 = k.pop()) { Z.push(v2); if (v2.isExpand) { var v = v2.children; if (v.length) { for (var m = 0; m < v.length; m++) { k.push(v[m]) } } } } while (v2 = Z.pop()) { v3(v2, v1) } } function sf(e, v1) { var k = [e]; var Z; while (Z = k.pop()) { v1(Z); if (Z.isExpand) { var v = Z.children; if (v.length) { for (var m = v.length - 1; m >= 0; m--) { k.push(v[m]) } } } } } var jM = function (e, i) { e.eachSeriesByType("tree", function (k) { p9(k, i) }) }; function p9(v3, v) { var v2 = wl(v3, v); v3.layoutInfo = v2; var In = v3.get("layout"); var Ij = 0; var Z = 0; var v1 = null; if (In === "radial") { Ij = 2 * Math.PI; Z = Math.min(v2.height, v2.width) / 2; v1 = B7(function (Iu, It) { return (Iu.parentNode === It.parentNode ? 1 : 2) / Iu.depth }) } else { Ij = v2.width; Z = v2.height; v1 = B7() } var e = v3.getData().tree.root; var Ik = e.children[0]; if (Ik) { nD(e); lJ(Ik, C4, v1); e.hierNode.modifier = -Ik.hierNode.prelim; sf(Ik, af); var i = Ik; var Io = Ik; var k = Ik; sf(Ik, function (Iu) { var It = Iu.getLayout().x; if (It < i.getLayout().x) { i = Iu } if (It > Io.getLayout().x) { Io = Iu } if (Iu.depth > k.depth) { k = Iu } }); var Ip = i === Io ? 1 : v1(i, Io) / 2; var Ir = Ip - i.getLayout().x; var Im = 0; var Il = 0; var Is = 0; var Iq = 0; if (In === "radial") { Im = Ij / (Io.getLayout().x + Ip + Ir); Il = Z / ((k.depth - 1) || 1); sf(Ik, function (It) { Is = (It.getLayout().x + Ir) * Im; Iq = (It.depth - 1) * Il; var Iu = j2(Is, Iq); It.setLayout({ x: Iu.x, y: Iu.y, rawX: Is, rawY: Iq }, true) }) } else { var m = v3.getOrient(); if (m === "RL" || m === "LR") { Il = Z / (Io.getLayout().x + Ip + Ir); Im = Ij / ((k.depth - 1) || 1); sf(Ik, function (It) { Iq = (It.getLayout().x + Ir) * Il; Is = m === "LR" ? (It.depth - 1) * Im : Ij - (It.depth - 1) * Im; It.setLayout({ x: Is, y: Iq }, true) }) } else { if (m === "TB" || m === "BT") { Im = Ij / (Io.getLayout().x + Ip + Ir); Il = Z / ((k.depth - 1) || 1); sf(Ik, function (It) { Is = (It.getLayout().x + Ir) * Im; Iq = m === "TB" ? (It.depth - 1) * Il : Z - (It.depth - 1) * Il; It.setLayout({ x: Is, y: Iq }, true) }) } } } } } G(ml("tree", "circle")); pr(jM); function uT(v, k, i) { if (v && eP(k, v.type) >= 0) { var e = i.getData().tree.root; var m = v.targetNode; if (typeof m === "string") { m = e.getNodeById(m) } if (m && e.contains(m)) { return { node: m } } var Z = v.targetNodeId; if (Z != null && (m = e.getNodeById(Z))) { return { node: m } } } } function tN(e) { var i = []; while (e) { e = e.parentNode; e && i.push(e) } return i.reverse() } function wM(k, i) { var e = tN(k); return eP(e, i) >= 0 } function dM(m, k) { var i = []; while (m) { var e = m.dataIndex; i.push({ name: m.name, dataIndex: e, value: k.getRawValue(e) }); m = m.parentNode } i.reverse(); return i } nU.extend({
    type: "series.treemap", layoutMode: "box", dependencies: ["grid", "polar"], _viewRoot: null, defaultOption: { progressive: 0, hoverLayerThreshold: Infinity, left: "center", top: "middle", right: null, bottom: null, width: "80%", height: "80%", sort: true, clipWindow: "origin", squareRatio: 0.5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: 0.32 * 0.32, roam: true, nodeClick: "zoomToNode", animation: true, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: true, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { color: "rgba(0,0,0,0.7)", borderColor: "rgba(255,255,255,0.7)", borderWidth: 1, shadowColor: "rgba(150,150,150,1)", shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: "#fff" } }, emphasis: { textStyle: {} } }, label: { show: true, distance: 0, padding: 5, position: "inside", color: "#fff", ellipsis: true }, upperLabel: { show: false, position: [0, "50%"], height: 20, color: "#fff", ellipsis: true, verticalAlign: "middle" }, itemStyle: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: { upperLabel: { show: true, position: [0, "50%"], color: "#fff", ellipsis: true, verticalAlign: "middle" } }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, getInitialData: function (m, e) {
      var i = { name: m.name, children: m.data };
      u5(i); var v = m.levels || []; v = m.levels = xk(v, e); var k = {}; k.levels = v; return nA.createTree(i, this, k).data
    }, optionUpdated: function () { this.resetViewRoot() }, formatTooltip: function (i) { var v = this.getData(); var m = this.getRawValue(i); var k = GG(m) ? j7(m[0]) : j7(m); var e = v.getName(i); return mv(e + ": " + k) }, getDataParams: function (e) { var k = nU.prototype.getDataParams.apply(this, arguments); var i = this.getData().tree.getNodeByDataIndex(e); k.treePathInfo = dM(i, this); return k }, setLayoutInfo: function (e) { this.layoutInfo = this.layoutInfo || {}; b0(this.layoutInfo, e) }, mapIdToIndex: function (k) { var e = this._idIndexMap; if (!e) { e = this._idIndexMap = CJ(); this._idIndexMapCount = 0 } var i = e.get(k); if (i == null) { e.set(k, i = this._idIndexMapCount++) } return i }, getViewRoot: function () { return this._viewRoot }, resetViewRoot: function (i) { i ? (this._viewRoot = i) : (i = this._viewRoot); var e = this.getRawData().tree.root; if (!i || (i !== e && !e.contains(i))) { this._viewRoot = e } }
  }); function u5(i) { var k = 0; o9(i.children, function (v) { u5(v); var m = v.value; GG(m) && (m = m[0]); k += m }); var e = i.value; if (GG(e)) { e = e[0] } if (e == null || isNaN(e)) { e = k } if (e < 0) { e = 0 } GG(i.value) ? (i.value[0] = e) : (i.value = e) } function xk(m, i) { var k = i.get("color"); if (!k) { return } m = m || []; var e; o9(m, function (v2) { var Z = new fv(v2); var v1 = Z.get("color"); if (Z.get("itemStyle.color") || (v1 && v1 !== "none")) { e = true } }); if (!e) { var v = m[0] || (m[0] = {}); v.color = k.slice() } return m } var zh = 8; var BB = 8; var EG = 5; function kL(e) { this.group = new B8(); e.add(this.group) } kL.prototype = { constructor: kL, render: function (e, m, v, v1) { var k = e.getModel("breadcrumb"); var i = this.group; i.removeAll(); if (!k.get("show") || !v) { return } var Z = k.getModel("itemStyle"); var v2 = Z.getModel("textStyle"); var v3 = { pos: { left: k.get("left"), right: k.get("right"), top: k.get("top"), bottom: k.get("bottom") }, box: { width: m.getWidth(), height: m.getHeight() }, emptyItemWidth: k.get("emptyItemWidth"), totalWidth: 0, renderList: [] }; this._prepare(v, v3, v2); this._renderContent(e, v3, Z, v2, v1); Ax(i, v3.pos, v3.box) }, _prepare: function (v, k, e) { for (var i = v; i; i = i.parentNode) { var v1 = i.getModel().get("name"); var Z = e.getTextRect(v1); var m = Math.max(Z.width + zh * 2, k.emptyItemWidth); k.totalWidth += m + BB; k.renderList.push({ node: i, text: v1, width: m }) } }, _renderContent: function (v1, Ir, Il, In, Im) { var k = 0; var v2 = Ir.emptyItemWidth; var Ip = v1.get("breadcrumb.height"); var Z = mA(Ir.pos, Ir.box); var Ij = Ir.totalWidth; var e = Ir.renderList; for (var v3 = e.length - 1; v3 >= 0; v3--) { var Iq = e[v3]; var v = Iq.node; var Ik = Iq.width; var Io = Iq.text; if (Ij > Z.width) { Ij -= Ik - v2; Ik = v2; Io = null } var m = new ia({ shape: { points: bf(k, 0, Ik, Ip, v3 === e.length - 1, v3 === 0) }, style: De(Il.getItemStyle(), { lineJoin: "bevel", text: Io, textFill: In.getTextColor(), textFont: In.getFont() }), z: 10, onclick: sv(Im, v) }); this.group.add(m); gH(m, v1, v); k += Ik + BB } }, remove: function () { this.group.removeAll() } }; function bf(e, v1, v, Z, k, i) { var m = [[k ? e : e - EG, v1], [e + v, v1], [e + v, v1 + Z], [k ? e : e - EG, v1 + Z]]; !i && m.splice(2, 0, [e + v + EG, v1 + Z / 2]); !k && m.push([e, v1 + Z / 2]); return m } function gH(i, e, k) { i.eventData = { componentType: "series", componentSubType: "treemap", seriesIndex: e.componentIndex, seriesName: e.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: k && k.dataIndex, name: k && k.name }, treePathInfo: k && dM(k, e) } } function s7() { var k = []; var i = {}; var e; return { add: function (v, v1, Z, m, v2) { if (wb(m)) { v2 = m; m = 0 } if (i[v.id]) { return false } i[v.id] = 1; k.push({ el: v, target: v1, time: Z, delay: m, easing: v2 }); return true }, done: function (m) { e = m; return this }, start: function () { var v2 = k.length; for (var Z = 0, m = k.length; Z < m; Z++) { var v1 = k[Z]; v1.el.animateTo(v1.target, v1.time, v1.delay, v1.easing, v) } return this; function v() { v2--; if (!v2) { k.length = 0; i = {}; e && e() } } } } } var pC = km; var rl = B8; var A0 = EH; var oZ = o9; var tX = 3; var Fn = ["label"]; var dU = ["emphasis", "label"]; var Hs = ["upperLabel"]; var mc = ["emphasis", "upperLabel"]; var lK = 10; var rk = 1; var Dz = 2; var h8 = yO([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]); var AR = function (e) { var i = h8(e); i.stroke = i.fill = i.lineWidth = null; return i }; BL({
    type: "treemap", init: function (i, e) { this._containerGroup; this._storage = AZ(); this._oldTree; this._breadcrumb; this._controller; this._state = "ready" }, render: function (v, v2, Ij, Il) { var e = v2.findComponents({ mainType: "series", subType: "treemap", query: Il }); if (eP(e, v) < 0) { return } this.seriesModel = v; this.api = Ij; this.ecModel = v2; var Ik = ["treemapZoomToNode", "treemapRootToNode"]; var v3 = uT(Il, Ik, v); var Im = Il && Il.type; var m = v.layoutInfo; var v1 = !this._oldTree; var k = this._storage; var i = (Im === "treemapRootToNode" && v3 && k) ? { rootNodeGroup: k.nodeGroup[v3.node.getRawIndex()], direction: Il.direction } : null; var Z = this._giveContainerGroup(m); var In = this._doRender(Z, v, i); (!v1 && (!Im || Im === "treemapZoomToNode" || Im === "treemapRootToNode")) ? this._doAnimation(Z, In, v, i) : In.renderFinally(); this._resetController(Ij); this._renderBreadcrumb(v, Ij, v3) }, _giveContainerGroup: function (e) { var i = this._containerGroup; if (!i) { i = this._containerGroup = new rl(); this._initEvents(i); this.group.add(i) } i.attr("position", [e.x, e.y]); return i }, _doRender: function (Ij, Z, v) {
      var m = Z.getData().tree; var e = this._oldTree;
      var Im = AZ(); var v1 = AZ(); var v2 = this._storage; var k = []; var In = sv(a2, Z, v1, v2, v, Im, k); i(m.root ? [m.root] : [], (e && e.root) ? [e.root] : [], Ij, m === e || !e, 0); var Il = Ik(v2); this._oldTree = m; this._storage = v1; return { lastsForAnimation: Im, willDeleteEls: Il, renderFinally: v3 }; function i(Iu, It, Iq, Io, Is) { if (Io) { It = Iu; oZ(Iu, function (Iw, Iv) { !Iw.isRemoved() && Ir(Iv, Iv) }) } else { (new Gx(It, Iu, Ip, Ip)).add(Ir).update(Ir).remove(sv(Ir, null)).execute() } function Ip(Iv) { return Iv.getId() } function Ir(Iw, Iz) { var Iv = Iw != null ? Iu[Iw] : null; var Iy = Iz != null ? It[Iz] : null; var Ix = In(Iv, Iy, Iq, Is); Ix && i(Iv && Iv.viewChildren || [], Iy && Iy.viewChildren || [], Ix, Io, Is + 1) } } function Ik(Ip) { var Io = AZ(); Ip && oZ(Ip, function (Iq, Ir) { var Is = Io[Ir]; oZ(Iq, function (It) { It && (Is.push(It), It.__tmWillDelete = 1) }) }); return Io } function v3() { oZ(Il, function (Io) { oZ(Io, function (Ip) { Ip.parent && Ip.parent.remove(Ip) }) }); oZ(k, function (Io) { Io.invisible = true; Io.dirty() }) }
    }, _doAnimation: function (v1, Z, e, m) { if (!e.get("animation")) { return } var k = e.get("animationDurationUpdate"); var v = e.get("animationEasing"); var i = s7(); oZ(Z.willDeleteEls, function (v2, v3) { oZ(v2, function (Im, Ij) { if (Im.invisible) { return } var Il = Im.parent; var Io; if (m && m.direction === "drillDown") { Io = Il === m.rootNodeGroup ? { shape: { x: 0, y: 0, width: Il.__tmNodeWidth, height: Il.__tmNodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } } } else { var In = 0; var Ik = 0; if (!Il.__tmWillDelete) { In = Il.__tmNodeWidth / 2; Ik = Il.__tmNodeHeight / 2 } Io = v3 === "nodeGroup" ? { position: [In, Ik], style: { opacity: 0 } } : { shape: { x: In, y: Ik, width: 0, height: 0 }, style: { opacity: 0 } } } Io && i.add(Im, Io, k, v) }) }); oZ(this._storage, function (v2, v3) { oZ(v2, function (Ik, Ij) { var Il = Z.lastsForAnimation[v3][Ij]; var Im = {}; if (!Il) { return } if (v3 === "nodeGroup") { if (Il.old) { Im.position = Ik.position.slice(); Ik.attr("position", Il.old) } } else { if (Il.old) { Im.shape = b0({}, Ik.shape); Ik.setShape(Il.old) } if (Il.fadein) { Ik.setStyle("opacity", 0); Im.style = { opacity: 1 } } else { if (Ik.style.opacity !== 1) { Im.style = { opacity: 1 } } } } i.add(Ik, Im, k, v) }) }, this); this._state = "animating"; i.done(pC(function () { this._state = "ready"; Z.renderFinally() }, this)).start() }, _resetController: function (i) { var e = this._controller; if (!e) { e = this._controller = new ad(i.getZr()); e.enable(this.seriesModel.get("roam")); e.on("pan", pC(this._onPan, this)); e.on("zoom", pC(this._onZoom, this)) } var k = new CH(0, 0, i.getWidth(), i.getHeight()); e.setPointerChecker(function (v, m, Z) { return k.contain(m, Z) }) }, _clearController: function () { var e = this._controller; if (e) { e.dispose(); e = null } }, _onPan: function (m) { if (this._state !== "animating" && (Math.abs(m.dx) > tX || Math.abs(m.dy) > tX)) { var k = this.seriesModel.getData().tree.root; if (!k) { return } var i = k.getLayout(); if (!i) { return } this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: i.x + m.dx, y: i.y + m.dy, width: i.width, height: i.height } }) } }, _onZoom: function (Ij) { var v1 = Ij.originX; var Z = Ij.originY; if (this._state !== "animating") { var v = this.seriesModel.getData().tree.root; if (!v) { return } var k = v.getLayout(); if (!k) { return } var v2 = new CH(k.x, k.y, k.width, k.height); var v3 = this.seriesModel.layoutInfo; v1 -= v3.x; Z -= v3.y; var i = CB(); vm(i, i, [-v1, -Z]); qX(i, i, [Ij.scale, Ij.scale]); vm(i, i, [v1, Z]); v2.applyTransform(i); this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: v2.x, y: v2.y, width: v2.width, height: v2.height } }) } }, _initEvents: function (e) { e.on("click", function (Z) { if (this._state !== "ready") { return } var i = this.seriesModel.get("nodeClick", true); if (!i) { return } var v2 = this.findTarget(Z.offsetX, Z.offsetY); if (!v2) { return } var v = v2.node; if (v.getLayout().isLeafRoot) { this._rootToNode(v2) } else { if (i === "zoomToNode") { this._zoomToNode(v2) } else { if (i === "link") { var k = v.hostTree.data.getItemModel(v.dataIndex); var m = k.get("link", true); var v1 = k.get("target", true) || "blank"; m && window.open(m, v1) } } } }, this) }, _renderBreadcrumb: function (e, k, m) { if (!m) { m = e.get("leafDepth", true) != null ? { node: e.getViewRoot() } : this.findTarget(k.getWidth() / 2, k.getHeight() / 2); if (!m) { m = { node: e.getData().tree.root } } } (this._breadcrumb || (this._breadcrumb = new kL(this.group))).render(e, k, m.node, pC(i, this)); function i(v) { if (this._state !== "animating") { wM(e.getViewRoot(), v) ? this._rootToNode({ node: v }) : this._zoomToNode({ node: v }) } } }, remove: function () { this._clearController(); this._containerGroup && this._containerGroup.removeAll(); this._storage = AZ(); this._state = "ready"; this._breadcrumb && this._breadcrumb.remove() }, dispose: function () { this._clearController() }, _zoomToNode: function (e) { this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node }) }, _rootToNode: function (e) { this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node }) }, findTarget: function (e, m) {
      var k; var i = this.seriesModel.getViewRoot(); i.eachNode({ attr: "viewChildren", order: "preorder" }, function (v2) {
        var v1 = this._storage.background[v2.getRawIndex()]; if (v1) {
          var v = v1.transformCoordToLocal(e, m); var Z = v1.shape; if (Z.x <= v[0] && v[0] <= Z.x + Z.width && Z.y <= v[1] && v[1] <= Z.y + Z.height) { k = { node: v2, offsetX: v[0], offsetY: v[1] } } else {
            return false
          }
        }
      }, this); return k
    }
  }); function AZ() { return { nodeGroup: [], background: [], content: [] } } function a2(Ir, v, v3, Ij, Iq, Il, Io, It, v2, ID) { if (!Io) { return } var Ix = Io.getLayout(); if (!Ix || !Ix.isInView) { return } var IF = Ix.width; var Ip = Ix.height; var IE = Ix.borderWidth; var In = Ix.invisible; var k = Io.getRawIndex(); var IC = It && It.getRawIndex(); var i = Io.viewChildren; var Iu = Ix.upperHeight; var IA = i && i.length; var e = Io.getModel("itemStyle"); var Ik = Io.getModel("emphasis.itemStyle"); var Im = m("nodeGroup", rl); if (!Im) { return } v2.add(Im); Im.attr("position", [Ix.x || 0, Ix.y || 0]); Im.__tmNodeWidth = IF; Im.__tmNodeHeight = Ip; if (Ix.isAboveViewRoot) { return Im } var v1 = m("background", A0, ID, rk); v1 && Z(Im, v1, IA && Ix.upperHeight); if (!IA) { var Iv = m("content", A0, ID, Dz); Iv && Iz(Im, Iv) } return Im; function Z(IJ, IH, IG) { IH.dataIndex = Io.dataIndex; IH.seriesIndex = Ir.seriesIndex; IH.setShape({ x: 0, y: 0, width: IF, height: Ip }); var II = Io.getVisual("borderColor", true); var IK = Ik.get("borderColor"); Is(IH, function () { var IN = AR(e); IN.fill = II; var IL = h8(Ik); IL.fill = IK; if (IG) { var IM = IF - 2 * IE; IB(IN, IL, II, IM, Iu, { x: IE, y: 0, width: IM, height: Iu }) } else { IN.text = IL.text = null } IH.setStyle(IN); yn(IH, IL) }); IJ.add(IH) } function Iz(IK, IJ) { IJ.dataIndex = Io.dataIndex; IJ.seriesIndex = Ir.seriesIndex; var IG = Math.max(IF - 2 * IE, 0); var II = Math.max(Ip - 2 * IE, 0); IJ.culling = true; IJ.setShape({ x: IE, y: IE, width: IG, height: II }); var IH = Io.getVisual("color", true); Is(IJ, function () { var IM = AR(e); IM.fill = IH; var IL = h8(Ik); IB(IM, IL, IH, IG, II); IJ.setStyle(IM); yn(IJ, IL) }); IK.add(IJ) } function Is(IH, IG) { if (!In) { IG(); if (!IH.__tmWillVisible) { IH.invisible = false } } else { !IH.invisible && Il.push(IH) } } function IB(IG, II, IO, IH, IP, IM) { var IJ = Io.getModel(); var IN = gu(Ir.getFormattedLabel(Io.dataIndex, "normal", null, null, IM ? "upperLabel" : "label"), IJ.get("name")); if (!IM && Ix.isLeafRoot) { var IL = Ir.get("drillDownIcon", true); IN = IL ? IL + " " + IN : IN } var IR = IJ.getModel(IM ? Hs : Fn); var IQ = IJ.getModel(IM ? mc : dU); var IK = IR.getShallow("show"); BD(IG, II, IR, IQ, { defaultText: IK ? IN : null, autoColor: IO, isRectText: true }); IM && (IG.textRect = C5(IM)); IG.truncate = (IK && IR.get("ellipsis")) ? { outerWidth: IH, outerHeight: IP, minChar: 2 } : null } function m(IJ, IH, IL, IK) { var II = IC != null && v3[IJ][IC]; var IG = Iq[IJ]; if (II) { v3[IJ][IC] = null; Iy(IG, II, IJ) } else { if (!In) { II = new IH({ z: te(IL, IK) }); II.__tmDepth = IL; II.__tmStorageName = IJ; Iw(IG, II, IJ) } } return (v[IJ][k] = II) } function Iy(IG, II, IH) { var IJ = IG[k] = {}; IJ.old = IH === "nodeGroup" ? II.position.slice() : b0({}, II.shape) } function Iw(II, IL, IK) { var IM = II[k] = {}; var IH = Io.parentNode; if (IH && (!Ij || Ij.direction === "drillDown")) { var IG = 0; var IN = 0; var IJ = Iq.background[IH.getRawIndex()]; if (!Ij && IJ && IJ.old) { IG = IJ.old.width; IN = IJ.old.height } IM.old = IK === "nodeGroup" ? [0, IN] : { x: IG, y: IN, width: 0, height: 0 } } IM.fadein = IK !== "nodeGroup" } } function te(k, i) { var e = k * lK + i; return (e - 1) / e } var vJ = function () { }; var fR = ["treemapZoomToNode", "treemapRender", "treemapMove"]; for (var Ac = 0; Ac < fR.length; Ac++) { b1({ type: fR[Ac], update: "updateView" }, vJ) } b1({ type: "treemapRootToNode", update: "updateView" }, function (k, e) { e.eachComponent({ mainType: "series", subType: "treemap", query: k }, i); function i(Z, v) { var v1 = ["treemapZoomToNode", "treemapRootToNode"]; var v2 = uT(k, v1, Z); if (v2) { var m = Z.getViewRoot(); if (m) { k.direction = wM(m, v2.node) ? "rollUp" : "drillDown" } Z.resetViewRoot(v2.node) } } }); var oX = o9; var tC = tJ; var oj = -1; var mH = function (m) { var e = m.mappingMethod; var v = m.type; var i = this.option = C5(m); this.type = v; this.mappingMethod = e; this._normalizeData = sr[e]; var k = sH[v]; this.applyVisual = k.applyVisual; this.getColorMapper = k.getColorMapper; this._doMap = k._doMap[e]; if (e === "piecewise") { hv(i); os(i) } else { if (e === "category") { i.categories ? eV(i) : hv(i, true) } else { bM(e !== "linear" || i.dataExtent); hv(i) } } }; mH.prototype = { constructor: mH, mapValueToVisual: function (e) { var i = this._normalizeData(e); return this._doMap(i, e) }, getNormalizer: function () { return km(this._normalizeData, this) } }; var sH = mH.visualHandlers = { color: { applyVisual: bO("color"), getColorMapper: function () { var e = this.option; return km(e.mappingMethod === "category" ? function (k, i) { !i && (k = this._normalizeData(k)); return sp.call(this, k) } : function (v, m, i) { var k = !!i; !m && (v = this._normalizeData(v)); i = Q(v, e.parsedVisual, i); return k ? i : wp(i, "rgba") }, this) }, _doMap: { linear: function (e) { return wp(Q(e, this.option.parsedVisual), "rgba") }, category: sp, piecewise: function (k, i) { var e = uc.call(this, i); if (e == null) { e = wp(Q(k, this.option.parsedVisual), "rgba") } return e }, fixed: sl } }, colorHue: u0(function (e, i) { return lx(e, i) }), colorSaturation: u0(function (e, i) { return lx(e, null, i) }), colorLightness: u0(function (e, i) { return lx(e, null, null, i) }), colorAlpha: u0(function (e, i) { return ik(e, i) }), opacity: { applyVisual: bO("opacity"), _doMap: pM([0, 1]) }, liftZ: { applyVisual: bO("liftZ"), _doMap: { linear: sl, category: sl, piecewise: sl, fixed: sl } }, symbol: { applyVisual: function (k, e, v) { var m = this.mapValueToVisual(k); if (wb(m)) { v("symbol", m) } else { if (tC(m)) { for (var i in m) { if (m.hasOwnProperty(i)) { v(i, m[i]) } } } } }, _doMap: { linear: x8, category: sp, piecewise: function (k, i) { var e = uc.call(this, i); if (e == null) { e = x8.call(this, k) } return e }, fixed: sl } }, symbolSize: { applyVisual: bO("symbolSize"), _doMap: pM([0, 1]) } }; function os(i) {
    var e = i.pieceList;
    i.hasSpecialVisual = false; o9(e, function (m, k) { m.originIndex = k; if (m.visual != null) { i.hasSpecialVisual = true } })
  } function eV(v) { var e = v.categories; var v1 = v.visual; var Z = v.categoryMap = {}; oX(e, function (v2, i) { Z[v2] = i }); if (!GG(v1)) { var m = []; if (tJ(v1)) { oX(v1, function (i, v3) { var v2 = Z[v3]; m[v2 != null ? v2 : oj] = i }) } else { m[oj] = v1 } v1 = Ey(v, m) } for (var k = e.length - 1; k >= 0; k--) { if (v1[k] == null) { delete Z[e[k]]; e.pop() } } } function hv(k, e) { var m = k.visual; var i = []; if (tJ(m)) { oX(m, function (Z) { i.push(Z) }) } else { if (m != null) { i.push(m) } } var v = { color: 1, symbol: 1 }; if (!e && i.length === 1 && !v.hasOwnProperty(k.type)) { i[1] = i[0] } Ey(k, i) } function u0(e) { return { applyVisual: function (k, i, m) { k = this.mapValueToVisual(k); m("color", e(i("color"), k)) }, _doMap: pM([0, 1]) } } function x8(i) { var e = this.option.visual; return e[Math.round(EQ(i, [0, 1], [0, e.length - 1], true))] || {} } function bO(e) { return function (k, i, m) { m(e, this.mapValueToVisual(k)) } } function sp(i) { var e = this.option.visual; return e[(this.option.loop && i !== oj) ? i % e.length : i] } function sl() { return this.option.visual[0] } function pM(e) { return { linear: function (i) { return EQ(i, e, this.option.visual, true) }, category: sp, piecewise: function (m, k) { var i = uc.call(this, k); if (i == null) { i = EQ(m, e, this.option.visual, true) } return i }, fixed: sl } } function uc(v) { var i = this.option; var e = i.pieceList; if (i.hasSpecialVisual) { var m = mH.findPieceIndex(v, e); var k = e[m]; if (k && k.visual) { return k.visual[this.type] } } } function Ey(i, e) { i.visual = e; if (i.type === "color") { i.parsedVisual = Ef(e, function (k) { return eW(k) }) } return e } var sr = { linear: function (e) { return EQ(e, this.option.dataExtent, [0, 1], true) }, piecewise: function (k) { var e = this.option.pieceList; var i = mH.findPieceIndex(k, e, true); if (i != null) { return EQ(i, [0, e.length - 1], [0, 1], true) } }, category: function (i) { var e = this.option.categories ? this.option.categoryMap[i] : i; return e == null ? oj : e }, fixed: V }; mH.listVisualTypes = function () { var e = []; o9(sH, function (k, i) { e.push(i) }); return e }; mH.addVisualHandler = function (e, i) { sH[e] = i }; mH.isValidType = function (e) { return sH.hasOwnProperty(e) }; mH.eachVisual = function (i, k, e) { if (tJ(i)) { o9(i, k, e) } else { k.call(e, i) } }; mH.mapVisual = function (i, v, e) { var m; var k = GG(i) ? [] : tJ(i) ? {} : (m = true, null); mH.eachVisual(i, function (Z, v2) { var v1 = v.call(e, Z, v2); m ? (k = v1) : (k[v2] = v1) }); return k }; mH.retrieveVisuals = function (k) { var i = {}; var e; k && oX(sH, function (m, v) { if (k.hasOwnProperty(v)) { i[v] = k[v]; e = true } }); return e ? i : null }; mH.prepareVisualTypes = function (i) { if (tC(i)) { var e = []; oX(i, function (m, k) { e.push(k) }); i = e } else { if (GG(i)) { i = i.slice() } else { return [] } } i.sort(function (m, k) { return (k === "color" && m !== "color" && m.indexOf("color") === 0) ? 1 : -1 }); return i }; mH.dependsOn = function (i, e) { return e === "color" ? !!(i && i.indexOf(e) === 0) : i === e }; mH.findPieceIndex = function (Ij, e, Z) { var v2; var Im = Infinity; for (var m = 0, v3 = e.length; m < v3; m++) { var v1 = e[m].value; if (v1 != null) { if (v1 === Ij || (typeof v1 === "string" && v1 === Ij + "")) { return m } Z && v(v1, m) } } for (var m = 0, v3 = e.length; m < v3; m++) { var Il = e[m]; var k = Il.interval; var Ik = Il.close; if (k) { if (k[0] === -Infinity) { if (n6(Ik[1], Ij, k[1])) { return m } } else { if (k[1] === Infinity) { if (n6(Ik[0], k[0], Ij)) { return m } } else { if (n6(Ik[0], k[0], Ij) && n6(Ik[1], Ij, k[1])) { return m } } } Z && v(k[0], m); Z && v(k[1], m) } } if (Z) { return Ij === Infinity ? e.length - 1 : Ij === -Infinity ? 0 : v2 } function v(Io, i) { var In = Math.abs(Io - Ij); if (In < Im) { Im = In; v2 = i } } }; function n6(k, i, e) { return k ? i <= e : i < e } var Ig = GG; var d6 = "itemStyle"; var x7 = { seriesType: "treemap", reset: function (v, i, Z, v2) { var e = v.getData().tree; var k = e.root; var v1 = v.getModel(d6); if (k.isRemoved()) { return } var m = Ef(e.levelModels, function (v3) { return v3 ? v3.get(d6) : null }); g0(k, {}, m, v1, v.getViewRoot().getAncestors(), v) } }; function g0(v, Ip, i, Io, Im, v1) { var k = v.getModel(); var Ij = v.getLayout(); if (!Ij || Ij.invisible || !Ij.isInView) { return } var Ik = v.getModel(d6); var Il = i[v.depth]; var Z = rI(Ik, Ip, Il, Io); var m = Ik.get("borderColor"); var v3 = Ik.get("borderColorSaturation"); var v2; if (v3 != null) { v2 = Ia(Z, v); m = FZ(v3, v2) } v.setVisual("borderColor", m); var In = v.viewChildren; if (!In || !In.length) { v2 = Ia(Z, v); v.setVisual("color", v2) } else { var e = yo(v, k, Ij, Ik, Z, In); o9(In, function (Is, Iq) { if (Is.depth >= Im.length || Is === Im[Is.depth]) { var Ir = mP(k, Z, Is, Iq, e, v1); g0(Is, Ir, i, Io, Im, v1) } }) } } function rI(v, e, m, i) { var k = b0({}, e); o9(["color", "colorAlpha", "colorSaturation"], function (Z) { var v1 = v.get(Z, true); v1 == null && m && (v1 = m[Z]); v1 == null && (v1 = e[Z]); v1 == null && (v1 = i.get(Z)); v1 != null && (k[Z] = v1) }); return k } function Ia(m) { var i = y8(m, "color"); if (i) { var k = y8(m, "colorAlpha"); var e = y8(m, "colorSaturation"); if (e) { i = lx(i, null, null, e) } if (k) { i = ik(i, k) } return i } } function FZ(i, e) { return e != null ? lx(e, null, null, i) : null } function y8(k, e) { var i = k[e]; if (i != null && i !== "none") { return i } } function yo(v, m, v3, Ik, v1, Il) {
    if (!Il || !Il.length) { return } var i = k4(m, "color") || (v1.color != null && v1.color !== "none" && (k4(m, "colorAlpha") || k4(m, "colorSaturation"))); if (!i) { return } var v2 = m.get("visualMin"); var Ij = m.get("visualMax"); var Im = v3.dataExtent.slice(); v2 != null && v2 < Im[0] && (Im[0] = v2); Ij != null && Ij > Im[1] && (Im[1] = Ij); var Z = m.get("colorMappingBy"); var k = { type: i.name, dataExtent: Im, visual: i.range }; if (k.type === "color" && (Z === "index" || Z === "id")) {
      k.mappingMethod = "category";
      k.loop = true
    } else { k.mappingMethod = "linear" } var e = new mH(k); e.__drColorMappingBy = Z; return e
  } function k4(k, i) { var e = k.get(i); return (Ig(e) && e.length) ? { name: i, range: e } : null } function mP(m, Z, i, v3, e, v1) { var k = b0({}, Z); if (e) { var v2 = e.type; var v = v2 === "color" && e.__drColorMappingBy; var Ij = v === "index" ? v3 : v === "id" ? v1.mapIdToIndex(i.getId()) : i.getValue(m.get("visualDimension")); k[v2] = e.mapValueToVisual(Ij) } return k } var AK = Math.max; var ju = Math.min; var bB = gu; var t3 = o9; var gq = ["itemStyle", "borderWidth"]; var j4 = ["itemStyle", "gapWidth"]; var E3 = ["upperLabel", "show"]; var un = ["upperLabel", "height"]; var eR = { seriesType: "treemap", reset: function (Iq, Iv, Im, Ir) { var Ik = Im.getWidth(); var i = Im.getHeight(); var v = Iq.option; var Ip = kV(Iq.getBoxLayoutParams(), { width: Im.getWidth(), height: Im.getHeight() }); var Io = v.size || []; var Ij = zN(bB(Ip.width, Io[0]), Ik); var In = zN(bB(Ip.height, Io[1]), i); var e = Ir && Ir.type; var Il = ["treemapZoomToNode", "treemapRootToNode"]; var v3 = uT(Ir, Il, Iq); var Z = (e === "treemapRender" || e === "treemapMove") ? Ir.rootRect : null; var v2 = Iq.getViewRoot(); var v1 = tN(v2); if (e !== "treemapMove") { var It = e === "treemapZoomToNode" ? U(Iq, v3, v2, Ij, In) : Z ? [Z.width, Z.height] : [Ij, In]; var Iu = v.sort; if (Iu && Iu !== "asc" && Iu !== "desc") { Iu = "desc" } var m = { squareRatio: v.squareRatio, sort: Iu, leafDepth: v.leafDepth }; v2.hostTree.clearLayouts(); var k = { x: 0, y: 0, width: It[0], height: It[1], area: It[0] * It[1] }; v2.setLayout(k); rj(v2, m, false, 0); var k = v2.getLayout(); t3(v1, function (Iy, Ix) { var Iw = (v1[Ix + 1] || v2).getValue(); Iy.setLayout(b0({ dataExtent: [Iw, Iw], borderWidth: 0, upperHeight: 0 }, k)) }) } var Is = Iq.getData().tree.root; Is.setLayout(HJ(Ip, Z, v3), true); Iq.setLayoutInfo(Ip); wt(Is, new CH(-Ip.x, -Ip.y, Ik, i), v1, v2, 0) } }; function rj(Il, v, It, Iy) { var Ik; var v3; if (Il.isRemoved()) { return } var Iw = Il.getLayout(); Ik = Iw.width; v3 = Iw.height; var Ij = Il.getModel(); var Iz = Ij.get(gq); var Io = Ij.get(j4) / 2; var Iq = px(Ij); var In = Math.max(Iz, Iq); var Ix = Iz - Io; var e = In - Io; var Ij = Il.getModel(); Il.setLayout({ borderWidth: Iz, upperHeight: In, upperLabelHeight: Iq }, true); Ik = AK(Ik - 2 * Ix, 0); v3 = AK(v3 - Ix - e, 0); var Iv = Ik * v3; var Im = q0(Il, Ij, Iv, v, It, Iy); if (!Im.length) { return } var k = { x: Ix, y: e, width: Ik, height: v3 }; var v2 = ju(Ik, v3); var m = Infinity; var v1 = []; v1.area = 0; for (var Is = 0, Iu = Im.length; Is < Iu;) { var Z = Im[Is]; v1.push(Z); v1.area += Z.getLayout().area; var Ir = iP(v1, v2, v.squareRatio); if (Ir <= m) { Is++; m = Ir } else { v1.area -= v1.pop().getLayout().area; vE(v1, v2, k, Io, false); v2 = ju(k.width, k.height); v1.length = v1.area = 0; m = Infinity } } if (v1.length) { vE(v1, v2, k, Io, true) } if (!It) { var Ip = Ij.get("childrenVisibleMin"); if (Ip != null && Iv < Ip) { It = true } } for (var Is = 0, Iu = Im.length; Is < Iu; Is++) { rj(Im[Is], v, It, Iy + 1) } } function q0(v, m, Im, In, v2, v1) { var Il = v.children || []; var Ij = In.sort; Ij !== "asc" && Ij !== "desc" && (Ij = null); var Ik = In.leafDepth != null && In.leafDepth <= v1; if (v2 && !Ik) { return (v.viewChildren = []) } Il = q4(Il, function (i) { return !i.isRemoved() }); fB(Il, Ij); var k = ge(m, Il, Ij); if (k.sum === 0) { return (v.viewChildren = []) } k.sum = dc(m, Im, k.sum, Ij, Il); if (k.sum === 0) { return (v.viewChildren = []) } for (var Z = 0, v3 = Il.length; Z < v3; Z++) { var e = Il[Z].getValue() / k.sum * Im; Il[Z].setLayout({ area: e }) } if (Ik) { Il.length && v.setLayout({ isLeafRoot: true }, true); Il.length = 0 } v.viewChildren = Il; v.setLayout({ dataExtent: k.dataExtent }, true); return Il } function dc(e, Ik, Z, v2, v) { if (!v2) { return Z } var Ij = e.get("visibleMin"); var v1 = v.length; var m = v1; for (var k = v1 - 1; k >= 0; k--) { var v3 = v[v2 === "asc" ? v1 - k - 1 : k].getValue(); if (v3 / Z * Ik < Ij) { m = k; Z -= v3 } } v2 === "asc" ? v.splice(0, v1 - m) : v.splice(m, v1 - m); return Z } function fB(e, i) { if (i) { e.sort(function (m, k) { var v = i === "asc" ? m.getValue() - k.getValue() : k.getValue() - m.getValue(); return v === 0 ? (i === "asc" ? m.dataIndex - k.dataIndex : k.dataIndex - m.dataIndex) : v }) } return e } function ge(v3, m, v2) { var v = 0; for (var k = 0, e = m.length; k < e; k++) { v += m[k].getValue() } var v1 = v3.get("visualDimension"); var Z; if (!m || !m.length) { Z = [NaN, NaN] } else { if (v1 === "value" && v2) { Z = [m[m.length - 1].getValue(), m[0].getValue()]; v2 === "asc" && Z.reverse() } else { var Z = [Infinity, -Infinity]; t3(m, function (Ij) { var i = Ij.getValue(v1); i < Z[0] && (Z[0] = i); i > Z[1] && (Z[1] = i) }) } } return { sum: v, dataExtent: Z } } function iP(Ik, v3, v2) { var k = 0; var Ij = Infinity; for (var v = 0, e, v1 = Ik.length; v < v1; v++) { e = Ik[v].getLayout().area; if (e) { e < Ij && (Ij = e); e > k && (k = e) } } var m = Ik.area * Ik.area; var Z = v3 * v3 * v2; return m ? AK((Z * k) / m, m / (Z * Ij)) : Infinity } function vE(Ij, Ik, e, Iq, Io) { var Ir = Ik === e.width ? 0 : 1; var It = 1 - Ir; var Z = ["x", "y"]; var v3 = ["width", "height"]; var Il = e[Z[Ir]]; var Iu = Ik ? Ij.area / Ik : 0; if (Io || Iu > e[v3[It]]) { Iu = e[v3[It]] } for (var Is = 0, v1 = Ij.length; Is < v1; Is++) { var Ip = Ij[Is]; var In = {}; var v2 = Iu ? Ip.getLayout().area / Iu : 0; var m = In[v3[It]] = AK(Iu - 2 * Iq, 0); var Im = e[Z[Ir]] + e[v3[Ir]] - Il; var k = (Is === v1 - 1 || Im < v2) ? Im : v2; var v = In[v3[Ir]] = AK(k - 2 * Iq, 0); In[Z[It]] = e[Z[It]] + ju(Iq, m / 2); In[Z[Ir]] = Il + ju(Iq, v / 2); Il += k; Ip.setLayout(In, true) } e[Z[It]] += Iu; e[v3[It]] -= Iu } function U(Im, v2, Z, Ij, Il) {
    var m = (v2 || {}).node; var Io = [Ij, Il]; if (!m || m === Z) { return Io } var v3; var Ik = Ij * Il; var Ir = Ik * Im.option.zoomToNodeRatio; while (v3 = m.parentNode) {
      var k = 0; var v = v3.children; for (var Ip = 0, Iq = v.length; Ip < Iq; Ip++) { k += v[Ip].getValue() } var v1 = m.getValue(); if (v1 === 0) {
        return Io
      } Ir *= k / v1; var e = v3.getModel(); var It = e.get(gq); var In = Math.max(It, px(e, It)); Ir += 4 * It * It + (3 * It + In) * Math.pow(Ir, 0.5); Ir > yX && (Ir = yX); m = v3
    } Ir < Ik && (Ir = Ik); var Is = Math.pow(Ir / Ik, 0.5); return [Ij * Is, Il * Is]
  } function HJ(i, v1, m) { if (v1) { return { x: v1.x, y: v1.y } } var v3 = { x: 0, y: 0 }; if (!m) { return v3 } var v = m.node; var k = v.getLayout(); if (!k) { return v3 } var Z = [k.width / 2, k.height / 2]; var e = v; while (e) { var v2 = e.getLayout(); Z[0] += v2.x; Z[1] += v2.y; e = e.parentNode } return { x: i.width / 2 - Z[0], y: i.height / 2 - Z[1] } } function wt(i, v, k, v1, Z) { var v2 = i.getLayout(); var v3 = k[Z]; var m = v3 && v3 === i; if ((v3 && !m) || (Z === k.length && i !== v1)) { return } i.setLayout({ isInView: true, invisible: !m && !v.intersect(v2), isAboveViewRoot: m }, true); var e = new CH(v.x - v2.x, v.y - v2.y, v.width, v.height); t3(i.viewChildren || [], function (Ij) { wt(Ij, e, k, v1, Z + 1) }) } function px(e) { return e.get(E3) ? e.get(un) : 0 } G(x7); pr(eR); function ip(e) { return "_EC_" + e } var hy = function (e) { this._directed = e || false; this.nodes = []; this.edges = []; this._nodesMap = {}; this._edgesMap = {}; this.data; this.edgeData }; var Db = hy.prototype; Db.type = "graph"; Db.isDirected = function () { return this._directed }; Db.addNode = function (m, e) { m = m || ("" + e); var k = this._nodesMap; if (k[ip(m)]) { if (ok) { console.error("Graph nodes have duplicate name or id") } return } var i = new sO(m, e); i.hostGraph = this; this.nodes.push(i); k[ip(m)] = i; return i }; Db.getNodeByIndex = function (e) { var i = this.data.getRawIndex(e); return this.nodes[i] }; Db.getNodeById = function (e) { return this._nodesMap[ip(e)] }; Db.addEdge = function (v, m, k) { var v1 = this._nodesMap; var e = this._edgesMap; if (typeof v === "number") { v = this.nodes[v] } if (typeof m === "number") { m = this.nodes[m] } if (!sO.isInstance(v)) { v = v1[ip(v)] } if (!sO.isInstance(m)) { m = v1[ip(m)] } if (!v || !m) { return } var i = v.id + "-" + m.id; if (e[i]) { return } var Z = new iT(v, m, k); Z.hostGraph = this; if (this._directed) { v.outEdges.push(Z); m.inEdges.push(Z) } v.edges.push(Z); if (v !== m) { m.edges.push(Z) } this.edges.push(Z); e[i] = Z; return Z }; Db.getEdgeByIndex = function (e) { var i = this.edgeData.getRawIndex(e); return this.edges[i] }; Db.getEdge = function (k, i) { if (sO.isInstance(k)) { k = k.id } if (sO.isInstance(i)) { i = i.id } var e = this._edgesMap; if (this._directed) { return e[k + "-" + i] } else { return e[k + "-" + i] || e[i + "-" + k] } }; Db.eachNode = function (k, Z) { var m = this.nodes; var e = m.length; for (var v = 0; v < e; v++) { if (m[v].dataIndex >= 0) { k.call(Z, m[v], v) } } }; Db.eachEdge = function (k, Z) { var m = this.edges; var e = m.length; for (var v = 0; v < e; v++) { if (m[v].dataIndex >= 0 && m[v].node1.dataIndex >= 0 && m[v].node2.dataIndex >= 0) { k.call(Z, m[v], v) } } }; Db.breadthFirstTraverse = function (Z, v, Il, k) { if (!sO.isInstance(v)) { v = this._nodesMap[ip(v)] } if (!v) { return } var Im = Il === "out" ? "outEdges" : (Il === "in" ? "inEdges" : "edges"); for (var v3 = 0; v3 < this.nodes.length; v3++) { this.nodes[v3].__visited = false } if (Z.call(k, v, null)) { return } var Ij = [v]; while (Ij.length) { var m = Ij.shift(); var v2 = m[Im]; for (var v3 = 0; v3 < v2.length; v3++) { var Ik = v2[v3]; var v1 = Ik.node1 === m ? Ik.node2 : Ik.node1; if (!v1.__visited) { if (Z.call(k, v1, m)) { return } Ij.push(v1); v1.__visited = true } } } }; Db.update = function () { var v1 = this.data; var Z = this.edgeData; var m = this.nodes; var k = this.edges; for (var v = 0, e = m.length; v < e; v++) { m[v].dataIndex = -1 } for (var v = 0, e = v1.count(); v < e; v++) { m[v1.getRawIndex(v)].dataIndex = v } Z.filterSelf(function (i) { var v2 = k[Z.getRawIndex(i)]; return v2.node1.dataIndex >= 0 && v2.node2.dataIndex >= 0 }); for (var v = 0, e = k.length; v < e; v++) { k[v].dataIndex = -1 } for (var v = 0, e = Z.count(); v < e; v++) { k[Z.getRawIndex(v)].dataIndex = v } }; Db.clone = function () { var Z = new hy(this._directed); var m = this.nodes; var k = this.edges; for (var v = 0; v < m.length; v++) { Z.addNode(m[v].id, m[v].dataIndex) } for (var v = 0; v < k.length; v++) { var v1 = k[v]; Z.addEdge(v1.node1.id, v1.node2.id, v1.dataIndex) } return Z }; function sO(i, e) { this.id = i == null ? "" : i; this.inEdges = []; this.outEdges = []; this.edges = []; this.hostGraph; this.dataIndex = e == null ? -1 : e } sO.prototype = { constructor: sO, degree: function () { return this.edges.length }, inDegree: function () { return this.inEdges.length }, outDegree: function () { return this.outEdges.length }, getModel: function (k) { if (this.dataIndex < 0) { return } var i = this.hostGraph; var e = i.data.getItemModel(this.dataIndex); return e.getModel(k) } }; function iT(k, i, e) { this.node1 = k; this.node2 = i; this.dataIndex = e == null ? -1 : e } iT.prototype.getModel = function (k) { if (this.dataIndex < 0) { return } var i = this.hostGraph; var e = i.edgeData.getItemModel(this.dataIndex); return e.getModel(k) }; var HM = function (i, e) { return { getValue: function (m) { var k = this[i][e]; return k.get(k.getDimension(m || "value"), this.dataIndex) }, setVisual: function (k, m) { this.dataIndex >= 0 && this[i][e].setItemVisual(this.dataIndex, k, m) }, getVisual: function (m, k) { return this[i][e].getItemVisual(this.dataIndex, m, k) }, setLayout: function (m, k) { this.dataIndex >= 0 && this[i][e].setItemLayout(this.dataIndex, m, k) }, getLayout: function () { return this[i][e].getItemLayout(this.dataIndex) }, getGraphicEl: function () { return this[i][e].getItemGraphicEl(this.dataIndex) }, getRawIndex: function () { return this[i][e].getRawIndex(this.dataIndex) } } }; Gq(sO, HM("hostGraph", "data")); Gq(iT, HM("hostGraph", "edgeData")); hy.Node = sO; hy.Edge = iT; z6(sO); z6(iT); var BJ = function (Io, v, In, Z, Ik) {
    var k = new hy(Z); for (var Iq = 0;
      Iq < Io.length; Iq++) { k.addNode(gu(Io[Iq].id, Io[Iq].name, Iq), Iq) } var v1 = []; var v2 = []; var Im = 0; for (var Iq = 0; Iq < v.length; Iq++) { var Il = v[Iq]; var Ip = Il.source; var It = Il.target; if (k.addEdge(Ip, It, Im)) { v2.push(Il); v1.push(gu(Il.id, Ip + " > " + It)); Im++ } } var Ij = In.get("coordinateSystem"); var e; if (Ij === "cartesian2d" || Ij === "polar") { e = a(Io, In) } else { var Is = fz.get(Ij); var v3 = (Is && Is.type !== "view") ? (Is.dimensions || []) : []; if (eP(v3, "value") < 0) { v3.concat(["value"]) } var Ir = yw(Io, { coordDimensions: v3 }); e = new xt(Ir, In); e.initData(Io) } var m = new xt(["value"], In); m.initData(v2, v1); Ik && Ik(e, m); BK({ mainData: e, struct: k, structAttr: "graph", datas: { node: e, edge: m }, datasAttr: { node: "data", edge: "edgeData" } }); k.update(); return k
  }; var uU = B3({ type: "series.graph", init: function (e) { uU.superApply(this, "init", arguments); this.legendDataProvider = function () { return this._categoriesData }; this.fillDataTextStyle(e.edges || e.links); this._updateCategoriesData() }, mergeOption: function (e) { uU.superApply(this, "mergeOption", arguments); this.fillDataTextStyle(e.edges || e.links); this._updateCategoriesData() }, mergeDefaultAndTheme: function (e) { uU.superApply(this, "mergeDefaultAndTheme", arguments); DA(e, ["edgeLabel"], ["show"]) }, getInitialData: function (Z, e) { var m = Z.edges || Z.links || []; var k = Z.data || Z.nodes || []; var i = this; if (k && m) { return BJ(k, m, this, true, v).data } function v(Ij, Im) { Ij.wrapMethod("getItemModel", function (In) { var Ip = i._categoriesModels; var Iq = In.getShallow("category"); var Io = Ip[Iq]; if (Io) { Io.parentModel = In.parentModel; In.parentModel = Io } return In }); var Ik = i.getModel("edgeLabel"); var v3 = new fv({ label: Ik.option }, Ik.parentModel, e); var Il = i.getModel("emphasis.edgeLabel"); var v2 = new fv({ emphasis: { label: Il.option } }, Il.parentModel, e); Im.wrapMethod("getItemModel", function (In) { In.customizeGetParent(v1); return In }); function v1(In) { In = this.parsePath(In); return (In && In[0] === "label") ? v3 : (In && In[0] === "emphasis" && In[1] === "label") ? v2 : this.parentModel } } }, getGraph: function () { return this.getData().graph }, getEdgeData: function () { return this.getGraph().edgeData }, getCategoriesData: function () { return this._categoriesData }, formatTooltip: function (v2, m, v3) { if (v3 === "edge") { var e = this.getData(); var v = this.getDataParams(v2, v3); var k = e.graph.getEdgeByIndex(v2); var i = e.getName(k.node1.dataIndex); var Z = e.getName(k.node2.dataIndex); var v1 = []; i != null && v1.push(i); Z != null && v1.push(Z); v1 = mv(v1.join(" > ")); if (v.value) { v1 += " : " + mv(v.value) } return v1 } else { return uU.superApply(this, "formatTooltip", arguments) } }, _updateCategoriesData: function () { var i = Ef(this.option.categories || [], function (k) { return k.value != null ? k : b0({ value: 0 }, k) }); var e = new xt(["value"], this); e.initData(i); this._categoriesData = e; this._categoriesModels = e.mapArray(function (k) { return e.getItemModel(k, true) }) }, setZoom: function (e) { this.option.zoom = e }, setCenter: function (e) { this.option.center = e }, isAnimationEnabled: function () { return uU.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation")) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", legendHoverLink: true, hoverAnimation: true, layout: null, focusNodeAdjacency: false, circular: { rotateLabel: false }, force: { initLayout: null, repulsion: [0, 50], gravity: 0.1, edgeLength: 30, layoutAnimation: true }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { position: "middle" }, draggable: false, roam: false, center: null, zoom: 1, nodeScaleRatio: 0.6, label: { show: false, formatter: "{b}" }, itemStyle: {}, lineStyle: { color: "#aaa", width: 1, curveness: 0, opacity: 0.5 }, emphasis: { label: { show: true } } } }); var u2 = zB.prototype; var cU = gX.prototype; function Bz(e) { return isNaN(+e.cpx1) || isNaN(+e.cpy1) } var Hq = Hw({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function (e, i) { (Bz(i) ? u2 : cU).buildPath(e, i) }, pointAt: function (e) { return Bz(this.shape) ? u2.pointAt.call(this, e) : cU.pointAt.call(this, e) }, tangentAt: function (i) { var e = this.shape; var k = Bz(e) ? [e.x2 - e.x1, e.y2 - e.y1] : cU.tangentAt.call(this, i); return wH(k, k) } }); var wK = ["fromSymbol", "toSymbol"]; function jt(e) { return "_" + e + "Type" } function Ek(m, v1, i) { var k = v1.getItemVisual(i, "color"); var Z = v1.getItemVisual(i, m); var v = v1.getItemVisual(i, m + "Size"); if (!Z || Z === "none") { return } if (!GG(v)) { v = [v, v] } var e = t9(Z, -v[0] / 2, -v[1] / 2, v[0], v[1], k); e.name = m; return e } function Hl(i) { var e = new Hq({ name: "line" }); FH(e.shape, i); return e } function FH(e, i) { var v = i[0]; var k = i[1]; var m = i[2]; e.x1 = v[0]; e.y1 = v[1]; e.x2 = k[0]; e.y2 = k[1]; e.percent = 1; if (m) { e.cpx1 = m[0]; e.cpy1 = m[1] } else { e.cpx1 = NaN; e.cpy1 = NaN } } function jQ() {
    var Ir = this; var e = Ir.childOfName("fromSymbol"); var It = Ir.childOfName("toSymbol"); var v2 = Ir.childOfName("label"); if (!e && !It && v2.ignore) { return } var k = 1; var v3 = this.parent; while (v3) { if (v3.scale) { k /= v3.scale[0] } v3 = v3.parent } var Ik = Ir.childOfName("line"); if (!this.__dirty && !Ik.__dirty) { return } var i = Ik.shape.percent; var Iq = Ik.pointAt(0); var Ip = Ik.pointAt(i); var Is = BN([], Ip, Iq); wH(Is, Is); if (e) {
      e.attr("position", Iq); var Ij = Ik.tangentAt(0); e.attr("rotation", Math.PI / 2 - Math.atan2(Ij[1], Ij[0]));
      e.attr("scale", [k * i, k * i])
    } if (It) { It.attr("position", Ip); var Ij = Ik.tangentAt(1); It.attr("rotation", -Math.PI / 2 - Math.atan2(Ij[1], Ij[0])); It.attr("scale", [k * i, k * i]) } if (!v2.ignore) { v2.attr("position", Ip); var v; var Z; var Im; var Il = 5 * k; if (v2.__position === "end") { v = [Is[0] * Il + Ip[0], Is[1] * Il + Ip[1]]; Z = Is[0] > 0.8 ? "left" : (Is[0] < -0.8 ? "right" : "center"); Im = Is[1] > 0.8 ? "top" : (Is[1] < -0.8 ? "bottom" : "middle") } else { if (v2.__position === "middle") { var m = i / 2; var Ij = Ik.tangentAt(m); var In = [Ij[1], -Ij[0]]; var v1 = Ik.pointAt(m); if (In[1] > 0) { In[0] = -In[0]; In[1] = -In[1] } v = [v1[0] + In[0] * Il, v1[1] + In[1] * Il]; Z = "center"; Im = "bottom"; var Io = -Math.atan2(Ij[1], Ij[0]); if (Ip[0] < Iq[0]) { Io = Math.PI + Io } v2.attr("rotation", Io) } else { v = [-Is[0] * Il + Iq[0], -Is[1] * Il + Iq[1]]; Z = Is[0] > 0.8 ? "right" : (Is[0] < -0.8 ? "left" : "center"); Im = Is[1] > 0.8 ? "bottom" : (Is[1] < -0.8 ? "top" : "middle") } } v2.attr({ style: { textVerticalAlign: v2.__verticalAlign || Im, textAlign: v2.__textAlign || Z }, position: v, scale: [k, k] }) }
  } function mM(k, e, i) { B8.call(this); this._createLine(k, e, i) } var lI = mM.prototype; lI.beforeUpdate = jQ; lI._createLine = function (v1, e, v) { var k = v1.hostModel; var Z = v1.getItemLayout(e); var i = Hl(Z); i.shape.percent = 0; jC(i, { shape: { percent: 1 } }, k, e); this.add(i); var m = new iR({ name: "label" }); this.add(m); o9(wK, function (v2) { var v3 = Ek(v2, v1, e); this.add(v3); this[jt(v2)] = v1.getItemVisual(e, v2) }, this); this._updateCommonStl(v1, e, v) }; lI.updateData = function (v1, e, m) { var k = v1.hostModel; var i = this.childOfName("line"); var Z = v1.getItemLayout(e); var v = { shape: {} }; FH(v.shape, Z); oS(i, v, k, e); o9(wK, function (v3) { var Ik = v1.getItemVisual(e, v3); var v2 = jt(v3); if (this[v2] !== Ik) { this.remove(this.childOfName(v3)); var Ij = Ek(v3, v1, e); this.add(Ij) } this[v2] = Ik }, this); this._updateCommonStl(v1, e, m) }; lI._updateCommonStl = function (Io, Im, Il) { var In = Io.hostModel; var v3 = this.childOfName("line"); var k = Il && Il.lineStyle; var Ij = Il && Il.hoverLineStyle; var v2 = Il && Il.labelModel; var Ir = Il && Il.hoverLabelModel; if (!Il || Io.hasItemOption) { var Iq = Io.getItemModel(Im); k = Iq.getModel("lineStyle").getLineStyle(); Ij = Iq.getModel("emphasis.lineStyle").getLineStyle(); v2 = Iq.getModel("label"); Ir = Iq.getModel("emphasis.label") } var Z = Io.getItemVisual(Im, "color"); var v = ka(Io.getItemVisual(Im, "opacity"), k.opacity, 1); v3.useStyle(De({ strokeNoScale: true, fill: "none", stroke: Z, opacity: v }, k)); v3.hoverStyle = Ij; o9(wK, function (Iv) { var Iw = this.childOfName(Iv); if (Iw) { Iw.setColor(Z); Iw.setStyle({ opacity: v }) } }, this); var Is = v2.getShallow("show"); var m = Ir.getShallow("show"); var v1 = this.childOfName("label"); var Ik; var Iu; if (Is || m) { Ik = Z || "#000"; Iu = In.getFormattedLabel(Im, "normal", Io.dataType); if (Iu == null) { var It = In.getRawValue(Im); Iu = It == null ? Io.getName(Im) : isFinite(It) ? FM(It) : It } } var i = Is ? Iu : null; var Ip = m ? kb(In.getFormattedLabel(Im, "emphasis", Io.dataType), Iu) : null; var e = v1.style; if (i != null || Ip != null) { pe(v1.style, v2, { text: i }, { autoColor: Ik }); v1.__textAlign = e.textAlign; v1.__verticalAlign = e.textVerticalAlign; v1.__position = v2.get("position") || "middle" } if (Ip != null) { v1.hoverStyle = { text: Ip, textFill: Ir.getTextColor(true), fontStyle: Ir.getShallow("fontStyle"), fontWeight: Ir.getShallow("fontWeight"), fontSize: Ir.getShallow("fontSize"), fontFamily: Ir.getShallow("fontFamily") } } else { v1.hoverStyle = { text: null } } v1.ignore = !Is && !m; yn(this) }; lI.highlight = function () { this.trigger("emphasis") }; lI.downplay = function () { this.trigger("normal") }; lI.updateLayout = function (i, e) { this.setLinePoints(i.getItemLayout(e)) }; lI.setLinePoints = function (i) { var e = this.childOfName("line"); FH(e.shape, i); e.dirty() }; mr(mM, B8); function hw(e) { this._ctor = e || mM; this.group = new B8() } var fV = hw.prototype; fV.isPersistent = function () { return true }; fV.updateData = function (v) { var e = this; var m = e.group; var k = e._lineData; e._lineData = v; if (!k) { m.removeAll() } var i = d8(v); v.diff(k).add(function (Z) { rb(e, v, Z, i) }).update(function (v1, Z) { sL(e, k, v, Z, v1, i) }).remove(function (Z) { m.remove(k.getItemGraphicEl(Z)) }).execute() }; function rb(i, Z, e, k) { var v = Z.getItemLayout(e); if (!e5(v)) { return } var m = new i._ctor(Z, e, k); Z.setItemGraphicEl(e, m); i.group.add(m) } function sL(e, v, v1, m, Z, k) { var i = v.getItemGraphicEl(m); if (!e5(v1.getItemLayout(Z))) { e.group.remove(i); return } if (!i) { i = new e._ctor(v1, Z, k) } else { i.updateData(v1, Z, k) } v1.setItemGraphicEl(Z, i); e.group.add(i) } fV.updateLayout = function () { var e = this._lineData; if (!e) { return } e.eachItemGraphicEl(function (k, i) { k.updateLayout(e, i) }, this) }; fV.incrementalPrepareUpdate = function (e) { this._seriesScope = d8(e); this._lineData = null; this.group.removeAll() }; fV.incrementalUpdate = function (v, Z) { function i(v1) { if (!v1.isGroup) { v1.incremental = v1.useHoverLayer = true } } for (var e = v.start; e < v.end; e++) { var m = Z.getItemLayout(e); if (e5(m)) { var k = new this._ctor(Z, e, this._seriesScope); k.traverse(i); this.group.add(k); Z.setItemGraphicEl(e, k) } } }; function d8(i) { var e = i.hostModel; return { lineStyle: e.getModel("lineStyle").getLineStyle(), hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label") } } fV.remove = function () { this._clearIncremental(); this._incremental = null; this.group.removeAll() }; fV._clearIncremental = function () {
    var e = this._incremental;
    if (e) { e.clearDisplaybles() }
  }; function wJ(e) { return isNaN(e[0]) || isNaN(e[1]) } function e5(e) { return !wJ(e[0]) && !wJ(e[1]) } var Bp = []; var Bo = []; var Bm = []; var q1 = kw; var rv = ck; var j9 = Math.abs; function vV(m, e, v2) { var Io = m[0]; var In = m[1]; var Ik = m[2]; var v3 = Infinity; var Ip; var v1 = v2 * v2; var k = 0.1; for (var Im = 0.1; Im <= 0.9; Im += 0.1) { Bp[0] = q1(Io[0], In[0], Ik[0], Im); Bp[1] = q1(Io[1], In[1], Ik[1], Im); var Ij = j9(rv(Bp, e) - v1); if (Ij < v3) { v3 = Ij; Ip = Im } } for (var v = 0; v < 32; v++) { var Z = Ip + k; Bo[0] = q1(Io[0], In[0], Ik[0], Ip); Bo[1] = q1(Io[1], In[1], Ik[1], Ip); Bm[0] = q1(Io[0], In[0], Ik[0], Z); Bm[1] = q1(Io[1], In[1], Ik[1], Z); var Ij = rv(Bo, e) - v1; if (j9(Ij) < 0.01) { break } var Il = rv(Bm, e) - v1; k /= 2; if (Ij < 0) { if (Il >= 0) { Ip = Ip + k } else { Ip = Ip - k } } else { if (Il >= 0) { Ip = Ip - k } else { Ip = Ip + k } } } return Ip } var m2 = function (v1, i) { var Z = []; var v3 = ED; var v2 = [[], [], []]; var m = [[], []]; var k = []; i /= 2; function e(v) { var Ij = v.getVisual("symbolSize"); if (Ij instanceof Array) { Ij = (Ij[0] + Ij[1]) / 2 } return Ij } v1.eachEdge(function (In, v) { var Ip = In.getLayout(); var Il = In.getVisual("fromSymbol"); var Ik = In.getVisual("toSymbol"); if (!Ip.__original) { Ip.__original = [uS(Ip[0]), uS(Ip[1])]; if (Ip[2]) { Ip.__original.push(uS(Ip[2])) } } var Ij = Ip.__original; if (Ip[2] != null) { yI(v2[0], Ij[0]); yI(v2[1], Ij[2]); yI(v2[2], Ij[1]); if (Il && Il != "none") { var Io = e(In.node1); var Im = vV(v2, Ij[0], Io * i); v3(v2[0][0], v2[1][0], v2[2][0], Im, Z); v2[0][0] = Z[3]; v2[1][0] = Z[4]; v3(v2[0][1], v2[1][1], v2[2][1], Im, Z); v2[0][1] = Z[3]; v2[1][1] = Z[4] } if (Ik && Ik != "none") { var Io = e(In.node2); var Im = vV(v2, Ij[1], Io * i); v3(v2[0][0], v2[1][0], v2[2][0], Im, Z); v2[1][0] = Z[1]; v2[2][0] = Z[2]; v3(v2[0][1], v2[1][1], v2[2][1], Im, Z); v2[1][1] = Z[1]; v2[2][1] = Z[2] } yI(Ip[0], v2[0]); yI(Ip[1], v2[2]); yI(Ip[2], v2[1]) } else { yI(m[0], Ij[0]); yI(m[1], Ij[1]); BN(k, m[1], m[0]); wH(k, k); if (Il && Il != "none") { var Io = e(In.node1); A6(m[0], m[0], k, Io * i) } if (Ik && Ik != "none") { var Io = e(In.node2); A6(m[1], m[1], k, -Io * i) } yI(Ip[0], m[0]); yI(Ip[1], m[1]) } }) }; var kK = ["itemStyle", "opacity"]; var Ec = ["lineStyle", "opacity"]; function fd(i, e) { return i.getVisual("opacity") || i.getModel().get(e) } function a6(m, k, v) { var i = m.getGraphicEl(); var e = fd(m, k); if (v != null) { e == null && (e = 1); e *= v } i.downplay && i.downplay(); i.traverse(function (Z) { if (Z.type !== "group") { Z.setStyle("opacity", e) } }) } function HP(m, k) { var e = fd(m, k); var i = m.getGraphicEl(); i.highlight && i.highlight(); i.traverse(function (v) { if (v.type !== "group") { v.setStyle("opacity", e) } }) } BL({
    type: "graph", init: function (e, m) { var k = new E9(); var i = new hw(); var v = this.group; this._controller = new ad(m.getZr()); this._controllerHost = { target: v }; v.add(k.group); v.add(i.group); this._symbolDraw = k; this._lineDraw = i; this._firstRender = true }, render: function (k, v1, v2) { var v = k.coordinateSystem; this._model = k; this._nodeScaleRatio = k.get("nodeScaleRatio"); var e = this._symbolDraw; var Ij = this._lineDraw; var Im = this.group; if (v.type === "view") { var Ik = { position: v.position, scale: v.scale }; if (this._firstRender) { Im.attr(Ik) } else { oS(Im, Ik, k) } } m2(k.getGraph(), this._getNodeGlobalScale(k)); var Z = k.getData(); e.updateData(Z); var v3 = k.getEdgeData(); Ij.updateData(v3); this._updateNodeAndLinkScale(); this._updateController(k, v1, v2); clearTimeout(this._layoutTimeout); var Il = k.forceLayout; var Io = k.get("force.layoutAnimation"); if (Il) { this._startForceLayoutIteration(Il, Io) } Z.eachItemGraphicEl(function (Is, Iq) { var Ir = Z.getItemModel(Iq); Is.off("drag").off("dragend"); var Ip = Ir.get("draggable"); if (Ip) { Is.on("drag", function () { if (Il) { Il.warmUp(); !this._layouting && this._startForceLayoutIteration(Il, Io); Il.setFixed(Iq); Z.setItemLayout(Iq, Is.position) } }, this).on("dragend", function () { if (Il) { Il.setUnfixed(Iq) } }, this) } Is.setDraggable(Ip && Il); Is.off("mouseover", Is.__focusNodeAdjacency); Is.off("mouseout", Is.__unfocusNodeAdjacency); if (Ir.get("focusNodeAdjacency")) { Is.on("mouseover", Is.__focusNodeAdjacency = function () { v2.dispatchAction({ type: "focusNodeAdjacency", seriesId: k.id, dataIndex: Is.dataIndex }) }); Is.on("mouseout", Is.__unfocusNodeAdjacency = function () { v2.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: k.id }) }) } }, this); Z.graph.eachEdge(function (Iq) { var Ip = Iq.getGraphicEl(); Ip.off("mouseover", Ip.__focusNodeAdjacency); Ip.off("mouseout", Ip.__unfocusNodeAdjacency); if (Iq.getModel().get("focusNodeAdjacency")) { Ip.on("mouseover", Ip.__focusNodeAdjacency = function () { v2.dispatchAction({ type: "focusNodeAdjacency", seriesId: k.id, edgeDataIndex: Iq.dataIndex }) }); Ip.on("mouseout", Ip.__unfocusNodeAdjacency = function () { v2.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: k.id }) }) } }); var In = k.get("layout") === "circular" && k.get("circular.rotateLabel"); var m = Z.getLayout("cx"); var i = Z.getLayout("cy"); Z.eachItemGraphicEl(function (Is, Ir) { var Iq = Is.getSymbolPath(); if (In) { var Iv = Z.getItemLayout(Ir); var Ip = Math.atan2(Iv[1] - i, Iv[0] - m); if (Ip < 0) { Ip = Math.PI * 2 + Ip } var Iu = Iv[0] < m; if (Iu) { Ip = Ip - Math.PI } var It = Iu ? "left" : "right"; Iq.setStyle({ textRotation: -Ip, textPosition: It, textOrigin: "center" }); Iq.hoverStyle && (Iq.hoverStyle.textPosition = It) } else { Iq.setStyle({ textRotation: 0 }) } }); this._firstRender = false }, dispose: function () { this._controller && this._controller.dispose(); this._controllerHost = {} }, focusNodeAdjacency: function (k, v, Z, v3) {
      var m = this._model.getData();
      var Ij = m.graph; var v1 = v3.dataIndex; var v2 = v3.edgeDataIndex; var i = Ij.getNodeByIndex(v1); var e = Ij.getEdgeByIndex(v2); if (!i && !e) { return } Ij.eachNode(function (Ik) { a6(Ik, kK, 0.1) }); Ij.eachEdge(function (Ik) { a6(Ik, Ec, 0.1) }); if (i) { HP(i, kK); o9(i.edges, function (Ik) { if (Ik.dataIndex < 0) { return } HP(Ik, Ec); HP(Ik.node1, kK); HP(Ik.node2, kK) }) } if (e) { HP(e, Ec); HP(e.node1, kK); HP(e.node2, kK) }
    }, unfocusNodeAdjacency: function (i, e, k, v) { var m = this._model.getData().graph; m.eachNode(function (Z) { a6(Z, kK) }); m.eachEdge(function (Z) { a6(Z, Ec) }) }, _startForceLayoutIteration: function (m, k) { var e = this; (function i() { m.step(function (v) { e.updateLayout(e._model); (e._layouting = !v) && (k ? (e._layoutTimeout = setTimeout(i, 16)) : i()) }) })() }, _updateController: function (k, e, m) { var i = this._controller; var Z = this._controllerHost; var v = this.group; i.setPointerChecker(function (v3, v1, Ij) { var v2 = v.getBoundingRect(); v2.applyTransform(v.transform); return v2.contain(v1, Ij) && !CS(v3, m, k) }); if (k.coordinateSystem.type !== "view") { i.disable(); return } i.enable(k.get("roam")); Z.zoomLimit = k.get("scaleLimit"); Z.zoom = k.coordinateSystem.getZoom(); i.off("pan").off("zoom").on("pan", function (v1) { FR(Z, v1.dx, v1.dy); m.dispatchAction({ seriesId: k.id, type: "graphRoam", dx: v1.dx, dy: v1.dy }) }).on("zoom", function (v1) { zE(Z, v1.scale, v1.originX, v1.originY); m.dispatchAction({ seriesId: k.id, type: "graphRoam", zoom: v1.scale, originX: v1.originX, originY: v1.originY }); this._updateNodeAndLinkScale(); m2(k.getGraph(), this._getNodeGlobalScale(k)); this._lineDraw.updateLayout() }, this) }, _updateNodeAndLinkScale: function () { var e = this._model; var m = e.getData(); var i = this._getNodeGlobalScale(e); var k = [i, i]; m.eachItemGraphicEl(function (Z, v) { Z.attr("scale", k) }) }, _getNodeGlobalScale: function (k) { var m = k.coordinateSystem; if (m.type !== "view") { return 1 } var v1 = this._nodeScaleRatio; var i = m.scale; var e = (i && i[0]) || 1; var Z = m.getZoom(); var v = (Z - 1) * v1 + 1; return v / e }, updateLayout: function (e) { m2(e.getGraph(), this._getNodeGlobalScale(e)); this._symbolDraw.updateLayout(); this._lineDraw.updateLayout() }, remove: function (e, i) { this._symbolDraw && this._symbolDraw.remove(); this._lineDraw && this._lineDraw.remove() }
  }); b1({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, function () { }); b1({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, function () { }); var bF = { type: "graphRoam", event: "graphRoam", update: "none" }; b1(bF, function (i, e) { e.eachComponent({ mainType: "series", query: i }, function (k) { var v = k.coordinateSystem; var m = bD(v, i); k.setCenter && k.setCenter(m.center); k.setZoom && k.setZoom(m.zoom) }) }); var cQ = function (e) { var i = e.findComponents({ mainType: "legend" }); if (!i || !i.length) { return } e.eachSeriesByType("graph", function (v1) { var k = v1.getCategoriesData(); var Z = v1.getGraph(); var v = Z.data; var m = k.mapArray(k.getName); v.filterSelf(function (v2) { var v3 = v.getItemModel(v2); var Ik = v3.getShallow("category"); if (Ik != null) { if (typeof Ik === "number") { Ik = m[Ik] } for (var Ij = 0; Ij < i.length; Ij++) { if (!i[Ij].isSelected(Ik)) { return false } } } return true }) }, this) }; var go = function (e) { var i = {}; e.eachSeriesByType("graph", function (v) { var k = v.getCategoriesData(); var Z = v.getData(); var m = {}; k.each(function (v1) { var v3 = k.getName(v1); m["ec-" + v3] = v1; var Ij = k.getItemModel(v1); var v2 = Ij.get("itemStyle.color") || v.getColorFromPalette(v3, i); k.setItemVisual(v1, "color", v2) }); if (k.count()) { Z.each(function (v1) { var v2 = Z.getItemModel(v1); var v3 = v2.getShallow("category"); if (v3 != null) { if (typeof v3 === "string") { v3 = m["ec-" + v3] } if (!Z.getItemVisual(v1, "color", true)) { Z.setItemVisual(v1, "color", k.getItemVisual(v3, "color")) } } }) } }) }; function lv(e) { if (!(e instanceof Array)) { e = [e, e] } return e } var hT = function (e) { e.eachSeriesByType("graph", function (k) { var v1 = k.getGraph(); var v = k.getEdgeData(); var v2 = lv(k.get("edgeSymbol")); var Z = lv(k.get("edgeSymbolSize")); var m = "lineStyle.color".split("."); var i = "lineStyle.opacity".split("."); v.setVisual("fromSymbol", v2 && v2[0]); v.setVisual("toSymbol", v2 && v2[1]); v.setVisual("fromSymbolSize", Z && Z[0]); v.setVisual("toSymbolSize", Z && Z[1]); v.setVisual("color", k.get(m)); v.setVisual("opacity", k.get(i)); v.each(function (v3) { var Il = v.getItemModel(v3); var Im = v1.getEdgeByIndex(v3); var Io = lv(Il.getShallow("symbol", true)); var In = lv(Il.getShallow("symbolSize", true)); var Ij = Il.get(m); var Ik = Il.get(i); switch (Ij) { case "source": Ij = Im.node1.getVisual("color"); break; case "target": Ij = Im.node2.getVisual("color"); break }Io[0] && Im.setVisual("fromSymbol", Io[0]); Io[1] && Im.setVisual("toSymbol", Io[1]); In[0] && Im.setVisual("fromSymbolSize", In[0]); In[1] && Im.setVisual("toSymbolSize", In[1]); Im.setVisual("color", Ij); Im.setVisual("opacity", Ik) }) }) }; function zg(e) { var i = e.coordinateSystem; if (i && i.type !== "view") { return } var k = e.getGraph(); k.eachNode(function (v) { var m = v.getModel(); v.setLayout([+m.get("x"), +m.get("y")]) }); Gl(k) } function Gl(e) {
    e.eachEdge(function (m) {
      var i = m.getModel().get("lineStyle.curveness") || 0; var Z = uS(m.node1.getLayout()); var v = uS(m.node2.getLayout()); var k = [Z, v]; if (+i) { k.push([(Z[0] + v[0]) / 2 - (Z[1] - v[1]) * i, (Z[1] + v[1]) / 2 - (v[0] - Z[0]) * i]) } m.setLayout(k)
    })
  } var gv = function (e, i) { e.eachSeriesByType("graph", function (v) { var v3 = v.get("layout"); var Z = v.coordinateSystem; if (Z && Z.type !== "view") { var v2 = v.getData(); var k = []; o9(Z.dimensions, function (Im) { k = k.concat(v2.mapDimension(Im, true)) }); for (var Ij = 0; Ij < v2.count(); Ij++) { var Ik = []; var Il = false; for (var v1 = 0; v1 < k.length; v1++) { var m = v2.get(k[v1], Ij); if (!isNaN(m)) { Il = true } Ik.push(m) } if (Il) { v2.setItemLayout(Ij, Z.dataToPoint(Ik)) } else { v2.setItemLayout(Ij, [NaN, NaN]) } } Gl(v2.graph) } else { if (!v3 || v3 === "none") { zg(v) } } }) }; function kJ(v) { var v1 = v.coordinateSystem; if (v1 && v1.type !== "view") { return } var Ij = v1.getBoundingRect(); var i = v.getData(); var Ik = i.graph; var m = 0; var v3 = i.getSum("value"); var v2 = Math.PI * 2 / (v3 || i.count()); var Z = Ij.width / 2 + Ij.x; var k = Ij.height / 2 + Ij.y; var e = Math.min(Ij.width, Ij.height) / 2; Ik.eachNode(function (Il) { var Im = Il.getValue("value"); m += v2 * (v3 ? Im : 1) / 2; Il.setLayout([e * Math.cos(m) + Z, e * Math.sin(m) + k]); m += v2 * (v3 ? Im : 1) / 2 }); i.setLayout({ cx: Z, cy: k }); Ik.eachEdge(function (In) { var Im = In.getModel().get("lineStyle.curveness") || 0; var Ir = uS(In.node1.getLayout()); var Ip = uS(In.node2.getLayout()); var Iq; var Io = (Ir[0] + Ip[0]) / 2; var Il = (Ir[1] + Ip[1]) / 2; if (+Im) { Im *= 3; Iq = [Z * Im + Io * (1 - Im), k * Im + Il * (1 - Im)] } In.setLayout([Ir, Ip, Iq]) }) } var sZ = function (e) { e.eachSeriesByType("graph", function (i) { if (i.get("layout") === "circular") { kJ(i) } }) }; var vA = A6; function DK(m, v2, e) { var Ij = e.rect; var v = Ij.width; var Ik = Ij.height; var k = [Ij.x + v / 2, Ij.y + Ik / 2]; var Il = e.gravity == null ? 0.1 : e.gravity; for (var v3 = 0; v3 < m.length; v3++) { var Z = m[v3]; if (!Z.p) { Z.p = G7(v * (Math.random() - 0.5) + k[0], Ik * (Math.random() - 0.5) + k[1]) } Z.pp = uS(Z.p); Z.edges = null } var v1 = 0.6; return { warmUp: function () { v1 = 0.5 }, setFixed: function (i) { m[i].fixed = true }, setUnfixed: function (i) { m[i].fixed = false }, step: function (In) { var Iq = []; var Iy = m.length; for (var Ir = 0; Ir < v2.length; Ir++) { var It = v2[Ir]; var Iu = It.n1; var Is = It.n2; BN(Iq, Is.p, Iu.p); var Iv = ey(Iq) - It.d; var Iw = Is.w / (Iu.w + Is.w); if (isNaN(Iw)) { Iw = 0 } wH(Iq, Iq); !Iu.fixed && vA(Iu.p, Iu.p, Iq, Iw * Iv * v1); !Is.fixed && vA(Is.p, Is.p, Iq, -(1 - Iw) * Iv * v1) } for (var Ir = 0; Ir < Iy; Ir++) { var Im = m[Ir]; if (!Im.fixed) { BN(Iq, k, Im.p); vA(Im.p, Im.p, Iq, Il * v1) } } for (var Ir = 0; Ir < Iy; Ir++) { var Iu = m[Ir]; for (var Io = Ir + 1; Io < Iy; Io++) { var Is = m[Io]; BN(Iq, Is.p, Iu.p); var Iv = ey(Iq); if (Iv === 0) { GL(Iq, Math.random() - 0.5, Math.random() - 0.5); Iv = 1 } var Ip = (Iu.rep + Is.rep) / Iv / Iv; !Iu.fixed && vA(Iu.pp, Iu.pp, Iq, Ip); !Is.fixed && vA(Is.pp, Is.pp, Iq, -Ip) } } var Ix = []; for (var Ir = 0; Ir < Iy; Ir++) { var Im = m[Ir]; if (!Im.fixed) { BN(Ix, Im.p, Im.pp); vA(Im.p, Im.p, Ix, v1); yI(Im.pp, Im.p) } } v1 = v1 * 0.992; In && In(m, v2, v1 < 0.01) } } } var yv = function (e) { e.eachSeriesByType("graph", function (Io) { var v2 = Io.coordinateSystem; if (v2 && v2.type !== "view") { return } if (Io.get("layout") === "force") { var v3 = Io.preservedPoints || {}; var Ir = Io.getGraph(); var k = Ir.data; var In = Ir.edgeData; var Ik = Io.getModel("force"); var Im = Ik.get("initLayout"); if (Io.preservedPoints) { k.each(function (Is) { var It = k.getId(Is); k.setItemLayout(Is, v3[It] || [NaN, NaN]) }) } else { if (!Im || Im === "none") { zg(Io) } else { if (Im === "circular") { kJ(Io) } } } var Z = k.getDataExtent("value"); var Il = In.getDataExtent("value"); var Iq = Ik.get("repulsion"); var v = Ik.get("edgeLength"); if (!GG(Iq)) { Iq = [Iq, Iq] } if (!GG(v)) { v = [v, v] } v = [v[1], v[0]]; var i = k.mapArray("value", function (Iv, It) { var Is = k.getItemLayout(It); var Iu = EQ(Iv, Z, Iq); if (isNaN(Iu)) { Iu = (Iq[0] + Iq[1]) / 2 } return { w: Iu, rep: Iu, fixed: k.getItemModel(It).get("fixed"), p: (!Is || isNaN(Is[0]) || isNaN(Is[1])) ? null : Is } }); var v1 = In.mapArray("value", function (Iu, Is) { var It = Ir.getEdgeByIndex(Is); var Iv = EQ(Iu, Il, v); if (isNaN(Iv)) { Iv = (v[0] + v[1]) / 2 } return { n1: i[It.node1.dataIndex], n2: i[It.node2.dataIndex], d: Iv, curveness: It.getModel().get("lineStyle.curveness") || 0 } }); var v2 = Io.coordinateSystem; var Ip = v2.getBoundingRect(); var Ij = DK(i, v1, { rect: Ip, gravity: Ik.get("gravity") }); var m = Ij.step; Ij.step = function (Is) { for (var Iu = 0, It = i.length; Iu < It; Iu++) { if (i[Iu].fixed) { yI(i[Iu].p, Ir.getNodeByIndex(Iu).getLayout()) } } m(function (Iw, Iz, Iv) { for (var IA = 0, Iy = Iw.length; IA < Iy; IA++) { if (!Iw[IA].fixed) { Ir.getNodeByIndex(IA).setLayout(Iw[IA].p) } v3[k.getId(IA)] = Iw[IA].p } for (var IA = 0, Iy = Iz.length; IA < Iy; IA++) { var IB = Iz[IA]; var Ix = Ir.getEdgeByIndex(IA); var IE = IB.n1.p; var ID = IB.n2.p; var IC = Ix.getLayout(); IC = IC ? IC.slice() : []; IC[0] = IC[0] || []; IC[1] = IC[1] || []; yI(IC[0], IE); yI(IC[1], ID); if (+IB.curveness) { IC[2] = [(IE[0] + ID[0]) / 2 - (IE[1] - ID[1]) * IB.curveness, (IE[1] + ID[1]) / 2 - (ID[0] - IE[0]) * IB.curveness] } Ix.setLayout(IC) } Is && Is(Iv) }) }; Io.forceLayout = Ij; Io.preservedPoints = v3; Ij.step() } else { Io.forceLayout = null } }) }; function rT(i, m, e) { var k = i.getBoxLayoutParams(); k.aspect = e; return kV(k, { width: m.getWidth(), height: m.getHeight() }) } var aP = function (e, k) {
    var i = []; e.eachSeriesByType("graph", function (v2) {
      var Ip = v2.get("coordinateSystem"); if (!Ip || Ip === "view") {
        var Ij = v2.getData(); var Ik = Ij.mapArray(function (Iq) { var Ir = Ij.getItemModel(Iq); return [+Ir.get("x"), +Ir.get("y")] }); var v3 = []; var Io = []; oI(Ik, v3, Io); if (Io[0] - v3[0] === 0) { Io[0] += 1; v3[0] -= 1 } if (Io[1] - v3[1] === 0) { Io[1] += 1; v3[1] -= 1 } var v = (Io[0] - v3[0]) / (Io[1] - v3[1]); var Im = rT(v2, k, v); if (isNaN(v)) {
          v3 = [Im.x, Im.y]; Io = [Im.x + Im.width, Im.y + Im.height]
        } var m = Io[0] - v3[0]; var In = Io[1] - v3[1]; var Il = Im.width; var v1 = Im.height; var Z = v2.coordinateSystem = new Cl(); Z.zoomLimit = v2.get("scaleLimit"); Z.setBoundingRect(v3[0], v3[1], m, In); Z.setViewRect(Im.x, Im.y, Il, v1); Z.setCenter(v2.get("center")); Z.setZoom(v2.get("zoom")); i.push(Z)
      }
    }); return i
  }; eb(cQ); G(ml("graph", "circle", null)); G(go); G(hT); pr(gv); pr(sZ); pr(yv); wA("graphView", { create: aP }); var J = nU.extend({ type: "series.gauge", getInitialData: function (i, e) { var k = i.data || []; if (!GG(k)) { k = [k] } i.data = k; return xi(this, ["value"]) }, defaultOption: { zlevel: 0, z: 2, center: ["50%", "50%"], legendHoverLink: true, radius: "75%", startAngle: 225, endAngle: -45, clockwise: true, min: 0, max: 100, splitNumber: 10, axisLine: { show: true, lineStyle: { color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]], width: 30 } }, splitLine: { show: true, length: 30, lineStyle: { color: "#eee", width: 2, type: "solid" } }, axisTick: { show: true, splitNumber: 5, length: 8, lineStyle: { color: "#eee", width: 1, type: "solid" } }, axisLabel: { show: true, distance: 5, color: "auto" }, pointer: { show: true, length: "80%", width: 8 }, itemStyle: { color: "auto" }, title: { show: true, offsetCenter: [0, "-40%"], color: "#333", fontSize: 15 }, detail: { show: true, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: null, padding: [5, 10], offsetCenter: [0, "40%"], color: "auto", fontSize: 30 } } }); var xR = mm.extend({ type: "echartsGaugePointer", shape: { angle: 0, width: 10, r: 10, x: 0, y: 0 }, buildPath: function (v3, v) { var Z = Math.cos; var m = Math.sin; var e = v.r; var i = v.width; var k = v.angle; var v2 = v.x - Z(k) * i * (i >= e / 3 ? 1 : 2); var v1 = v.y - m(k) * i * (i >= e / 3 ? 1 : 2); k = v.angle - Math.PI / 2; v3.moveTo(v2, v1); v3.lineTo(v.x + Z(k) * i, v.y + m(k) * i); v3.lineTo(v.x + Z(v.angle) * e, v.y + m(v.angle) * e); v3.lineTo(v.x - Z(k) * i, v.y - m(k) * i); v3.lineTo(v2, v1); return } }); function lT(v, v1) { var i = v.get("center"); var k = v1.getWidth(); var v2 = v1.getHeight(); var v3 = Math.min(k, v2); var Z = zN(i[0], v1.getWidth()); var m = zN(i[1], v1.getHeight()); var e = zN(v.get("radius"), v3 / 2); return { cx: Z, cy: m, r: e } } function gk(e, i) { if (i) { if (typeof i === "string") { e = i.replace("{value}", e != null ? e : "") } else { if (typeof i === "function") { e = i(e) } } } return e } var GX = Math.PI * 2; var sV = dF.extend({
    type: "gauge", render: function (k, i, v) { this.group.removeAll(); var m = k.get("axisLine.lineStyle.color"); var e = lT(k, v); this._renderMain(k, i, v, m, e) }, dispose: function () { }, _renderMain: function (v3, It, v1, v2, Z) { var v = this.group; var m = v3.getModel("axisLine"); var Ik = m.getModel("lineStyle"); var Ir = v3.get("clockwise"); var Io = -v3.get("startAngle") / 180 * Math.PI; var Im = -v3.get("endAngle") / 180 * Math.PI; var Ij = (Im - Io) % GX; var Iq = Io; var Il = Ik.get("width"); for (var Ip = 0; Ip < v2.length; Ip++) { var e = Math.min(Math.max(v2[Ip][0], 0), 1); var Im = Io + Ij * e; var In = new tx({ shape: { startAngle: Iq, endAngle: Im, cx: Z.cx, cy: Z.cy, clockwise: Ir, r0: Z.r - Il, r: Z.r }, silent: true }); In.setStyle({ fill: v2[Ip][1] }); In.setStyle(Ik.getLineStyle(["color", "borderWidth", "borderColor"])); v.add(In); Iq = Im } var k = function (Iv) { if (Iv <= 0) { return v2[0][1] } for (var Iu = 0; Iu < v2.length; Iu++) { if (v2[Iu][0] >= Iv && (Iu === 0 ? 0 : v2[Iu - 1][0]) < Iv) { return v2[Iu][1] } } return v2[Iu - 1][1] }; if (!Ir) { var Is = Io; Io = Im; Im = Is } this._renderTicks(v3, It, v1, k, Z, Io, Im, Ir); this._renderPointer(v3, It, v1, k, Z, Io, Im, Ir); this._renderTitle(v3, It, v1, k, Z); this._renderDetail(v3, It, v1, k, Z) }, _renderTicks: function (Iw, IJ, It, m, Iq, IA, Ix, ID) { var Io = this.group; var k = Iq.cx; var e = Iq.cy; var Iv = Iq.r; var IF = +Iw.get("min"); var In = +Iw.get("max"); var II = Iw.getModel("splitLine"); var IG = Iw.getModel("axisTick"); var Ip = Iw.getModel("axisLabel"); var v3 = Iw.get("splitNumber"); var v1 = IG.get("splitNumber"); var IC = zN(II.get("length"), Iv); var Ir = zN(IG.get("length"), Iv); var IE = IA; var Ik = (Ix - IA) / v3; var IH = Ik / v1; var Iu = II.getModel("lineStyle").getLineStyle(); var Ij = IG.getModel("lineStyle").getLineStyle(); for (var IB = 0; IB <= v3; IB++) { var v2 = Math.cos(IE); var Z = Math.sin(IE); if (II.get("show")) { var Im = new zB({ shape: { x1: v2 * Iv + k, y1: Z * Iv + e, x2: v2 * (Iv - IC) + k, y2: Z * (Iv - IC) + e }, style: Iu, silent: true }); if (Iu.stroke === "auto") { Im.setStyle({ stroke: m(IB / v3) }) } Io.add(Im) } if (Ip.get("show")) { var Il = gk(FM(IB / v3 * (In - IF) + IF), Ip.get("formatter")); var v = Ip.get("distance"); var Iy = m(IB / v3); Io.add(new iR({ style: pe({}, Ip, { text: Il, x: v2 * (Iv - IC - v) + k, y: Z * (Iv - IC - v) + e, textVerticalAlign: Z < -0.4 ? "top" : (Z > 0.4 ? "bottom" : "middle"), textAlign: v2 < -0.4 ? "left" : (v2 > 0.4 ? "right" : "center") }, { autoColor: Iy }), silent: true })) } if (IG.get("show") && IB !== v3) { for (var Iz = 0; Iz <= v1; Iz++) { var v2 = Math.cos(IE); var Z = Math.sin(IE); var Is = new zB({ shape: { x1: v2 * Iv + k, y1: Z * Iv + e, x2: v2 * (Iv - Ir) + k, y2: Z * (Iv - Ir) + e }, silent: true, style: Ij }); if (Ij.stroke === "auto") { Is.setStyle({ stroke: m((IB + Iz / v1) / v3) }) } Io.add(Is); IE += IH } IE -= IH } else { IE += Ik } } }, _renderPointer: function (k, v1, v2, In, m, Ij, i, e) {
      var Im = this.group; var Z = this._data; if (!k.get("pointer.show")) { Z && Z.eachItemGraphicEl(function (Io) { Im.remove(Io) }); return } var Ik = [+k.get("min"), +k.get("max")]; var Il = [Ij, i]; var v = k.getData(); var v3 = v.mapDimension("value"); v.diff(Z).add(function (Io) { var Ip = new xR({ shape: { angle: Ij } }); jC(Ip, { shape: { angle: EQ(v.get(v3, Io), Ik, Il, true) } }, k); Im.add(Ip); v.setItemGraphicEl(Io, Ip) }).update(function (Ip, Io) {
        var Iq = Z.getItemGraphicEl(Io); oS(Iq, { shape: { angle: EQ(v.get(v3, Ip), Ik, Il, true) } }, k);
        Im.add(Iq); v.setItemGraphicEl(Ip, Iq)
      }).remove(function (Io) { var Ip = Z.getItemGraphicEl(Io); Im.remove(Ip) }).execute(); v.eachItemGraphicEl(function (Ir, Io) { var Iq = v.getItemModel(Io); var Ip = Iq.getModel("pointer"); Ir.setShape({ x: m.cx, y: m.cy, width: zN(Ip.get("width"), m.r), r: zN(Ip.get("length"), m.r) }); Ir.useStyle(Iq.getModel("itemStyle").getItemStyle()); if (Ir.style.fill === "auto") { Ir.setStyle("fill", In(EQ(v.get(v3, Io), Ik, [0, 1], true))) } yn(Ir, Iq.getModel("emphasis.itemStyle").getItemStyle()) }); this._data = v
    }, _renderTitle: function (k, Z, v1, Im, m) { var v = k.getData(); var v2 = v.mapDimension("value"); var e = k.getModel("title"); if (e.get("show")) { var i = e.get("offsetCenter"); var Ij = m.cx + zN(i[0], m.r); var v3 = m.cy + zN(i[1], m.r); var Il = +k.get("min"); var In = +k.get("max"); var Ik = k.getData().get(v2, 0); var Io = Im(EQ(Ik, [Il, In], [0, 1], true)); this.group.add(new iR({ silent: true, style: pe({}, e, { x: Ij, y: v3, text: v.getName(0), textAlign: "center", textVerticalAlign: "middle" }, { autoColor: Io, forceRich: true }) })) } }, _renderDetail: function (k, Z, v1, In, m) { var v2 = k.getModel("detail"); var Il = +k.get("min"); var Io = +k.get("max"); if (v2.get("show")) { var i = v2.get("offsetCenter"); var Ij = m.cx + zN(i[0], m.r); var v3 = m.cy + zN(i[1], m.r); var e = zN(v2.get("width"), m.r); var Im = zN(v2.get("height"), m.r); var v = k.getData(); var Ik = v.get(v.mapDimension("value"), 0); var Ip = In(EQ(Ik, [Il, Io], [0, 1], true)); this.group.add(new iR({ silent: true, style: pe({}, v2, { x: Ij, y: v3, text: gk(Ik, v2.get("formatter")), textWidth: isNaN(e) ? null : e, textHeight: isNaN(Im) ? null : Im, textAlign: "center", textVerticalAlign: "middle" }, { autoColor: Ip, forceRich: true }) })) } }
  }); var iu = B3({ type: "series.funnel", init: function (e) { iu.superApply(this, "init", arguments); this.legendDataProvider = function () { return this.getRawData() }; this._defaultLabelLine(e) }, getInitialData: function (i, e) { return xi(this, ["value"]) }, _defaultLabelLine: function (i) { DA(i, "labelLine", ["show"]); var e = i.labelLine; var k = i.emphasis.labelLine; e.show = e.show && i.label.show; k.show = k.show && i.emphasis.label.show }, getDataParams: function (e) { var k = this.getData(); var m = iu.superCall(this, "getDataParams", e); var v = k.mapDimension("value"); var i = k.getSum(v); m.percent = !i ? 0 : +(k.get(v, e) / i * 100).toFixed(2); m.$vars.push("percent"); return m }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: true, left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", gap: 0, funnelAlign: "center", label: { show: true, position: "outer" }, labelLine: { show: true, length: 20, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderColor: "#fff", borderWidth: 1 }, emphasis: { label: { show: true } } } }); function ah(v, k) { B8.call(this); var m = new ia(); var v1 = new z7(); var Z = new iR(); this.add(m); this.add(v1); this.add(Z); this.updateData(v, k, true); function i() { v1.ignore = v1.hoverIgnore; Z.ignore = Z.hoverIgnore } function e() { v1.ignore = v1.normalIgnore; Z.ignore = Z.normalIgnore } this.on("emphasis", i).on("normal", e).on("mouseover", i).on("mouseout", e) } var I = ah.prototype; var nb = ["itemStyle", "opacity"]; I.updateData = function (k, v2, Z) { var v1 = this.childAt(0); var e = k.hostModel; var Ij = k.getItemModel(v2); var m = k.getItemLayout(v2); var v = k.getItemModel(v2).get(nb); v = v == null ? 1 : v; v1.useStyle({}); if (Z) { v1.setShape({ points: m.points }); v1.setStyle({ opacity: 0 }); jC(v1, { style: { opacity: v } }, e, v2) } else { oS(v1, { style: { opacity: v }, shape: { points: m.points } }, e, v2) } var i = Ij.getModel("itemStyle"); var v3 = k.getItemVisual(v2, "color"); v1.setStyle(De({ lineJoin: "round", fill: v3 }, i.getItemStyle(["opacity"]))); v1.hoverStyle = i.getModel("emphasis").getItemStyle(); this._updateLabel(k, v2); yn(this) }; I._updateLabel = function (Z, v3) { var v = this.childAt(1); var i = this.childAt(2); var k = Z.hostModel; var Ik = Z.getItemModel(v3); var v2 = Z.getItemLayout(v3); var Im = v2.label; var Ij = Z.getItemVisual(v3, "color"); oS(v, { shape: { points: Im.linePoints || Im.linePoints } }, k, v3); oS(i, { style: { x: Im.x, y: Im.y } }, k, v3); i.attr({ rotation: Im.rotation, origin: [Im.x, Im.y], z2: 10 }); var Il = Ik.getModel("label"); var v1 = Ik.getModel("emphasis.label"); var m = Ik.getModel("labelLine"); var e = Ik.getModel("emphasis.labelLine"); var Ij = Z.getItemVisual(v3, "color"); BD(i.style, i.hoverStyle = {}, Il, v1, { labelFetcher: Z.hostModel, labelDataIndex: v3, defaultText: Z.getName(v3), autoColor: Ij, useInsideStyle: !!Im.inside }, { textAlign: Im.textAlign, textVerticalAlign: Im.verticalAlign }); i.ignore = i.normalIgnore = !Il.get("show"); i.hoverIgnore = !v1.get("show"); v.ignore = v.normalIgnore = !m.get("show"); v.hoverIgnore = !e.get("show"); v.setStyle({ stroke: Ij }); v.setStyle(m.getModel("lineStyle").getLineStyle()); v.hoverStyle = e.getModel("lineStyle").getLineStyle() }; mr(ah, B8); var xB = dF.extend({ type: "funnel", render: function (i, e, k) { var m = i.getData(); var Z = this._data; var v = this.group; m.diff(Z).add(function (v1) { var v2 = new ah(m, v1); m.setItemGraphicEl(v1, v2); v.add(v2) }).update(function (v3, v2) { var v1 = Z.getItemGraphicEl(v2); v1.updateData(m, v3); v.add(v1); m.setItemGraphicEl(v3, v1) }).remove(function (v1) { var v2 = Z.getItemGraphicEl(v1); v.remove(v2) }).execute(); this._data = m }, remove: function () { this.group.removeAll(); this._data = null }, dispose: function () { } }); function rS(e, i) {
    return kV(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() })
  } function nw(Z, v) { var v3 = Z.mapDimension("value"); var k = Z.mapArray(v3, function (i) { return i }); var v2 = []; var v1 = v === "ascending"; for (var m = 0, e = Z.count(); m < e; m++) { v2[m] = m } if (typeof v === "function") { v2.sort(v) } else { if (v !== "none") { v2.sort(function (Ij, i) { return v1 ? k[Ij] - k[i] : k[i] - k[Ij] }) } } return v2 } function zp(e) { e.each(function (Io) { var Iq = e.getItemModel(Io); var Ir = Iq.getModel("label"); var v2 = Ir.get("position"); var v = Iq.getModel("labelLine"); var v3 = e.getItemLayout(Io); var Ip = v3.points; var Ij = v2 === "inner" || v2 === "inside" || v2 === "center"; var m; var v1; var Z; var Im; if (Ij) { v1 = (Ip[0][0] + Ip[1][0] + Ip[2][0] + Ip[3][0]) / 4; Z = (Ip[0][1] + Ip[1][1] + Ip[2][1] + Ip[3][1]) / 4; m = "center"; Im = [[v1, Z], [v1, Z]] } else { var k; var Il; var i; var In = v.get("length"); if (v2 === "left") { k = (Ip[3][0] + Ip[0][0]) / 2; Il = (Ip[3][1] + Ip[0][1]) / 2; i = k - In; v1 = i - 5; m = "right" } else { k = (Ip[1][0] + Ip[2][0]) / 2; Il = (Ip[1][1] + Ip[2][1]) / 2; i = k + In; v1 = i + 5; m = "left" } var Ik = Il; Im = [[k, Il], [i, Ik]]; Z = Ik } v3.label = { linePoints: Im, x: v1, y: Z, verticalAlign: "middle", textAlign: m, inside: Ij } }) } var hD = function (e, i, k) { e.eachSeriesByType("funnel", function (Io) { var Iy = Io.getData(); var v = Iy.mapDimension("value"); var Iw = Io.get("sort"); var It = rS(Io, i); var v2 = nw(Iy, Iw); var Ij = [zN(Io.get("minSize"), It.width), zN(Io.get("maxSize"), It.width)]; var Ip = Iy.getDataExtent(v); var Iq = Io.get("min"); var Iu = Io.get("max"); if (Iq == null) { Iq = Math.min(Ip[0], 0) } if (Iu == null) { Iu = Ip[1] } var m = Io.get("funnelAlign"); var In = Io.get("gap"); var Ir = (It.height - In * (Iy.count() - 1)) / Iy.count(); var v3 = It.y; var Il = function (IA, Iz) { var ID = Iy.get(v, IA) || 0; var IC = EQ(ID, [Iq, Iu], Ij, true); var IB; switch (m) { case "left": IB = It.x; break; case "center": IB = It.x + (It.width - IC) / 2; break; case "right": IB = It.x + It.width - IC; break }return [[IB, Iz], [IB + IC, Iz]] }; if (Iw === "ascending") { Ir = -Ir; In = -In; v3 += It.height; v2 = v2.reverse() } for (var Iv = 0; Iv < v2.length; Iv++) { var Ik = v2[Iv]; var Ix = v2[Iv + 1]; var Is = Iy.getItemModel(Ik); var Im = Is.get("itemStyle.height"); if (Im == null) { Im = Ir } else { Im = zN(Im, It.height); if (Iw === "ascending") { Im = -Im } } var v1 = Il(Ik, v3); var Z = Il(Ix, v3 + Im); v3 += Im + In; Iy.setItemLayout(Ik, { points: v1.concat(Z.slice().reverse()) }) } zp(Iy) }) }; G(eN("funnel")); pr(hD); eb(D7("funnel")); var of = function (e) { iF(e); o5(e) }; function iF(e) { if (e.parallel) { return } var i = false; o9(e.series, function (k) { if (k && k.type === "parallel") { i = true } }); if (i) { e.parallel = [{}] } } function o5(e) { var i = mp(e.parallelAxis); o9(i, function (v) { if (!tJ(v)) { return } var k = v.parallelIndex || 0; var m = mp(e.parallel)[k]; if (m && m.parallelAxisDefault) { v4(v, m.parallelAxisDefault, false) } }) } var yM = function (m, v, k, e, i) { BS.call(this, m, v, k); this.type = e || "value"; this.axisIndex = i }; yM.prototype = { constructor: yM, model: null, isHorizontal: function () { return this.coordinateSystem.getModel().get("layout") !== "horizontal" } }; mr(yM, BS); var nv = function (v2, m, Ik, e, Ij, Z) { m[0] = rw(m[0], Ik); m[1] = rw(m[1], Ik); v2 = v2 || 0; var k = Ik[1] - Ik[0]; if (Ij != null) { Ij = rw(Ij, [0, k]) } if (Z != null) { Z = Math.max(Z, Ij != null ? Ij : 0) } if (e === "all") { Ij = Z = Math.abs(m[1] - m[0]); e = 0 } var v3 = fM(m, e); m[e] += v2; var i = Ij || 0; var v1 = Ik.slice(); v3.sign < 0 ? (v1[0] += i) : (v1[1] -= i); m[e] = rw(m[e], v1); var v = fM(m, e); if (Ij != null && (v.sign !== v3.sign || v.span < Ij)) { m[1 - e] = m[e] + v3.sign * Ij } var v = fM(m, e); if (Z != null && v.span > Z) { m[1 - e] = m[e] + v.sign * Z } return m }; function fM(i, k) { var e = i[k] - i[1 - k]; return { span: Math.abs(e), sign: e > 0 ? -1 : e < 0 ? 1 : k ? -1 : 1 } } function rw(e, i) { return Math.min(i[1], Math.max(i[0], e)) } var t1 = o9; var js = Math.min; var AI = Math.max; var vY = Math.floor; var oQ = Math.ceil; var FL = FM; var yD = Math.PI; function d1(i, e, k) { this._axesMap = CJ(); this._axesLayout = {}; this.dimensions = i.dimensions; this._rect; this._model = i; this._init(i, e, k) } d1.prototype = {
    type: "parallel", constructor: d1, _init: function (k, e, m) { var v = k.dimensions; var i = k.parallelAxisIndex; t1(v, function (Ik, Z) { var v3 = i[Z]; var v2 = e.getComponent("parallelAxis", v3); var Ij = this._axesMap.set(Ik, new yM(Ik, nq(v2), [0, 0], v2.get("type"), v3)); var v1 = Ij.type === "category"; Ij.onBand = v1 && v2.get("boundaryGap"); Ij.inverse = v2.get("inverse"); v2.axis = Ij; Ij.model = v2; Ij.coordinateSystem = v2.coordinateSystem = this }, this) }, update: function (e, i) { this._updateAxesFromSeries(this._model, e) }, containPoint: function (e) { var v1 = this._makeLayoutInfo(); var k = v1.axisBase; var Z = v1.layoutBase; var v = v1.pixelDimIndex; var m = e[1 - v]; var i = e[v]; return m >= k && m <= k + v1.axisLength && i >= Z && i <= Z + v1.layoutLength }, getModel: function () { return this._model }, _updateAxesFromSeries: function (i, e) { e.eachSeries(function (k) { if (!i.contains(k, e)) { return } var m = k.getData(); t1(this.dimensions, function (Z) { var v = this._axesMap.get(Z); v.scale.unionExtentFromData(m, m.mapDimension(Z)); nL(v.scale, v.model) }, this) }, this) }, resize: function (e, i) { this._rect = kV(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }); this._layoutAxes() }, getRect: function () { return this._rect }, _makeLayoutInfo: function () {
      var m = this._model; var i = this._rect; var Z = ["x", "y"]; var v1 = ["width", "height"]; var Ip = m.get("layout"); var v = Ip === "horizontal" ? 0 : 1; var Im = i[v1[v]]; var e = [0, Im]; var Ik = this.dimensions.length; var Io = Cc(m.get("axisExpandWidth"), e); var v3 = Cc(m.get("axisExpandCount") || 0, [0, Ik]); var Il = m.get("axisExpandable") && Ik > 3 && Ik > v3 && v3 > 1 && Io > 0 && Im > 0;
      var Iq = m.get("axisExpandWindow"); var v2; if (!Iq) { v2 = Cc(Io * (v3 - 1), e); var Ij = m.get("axisExpandCenter") || vY(Ik / 2); Iq = [Io * Ij - v2 / 2]; Iq[1] = Iq[0] + v2 } else { v2 = Cc(Iq[1] - Iq[0], e); Iq[1] = Iq[0] + v2 } var k = (Im - v2) / (Ik - v3); k < 3 && (k = 0); var In = [vY(FL(Iq[0] / Io, 1)) + 1, oQ(FL(Iq[1] / Io, 1)) - 1]; var Ir = k / Io * Iq[0]; return { layout: Ip, pixelDimIndex: v, layoutBase: i[Z[v]], layoutLength: Im, axisBase: i[Z[1 - v]], axisLength: i[v1[1 - v]], axisExpandable: Il, axisExpandWidth: Io, axisCollapseWidth: k, axisExpandWindow: Iq, axisCount: Ik, winInnerIndices: In, axisExpandWindow0Pos: Ir }
    }, _layoutAxes: function () { var k = this._rect; var v = this._axesMap; var i = this.dimensions; var m = this._makeLayoutInfo(); var e = m.layout; v.each(function (v1) { var v2 = [0, m.axisLength]; var Z = v1.inverse ? 1 : 0; v1.setExtent(v2[Z], v2[1 - Z]) }); t1(i, function (Im, v2) { var v1 = (m.axisExpandable ? gx : fF)(v2, m); var Il = { horizontal: { x: v1.position, y: m.axisLength }, vertical: { x: 0, y: v1.position } }; var Ik = { horizontal: yD / 2, vertical: 0 }; var Z = [Il[e].x + k.x, Il[e].y + k.y]; var Ij = Ik[e]; var v3 = CB(); ki(v3, v3, Ij); vm(v3, v3, Z); this._axesLayout[Im] = { position: Z, rotation: Ij, transform: v3, axisNameAvailableWidth: v1.axisNameAvailableWidth, axisLabelShow: v1.axisLabelShow, nameTruncateMaxWidth: v1.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1 } }, this) }, getAxis: function (e) { return this._axesMap.get(e) }, dataToPoint: function (e, i) { return this.axisCoordToPoint(this._axesMap.get(i).dataToCoord(e), i) }, eachActiveState: function (v1, Io, k, v) { k == null && (k = 0); v == null && (v = v1.count()); var Ik = this._axesMap; var e = this.dimensions; var m = []; var v2 = []; o9(e, function (Ip) { m.push(v1.mapDimension(Ip)); v2.push(Ik.get(Ip).model) }); var Ij = this.hasAxisBrushed(); for (var Il = k; Il < v; Il++) { var v3; if (!Ij) { v3 = "normal" } else { v3 = "active"; var Im = v1.getValues(m, Il); for (var Z = 0, In = e.length; Z < In; Z++) { var i = v2[Z].getActiveState(Im[Z]); if (i === "inactive") { v3 = "inactive"; break } } } Io(v3, Il) } }, hasAxisBrushed: function () { var v = this.dimensions; var m = this._axesMap; var i = false; for (var k = 0, e = v.length; k < e; k++) { if (m.get(v[k]).model.getActiveState() !== "normal") { i = true } } return i }, axisCoordToPoint: function (k, i) { var e = this._axesLayout[i]; return v7([k, 0], e.transform) }, getAxisLayout: function (e) { return C5(this._axesLayout[e]) }, getSlidedAxisExpandWindow: function (Ij) { var m = this._makeLayoutInfo(); var Il = m.pixelDimIndex; var i = m.axisExpandWindow.slice(); var Z = i[1] - i[0]; var Im = [0, m.axisExpandWidth * (m.axisCount - 1)]; if (!this.containPoint(Ij)) { return { behavior: "none", axisExpandWindow: i } } var v3 = Ij[Il] - m.layoutBase - m.axisExpandWindow0Pos; var Ik; var e = "slide"; var v = m.axisCollapseWidth; var v2 = this._model.get("axisExpandSlideTriggerArea"); var k = v2[0] != null; if (v) { if (k && v && v3 < Z * v2[0]) { e = "jump"; Ik = v3 - Z * v2[2] } else { if (k && v && v3 > Z * (1 - v2[0])) { e = "jump"; Ik = v3 - Z * (1 - v2[2]) } else { (Ik = v3 - Z * v2[1]) >= 0 && (Ik = v3 - Z * (1 - v2[1])) <= 0 && (Ik = 0) } } Ik *= m.axisExpandWidth / v; Ik ? nv(Ik, i, Im, "all") : (e = "none") } else { var Z = i[1] - i[0]; var v1 = Im[1] * v3 / Z; i = [AI(0, v1 - Z / 2)]; i[1] = js(Im[1], i[0] + Z); i[0] = i[1] - Z } return { axisExpandWindow: i, behavior: e } }
  }; function Cc(e, i) { return js(AI(e, i[0]), i[1]) } function fF(e, k) { var i = k.layoutLength / (k.axisCount - 1); return { position: i * e, axisNameAvailableWidth: i, axisLabelShow: true } } function gx(Ik, i) { var e = i.layoutLength; var v1 = i.axisExpandWidth; var Ij = i.axisCount; var m = i.axisCollapseWidth; var v2 = i.winInnerIndices; var v; var Z = m; var k = false; var v3; if (Ik < v2[0]) { v = Ik * m; v3 = m } else { if (Ik <= v2[1]) { v = i.axisExpandWindow0Pos + Ik * v1 - i.axisExpandWindow[0]; Z = v1; k = true } else { v = e - (Ij - 1 - Ik) * m; v3 = m } } return { position: v, axisNameAvailableWidth: Z, axisLabelShow: k, nameTruncateMaxWidth: v3 } } function CA(e, k) { var i = []; e.eachComponent("parallel", function (v, m) { var Z = new d1(v, e, k); Z.name = "parallel_" + m; Z.resize(v, k); v.coordinateSystem = Z; Z.model = v; i.push(Z) }); e.eachSeries(function (m) { if (m.get("coordinateSystem") === "parallel") { var v = e.queryComponents({ mainType: "parallel", index: m.get("parallelIndex"), id: m.get("parallelId") })[0]; m.coordinateSystem = v.coordinateSystem } }); return i } fz.register("parallel", { create: CA }); var mo = aH.extend({ type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle: function () { return yO([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle")) }, setActiveIntervals: function (k) { var m = this.activeIntervals = C5(k); if (m) { for (var e = m.length - 1; e >= 0; e--) { o7(m[e]) } } }, getActiveState: function (v) { var Z = this.activeIntervals; if (!Z.length) { return "normal" } if (v == null || isNaN(v)) { return "inactive" } if (Z.length === 1) { var k = Z[0]; if (k[0] <= v && v <= k[1]) { return "active" } } else { for (var m = 0, e = Z.length; m < e; m++) { if (Z[m][0] <= v && v <= Z[m][1]) { return "active" } } } return "inactive" } }); var ql = { type: "value", dim: null, areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: 0.3 }, realtime: true, z: 10 }; v4(mo.prototype, nB); function sd(i, e) { return e.type || (e.data ? "category" : "value") } mR("parallel", mo, sd, ql); aH.extend({
    type: "parallel", dependencies: ["parallelAxis"], coordinateSystem: null, dimensions: null, parallelAxisIndex: null, layoutMode: "box", defaultOption: { zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: false, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, init: function () {
      aH.prototype.init.apply(this, arguments);
      this.mergeOption({})
    }, mergeOption: function (i) { var e = this.option; i && v4(e, i, true); this._initDimensions() }, contains: function (k, e) { var i = k.get("parallelIndex"); return i != null && e.getComponent("parallel", i) === this }, setAxisExpand: function (e) { o9(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (i) { if (e.hasOwnProperty(i)) { this.option[i] = e[i] } }, this) }, _initDimensions: function () { var k = this.dimensions = []; var e = this.parallelAxisIndex = []; var i = q4(this.dependentModels.parallelAxis, function (m) { return (m.get("parallelIndex") || 0) === this.componentIndex }, this); o9(i, function (m) { k.push("dim" + m.get("dim")); e.push(m.componentIndex) }) }
  }); var Cf = { type: "axisAreaSelect", event: "axisAreaSelected" }; b1(Cf, function (i, e) { e.eachComponent({ mainType: "parallelAxis", query: i }, function (k) { k.axis.model.setActiveIntervals(i.intervals) }) }); b1("parallelAxisExpand", function (i, e) { e.eachComponent({ mainType: "parallel", query: i }, function (k) { k.setAxisExpand(i) }) }); var uk = sv; var tZ = o9; var Ap = Ef; var jq = Math.min; var AH = Math.max; var c4 = Math.pow; var eM = 10000; var Hh = 6; var C8 = 6; var rz = "globalPan"; var HS = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }; var z5 = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" }; var oe = { brushStyle: { lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)" }, transformable: true, brushMode: "single", removeOnClick: false }; var HN = 0; function kx(e) { if (ok) { bM(e) } Gc.call(this); this._zr = e; this.group = new B8(); this._brushType; this._brushOption; this._panels; this._track = []; this._dragging; this._covers = []; this._creatingCover; this._creatingPanel; this._enableGlobalPan; if (ok) { this._mounted } this._uid = "brushController_" + HN++; this._handlers = {}; tZ(tB, function (k, i) { this._handlers[i] = km(k, this) }, this) } kx.prototype = { constructor: kx, enableBrush: function (e) { if (ok) { bM(this._mounted) } this._brushType && FG(this); e.brushType && DF(this, e); return this }, setPanels: function (e) { if (e && e.length) { var i = this._panels = {}; o9(e, function (k) { i[k.panelId] = C5(k) }) } else { this._panels = null } return this }, mount: function (i) { i = i || {}; if (ok) { this._mounted = true } this._enableGlobalPan = i.enableGlobalPan; var e = this.group; this._zr.add(e); e.attr({ position: i.position || [0, 0], rotation: i.rotation || 0, scale: i.scale || [1, 1] }); this._transform = e.getLocalTransform(); return this }, eachCover: function (e, i) { tZ(this._covers, e, i) }, updateCovers: function (i) { if (ok) { bM(this._mounted) } i = Ef(i, function (Ik) { return v4(C5(oe), Ik, true) }); var Ij = "\0-brush-index-"; var k = this._covers; var m = this._covers = []; var v2 = this; var v3 = this._creatingCover; (new Gx(k, i, v1, Z)).add(e).update(e).remove(v).execute(); return this; function Z(Il, Ik) { return (Il.id != null ? Il.id : Ij + Ik) + "-" + Il.brushType } function v1(Il, Ik) { return Z(Il.__brushOption, Ik) } function e(Ik, In) { var Im = i[Ik]; if (In != null && k[In] === v3) { m[Ik] = k[In] } else { var Il = m[Ik] = In != null ? (k[In].__brushOption = Im, k[In]) : ic(v2, oq(v2, Im)); aN(v2, Il) } } function v(Ik) { if (k[Ik] !== v3) { v2.group.remove(k[Ik]) } } }, unmount: function () { if (ok) { if (!this._mounted) { return } } this.enableBrush(false); Au(this); this._zr.remove(this.group); if (ok) { this._mounted = false } return this }, dispose: function () { this.unmount(); this.off() } }; Gq(kx, Gc); function DF(e, k) { var i = e._zr; if (!e._enableGlobalPan) { hs(i, rz, e._uid) } tZ(e._handlers, function (v, m) { i.on(m, v) }); e._brushType = k.brushType; e._brushOption = v4(C5(oe), k, true) } function FG(e) { var i = e._zr; bl(i, rz, e._uid); tZ(e._handlers, function (m, k) { i.off(k, m) }); e._brushType = e._brushOption = null } function oq(e, k) { var i = xu[k.brushType].createCover(e, k); i.__brushOption = k; g3(i, k); e.group.add(i); return i } function ic(i, k) { var e = iX(k); if (e.endCreating) { e.endCreating(i, k); g3(k, k.__brushOption) } return k } function gd(e, i) { var k = i.__brushOption; iX(i).updateCoverShape(e, i, k.range, k) } function g3(e, k) { var i = k.z; i == null && (i = eM); e.traverse(function (m) { m.z = i; m.z2 = i }) } function aN(e, i) { iX(i).updateCommon(e, i); gd(e, i) } function iX(e) { return xu[e.__brushOption.brushType] } function Al(k, v1, Z) { var v = k._panels; if (!v) { return true } var i; var m = k._transform; tZ(v, function (e) { e.isTargetByCursor(v1, Z, m) && (i = e) }); return i } function fL(e, m) { var i = e._panels; if (!i) { return true } var k = m.__brushOption.panelId; return k != null ? i[k] : true } function Au(i) { var e = i._covers; var k = e.length; tZ(e, function (m) { i.group.remove(m) }, i); e.length = 0; return !!k } function oP(e, k) { var i = Ap(e._covers, function (v) { var Z = v.__brushOption; var m = C5(Z.range); return { brushType: Z.brushType, panelId: Z.panelId, range: m } }); e.trigger("brush", i, { isEnd: !!k.isEnd, removeOnClick: !!k.removeOnClick }) } function xK(k) { var i = k._track; if (!i.length) { return false } var v = i[i.length - 1]; var v1 = i[0]; var m = v[0] - v1[0]; var e = v[1] - v1[1]; var Z = c4(m * m + e * e, 0.5); return Z > Hh } function R(e) { var i = e.length - 1; i < 0 && (i = 0); return [e[0], e[i]] } function xZ(k, i, v, e) { var m = new B8(); m.add(new EH({ name: "main", style: hr(v), silent: true, draggable: true, cursor: "move", drift: uk(k, i, m, "nswe"), ondragend: uk(oP, i, { isEnd: true }) })); tZ(e, function (Z) { m.add(new EH({ name: Z, style: { opacity: 0 }, draggable: true, silent: true, invisible: true, drift: uk(k, i, m, Z), ondragend: uk(oP, i, { isEnd: true }) })) }); return m } function FY(Il, Iq, Z, Ij) {
    var e = Ij.brushStyle.lineWidth || 0;
    var i = AH(e, C8); var v3 = Z[0][0]; var v2 = Z[1][0]; var Io = v3 - e / 2; var m = v2 - e / 2; var In = Z[0][1]; var k = Z[1][1]; var v1 = In - i + e / 2; var Ir = k - i + e / 2; var Im = In - v3; var Ik = k - v2; var Ip = Im + e; var v = Ik + e; uw(Il, Iq, "main", v3, v2, Im, Ik); if (Ij.transformable) { uw(Il, Iq, "w", Io, m, i, v); uw(Il, Iq, "e", v1, m, i, v); uw(Il, Iq, "n", Io, m, Ip, i); uw(Il, Iq, "s", Io, Ir, Ip, i); uw(Il, Iq, "nw", Io, m, i, i); uw(Il, Iq, "ne", v1, m, i, i); uw(Il, Iq, "sw", Io, Ir, i, i); uw(Il, Iq, "se", v1, Ir, i, i) }
  } function nR(e, m) { var v = m.__brushOption; var k = v.transformable; var i = m.childAt(0); i.useStyle(hr(v)); i.attr({ silent: !k, cursor: k ? "move" : "default" }); tZ(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function (v1) { var v2 = m.childOfName(v1); var Z = Dr(e, v1); v2 && v2.attr({ silent: !k, invisible: !k, cursor: k ? z5[Z] + "-resize" : null }) }) } function uw(k, v1, m, e, v2, i, Z) { var v = v1.childOfName(m); v && v.setShape(v9(ob(k, v1, [[e, v2], [e + i, v2 + Z]]))) } function hr(e) { return De({ strokeNoScale: true }, e.brushStyle) } function pG(i, Z, k, v) { var m = [jq(i, k), jq(Z, v)]; var e = [AH(i, k), AH(Z, v)]; return [[m[0], e[0]], [m[1], e[1]]] } function td(e) { return aI(e.group) } function Dr(i, m) { if (m.length > 1) { m = m.split(""); var e = [Dr(i, m[0]), Dr(i, m[1])]; (e[0] === "e" || e[0] === "w") && e.reverse(); return e.join("") } else { var v = { w: "left", e: "right", n: "top", s: "bottom" }; var k = { left: "w", right: "e", top: "n", bottom: "s" }; var e = n0(v[m], td(i)); return k[e] } } function uZ(m, v1, v, Ik, i, Il, v3, Z) { var k = Ik.__brushOption; var v2 = m(k.range); var Ij = Ak(v, Il, v3); tZ(i.split(""), function (e) { var Im = HS[e]; v2[Im[0]][Im[1]] += Ij[Im[0]] }); k.range = v1(pG(v2[0][0], v2[1][0], v2[0][1], v2[1][1])); aN(v, Ik); oP(v, { isEnd: false }) } function qH(k, v2, v, i, v1) { var m = v2.__brushOption.range; var Z = Ak(k, v, i); tZ(m, function (e) { e[0] += Z[0]; e[1] += Z[1] }); aN(k, v2); oP(k, { isEnd: false }) } function Ak(k, v, i) { var m = k.group; var e = m.transformCoordToLocal(v, i); var Z = m.transformCoordToLocal(0, 0); return [e[0] - Z[0], e[1] - Z[1]] } function ob(i, m, k) { var e = fL(i, m); return (e && e !== true) ? e.clipPath(k, i._transform) : C5(k) } function v9(m) { var v = jq(m[0][0], m[1][0]); var k = jq(m[0][1], m[1][1]); var i = AH(m[0][0], m[1][0]); var e = AH(m[0][1], m[1][1]); return { x: v, y: k, width: i - v, height: e - k } } function h9(m, v3, v1) { if (!m._brushType) { return } var v2 = m._zr; var k = m._covers; var Z = Al(m, v3, v1); if (!m._dragging) { for (var v = 0; v < k.length; v++) { var Ij = k[v].__brushOption; if (Z && (Z === true || Ij.panelId === Z.panelId) && xu[Ij.brushType].contain(k[v], v1[0], v1[1])) { return } } } Z && v2.setCursorStyle("crosshair") } function aL(i) { var k = i.event; k.preventDefault && k.preventDefault() } function gR(i, e, k) { return i.childOfName("main").contain(e, k) } function uF(v1, Il, i, Z) { var v3 = v1._creatingCover; var k = v1._creatingPanel; var v = v1._brushOption; var v2; v1._track.push(i.slice()); if (xK(v1) || v3) { if (k && !v3) { v.brushMode === "single" && Au(v1); var m = C5(v); m.brushType = Fw(m.brushType, k); m.panelId = k === true ? null : k.panelId; v3 = v1._creatingCover = oq(v1, m); v1._covers.push(v3) } if (v3) { var Ik = xu[Fw(v1._brushType, k)]; var Ij = v3.__brushOption; Ij.range = Ik.getCreatingRange(ob(v1, v3, v1._track)); if (Z) { ic(v1, v3); Ik.updateCommon(v1, v3) } gd(v1, v3); v2 = { isEnd: Z } } } else { if (Z && v.brushMode === "single" && v.removeOnClick) { if (Al(v1, Il, i) && Au(v1)) { v2 = { isEnd: Z, removeOnClick: true } } } } return v2 } function Fw(i, e) { if (i === "auto") { if (ok) { bM(e && e.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"') } return e.defaultBrushType } return i } var tB = { mousedown: function (m) { if (this._dragging) { x6.call(this, m) } else { if (!m.target || !m.target.draggable) { aL(m); var k = this.group.transformCoordToLocal(m.offsetX, m.offsetY); this._creatingCover = null; var i = this._creatingPanel = Al(this, m, k); if (i) { this._dragging = true; this._track = [k.slice()] } } } }, mousemove: function (k) { var i = this.group.transformCoordToLocal(k.offsetX, k.offsetY); h9(this, k, i); if (this._dragging) { aL(k); var m = uF(this, k, i, false); m && oP(this, m) } }, mouseup: x6 }; function x6(k) { if (this._dragging) { aL(k); var i = this.group.transformCoordToLocal(k.offsetX, k.offsetY); var m = uF(this, k, i, true); this._dragging = false; this._track = []; this._creatingCover = null; m && oP(this, m) } } var xu = { lineX: zO(0), lineY: zO(1), rect: { createCover: function (e, i) { return xZ(uk(uZ, function (k) { return k }, function (k) { return k }), e, i, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]) }, getCreatingRange: function (i) { var e = R(i); return pG(e[1][0], e[1][1], e[0][0], e[0][1]) }, updateCoverShape: function (e, k, i, m) { FY(e, k, i, m) }, updateCommon: nR, contain: gR }, polygon: { createCover: function (e, k) { var i = new B8(); i.add(new z7({ name: "main", style: hr(k), silent: true })); return i }, getCreatingRange: function (e) { return e }, endCreating: function (e, i) { i.remove(i.childAt(0)); i.add(new ia({ name: "main", draggable: true, drift: uk(qH, e, i), ondragend: uk(oP, e, { isEnd: true }) })) }, updateCoverShape: function (e, k, i, m) { k.childAt(0).setShape({ points: ob(e, k, i) }) }, updateCommon: nR, contain: gR } }; function zO(e) {
    return {
      createCover: function (i, k) { return xZ(uk(uZ, function (m) { var v = [m, [0, 100]]; e && v.reverse(); return v }, function (m) { return m[e] }), i, k, [["w", "e"], ["n", "s"]][e]) }, getCreatingRange: function (v) { var k = R(v); var m = jq(k[0][e], k[1][e]); var i = AH(k[0][e], k[1][e]); return [m, i] }, updateCoverShape: function (k, v1, Z, v3) {
        var v2; var i = fL(k, v1); if (i !== true && i.getLinearBrushOtherExtent) {
          v2 = i.getLinearBrushOtherExtent(e, k._transform)
        } else { var v = k._zr; v2 = [0, [v.getWidth(), v.getHeight()][1 - e]] } var m = [Z, v2]; e && m.reverse(); FY(k, v1, m, v3)
      }, updateCommon: nR, contain: gR
    }
  } function Fg(e) { e = vU(e); return function (k, i) { return oF(k, e) } } function vz(i, e) { i = vU(i); return function (Z) { var k = e != null ? e : Z; var m = k ? i.width : i.height; var v = k ? i.x : i.y; return [v, v + (m || 0)] } } function qL(k, i, e) { k = vU(k); return function (Z, v, m) { return k.contain(v[0], v[1]) && !CS(Z, i, e) } } function vU(e) { return CH.create(e) } var A4 = ["axisLine", "axisTickLabel", "axisName"]; var cO = qy({ type: "parallelAxis", init: function (e, i) { cO.superApply(this, "init", arguments); (this._brushController = new kx(i.getZr())).on("brush", km(this._onBrush, this)) }, render: function (In, v1, v2, Ik) { if (iY(In, v1, Ik)) { return } this.axisModel = In; this.api = v2; this.group.removeAll(); var v = this._axisGroup; this._axisGroup = new B8(); this.group.add(this._axisGroup); if (!In.get("show")) { return } var i = kX(In, v1); var k = i.coordinateSystem; var e = In.getAreaSelectStyle(); var Ij = e.width; var m = In.axis.dim; var Im = k.getAxisLayout(m); var Il = b0({ strokeContainThreshold: Ij }, Im); var v3 = new da(In, Il); o9(A4, v3.add, v3); this._axisGroup.add(v3.getGroup()); this._refreshBrushController(Il, e, In, i, Ij, v2); var Z = (Ik && Ik.animation === false) ? null : In; E(v, this._axisGroup, Z) }, _refreshBrushController: function (v3, e, v2, k, v1, m) { var Ij = v2.axis.getExtent(); var Z = Ij[1] - Ij[0]; var i = Math.min(30, Math.abs(Z) * 0.1); var v = CH.create({ x: Ij[0], y: -v1 / 2, width: Z, height: v1 }); v.x -= i; v.width += 2 * i; this._brushController.mount({ enableGlobalPan: true, rotation: v3.rotation, position: v3.position }).setPanels([{ panelId: "pl", clipPath: Fg(v), isTargetByCursor: qL(v, m, k), getLinearBrushOtherExtent: vz(v, 0) }]).enableBrush({ brushType: "lineX", brushStyle: e, removeOnClick: true }).updateCovers(Dw(v2)) }, _onBrush: function (v, k) { var i = this.axisModel; var m = i.axis; var e = Ef(v, function (Z) { return [m.coordToData(Z.range[0], true), m.coordToData(Z.range[1], true)] }); if (!i.option.realtime === k.isEnd || k.removeOnClick) { this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: i.id, intervals: e }) } }, dispose: function () { this._brushController.dispose() } }); function iY(i, e, k) { return k && k.type === "axisAreaSelect" && e.findComponents({ mainType: "parallelAxis", query: k })[0] === i } function Dw(e) { var i = e.axis; return Ef(e.activeIntervals, function (k) { return { brushType: "lineX", panelId: "pl", range: [i.dataToCoord(k[0], true), i.dataToCoord(k[1], true)] } }) } function kX(i, e) { return e.getComponent("parallel", i.get("parallelIndex")) } var iB = 5; qy({ type: "parallel", render: function (i, e, k) { this._model = i; this._api = k; if (!this._handlers) { this._handlers = {}; o9(hu, function (v, m) { k.getZr().on(m, this._handlers[m] = km(v, this)) }, this) } mK(this, "_throttledDispatchExpand", i.get("axisExpandRate"), "fixRate") }, dispose: function (e, i) { o9(this._handlers, function (m, k) { i.getZr().off(k, m) }); this._handlers = null }, _throttledDispatchExpand: function (e) { this._dispatchExpand(e) }, _dispatchExpand: function (e) { e && this._api.dispatchAction(b0({ type: "parallelAxisExpand" }, e)) } }); var hu = { mousedown: function (i) { if (Dj(this, "click")) { this._mouseDownPoint = [i.offsetX, i.offsetY] } }, mouseup: function (v) { var m = this._mouseDownPoint; if (Dj(this, "click") && m) { var k = [v.offsetX, v.offsetY]; var Z = Math.pow(m[0] - k[0], 2) + Math.pow(m[1] - k[1], 2); if (Z > iB) { return } var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([v.offsetX, v.offsetY]); i.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: i.axisExpandWindow }) } this._mouseDownPoint = null }, mousemove: function (v) { if (this._mouseDownPoint || !Dj(this, "mousemove")) { return } var k = this._model; var i = k.coordinateSystem.getSlidedAxisExpandWindow([v.offsetX, v.offsetY]); var m = i.behavior; m === "jump" && this._throttledDispatchExpand.debounceNextCall(k.get("axisExpandDebounce")); this._throttledDispatchExpand(m === "none" ? null : { axisExpandWindow: i.axisExpandWindow, animation: m === "jump" ? null : false }) } }; function Dj(i, e) { var k = i._model; return k.get("axisExpandable") && k.get("axisExpandTriggerOn") === e } y2(of); nU.extend({ type: "series.parallel", dependencies: ["parallel"], visualColorAccessPath: "lineStyle.color", getInitialData: function (i, e) { var k = this.getSource(); Gg(k, this); return a(k, this) }, getRawIndicesByActiveState: function (i) { var e = this.coordinateSystem; var k = this.getData(); var m = []; e.eachActiveState(k, function (v, Z) { if (i === v) { m.push(k.getRawIndex(Z)) } }); return m }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { show: false }, inactiveOpacity: 0.05, activeOpacity: 1, lineStyle: { width: 1, opacity: 0.45, type: "solid" }, emphasis: { label: { show: false } }, progressive: 500, smooth: false, animationEasing: "linear" } }); function Gg(k, e) { if (k.encodeDefine) { return } var i = e.ecModel.getComponent("parallel", e.get("parallelIndex")); if (!i) { return } var m = k.encodeDefine = CJ(); o9(i.dimensions, function (Z) { var v = mn(Z); m.set(Z, v) }) } function mn(e) { return +e.replace("dim", "") } var w = 0.3; var zv = dF.extend({
    type: "parallel", init: function () { this._dataGroup = new B8(); this.group.add(this._dataGroup); this._data; this._initialized }, render: function (k, v3, Ij, Im) {
      var i = this._dataGroup; var v1 = k.getData(); var v2 = this._data; var v = k.coordinateSystem; var e = v.dimensions;
      var Il = d7(k); v1.diff(v2).add(In).update(m).remove(Z).execute(); function In(Ip) { var Io = zS(v1, i, Ip, e, v); rM(Io, v1, Ip, Il) } function m(Is, Io) { var Ip = v2.getItemGraphicEl(Io); var Ir = Fa(v1, Is, e, v); v1.setItemGraphicEl(Is, Ip); var Iq = (Im && Im.animation === false) ? null : k; oS(Ip, { shape: { points: Ir } }, Iq, Is); rM(Ip, v1, Is, Il) } function Z(Io) { var Ip = v2.getItemGraphicEl(Io); i.remove(Ip) } if (!this._initialized) { this._initialized = true; var Ik = vj(v, k, function () { setTimeout(function () { i.removeClipPath() }) }); i.setClipPath(Ik) } this._data = v1
    }, incrementalPrepareRender: function (i, e, k) { this._initialized = true; this._data = null; this._dataGroup.removeAll() }, incrementalRender: function (Z, i, v) { var m = i.getData(); var k = i.coordinateSystem; var e = k.dimensions; var v1 = d7(i); for (var v2 = Z.start; v2 < Z.end; v2++) { var v3 = zS(m, this._dataGroup, v2, e, k); v3.incremental = true; rM(v3, m, v2, v1) } }, dispose: function () { }, remove: function () { this._dataGroup && this._dataGroup.removeAll(); this._data = null }
  }); function vj(v, i, e) { var k = v.model; var Z = v.getRect(); var m = new EH({ shape: { x: Z.x, y: Z.y, width: Z.width, height: Z.height } }); var v1 = k.get("layout") === "horizontal" ? "width" : "height"; m.setShape(v1, 0); jC(m, { shape: { width: Z.width, height: Z.height } }, i, e); return m } function Fa(v2, m, Z, k) { var v = []; for (var e = 0; e < Z.length; e++) { var v3 = Z[e]; var v1 = v2.get(v2.mapDimension(v3), m); if (!vX(v1, k.getAxis(v3).type)) { v.push(k.dataToPoint(v1, v3)) } } return v } function zS(Z, v1, k, v, i) { var m = Fa(Z, k, v, i); var e = new z7({ shape: { points: m }, silent: true, z2: 10 }); v1.add(e); Z.setItemGraphicEl(k, e); return e } function d7(i) { var e = i.get("smooth", true); e === true && (e = w); return { lineStyle: i.getModel("lineStyle").getLineStyle(), smooth: e != null ? e : w } } function rM(v, Z, m, k) { var e = k.lineStyle; if (Z.hasItemOption) { var v1 = Z.getItemModel(m).getModel("lineStyle"); e = v1.getLineStyle() } v.useStyle(e); var i = v.style; i.fill = null; i.stroke = Z.getItemVisual(m, "color"); i.opacity = Z.getItemVisual(m, "opacity"); k.smooth && (v.shape.smooth = k.smooth) } function vX(i, e) { return e === "category" ? i == null : (i == null || isNaN(i)) } var Gn = ["lineStyle", "normal", "opacity"]; var rE = { seriesType: "parallel", reset: function (m, Ik, Il) { var v2 = m.getModel("itemStyle"); var Im = m.getModel("lineStyle"); var k = Ik.get("color"); var Z = Im.get("color") || v2.get("color") || k[m.seriesIndex % k.length]; var i = m.get("inactiveOpacity"); var v = m.get("activeOpacity"); var Ij = m.getModel("lineStyle").getLineStyle(); var v1 = m.coordinateSystem; var v3 = m.getData(); var In = { normal: Ij.opacity, active: v, inactive: i }; v3.setVisual("color", Z); function e(Ip, Io) { v1.eachActiveState(Io, function (Is, Ir) { var Iq = In[Is]; if (Is === "normal" && Io.hasItemOption) { var It = Io.getItemModel(Ir).get(Gn, true); It != null && (Iq = It) } Io.setItemVisual(Ir, "opacity", Iq) }, Ip.start, Ip.end) } return { progress: e } } }; G(rE); var uq = nU.extend({ type: "series.sankey", layoutInfo: null, getInitialData: function (k) { var i = k.edges || k.links; var e = k.data || k.nodes; if (e && i) { var m = BJ(e, i, this, true); return m.data } }, setNodePosition: function (k, e) { var i = this.option.data[k]; i.localX = e[0]; i.localY = e[1] }, getGraph: function () { return this.getData().graph }, getEdgeData: function () { return this.getGraph().edgeData }, formatTooltip: function (k, m, e) { if (e === "edge") { var v = this.getDataParams(k, e); var Z = v.data; var i = Z.source + " -- " + Z.target; if (v.value) { i += " : " + v.value } return mv(i) } return uq.superCall(this, "formatTooltip", k, m) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", layout: null, left: "5%", top: "5%", right: "20%", bottom: "5%", orient: "horizontal", nodeWidth: 20, nodeGap: 8, draggable: true, focusNodeAdjacency: false, layoutIterations: 32, label: { show: true, position: "right", color: "#000", fontSize: 12 }, itemStyle: { borderWidth: 1, borderColor: "#333" }, lineStyle: { color: "#314656", opacity: 0.2, curveness: 0.5 }, emphasis: { label: { show: true }, lineStyle: { opacity: 0.6 } }, animationEasing: "linear", animationDuration: 1000 } }); var vv = ["itemStyle", "opacity"]; var Gy = ["lineStyle", "opacity"]; function H4(i, e) { return i.getVisual("opacity") || i.getModel().get(e) } function wT(m, k, v) { var i = m.getGraphicEl(); var e = H4(m, k); if (v != null) { e == null && (e = 1); e *= v } i.downplay && i.downplay(); i.traverse(function (Z) { if (Z.type !== "group") { Z.setStyle("opacity", e) } }) } function oA(m, k) { var e = H4(m, k); var i = m.getGraphicEl(); i.highlight && i.highlight(); i.traverse(function (v) { if (v.type !== "group") { v.setStyle("opacity", e) } }) } var qO = Hw({ shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0, orient: "" }, buildPath: function (e, i) { var m = i.extent; var k = i.orient; if (k === "vertical") { e.moveTo(i.x1, i.y1); e.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2); e.lineTo(i.x2 + m, i.y2); e.bezierCurveTo(i.cpx2 + m, i.cpy2, i.cpx1 + m, i.cpy1, i.x1 + m, i.y1) } else { e.moveTo(i.x1, i.y1); e.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2); e.lineTo(i.x2, i.y2 + m); e.bezierCurveTo(i.cpx2, i.cpy2 + m, i.cpx1, i.cpy1 + m, i.x1, i.y1 + m) } e.closePath() } }); BL({
    type: "sankey", _model: null, _focusAdjacencyDisabled: false, render: function (m, Z, v1) {
      var Il = this; var Ik = m.getGraph(); var v3 = this.group; var k = m.layoutInfo; var i = k.width; var Ij = k.height; var e = m.getData(); var v2 = m.getData("edge"); var v = m.get("orient"); this._model = m; v3.removeAll(); v3.attr("position", [k.x, k.y]);
      Ik.eachEdge(function (Iv) { var Iy = new qO(); Iy.dataIndex = Iv.dataIndex; Iy.seriesIndex = m.seriesIndex; Iy.dataType = "edge"; var Iz = Iv.getModel("lineStyle"); var Is = Iz.get("curveness"); var In = Iv.node1.getLayout(); var IG = Iv.node1.getModel(); var IF = IG.get("localX"); var Iu = IG.get("localY"); var Im = Iv.node2.getLayout(); var Io = Iv.node2.getModel(); var IE = Io.get("localX"); var It = Io.get("localY"); var Ir = Iv.getLayout(); var IB; var Iq; var IA; var Ip; var Ix; var ID; var Iw; var IC; Iy.shape.extent = Math.max(1, Ir.dy); Iy.shape.orient = v; if (v === "vertical") { IB = (IF != null ? IF * i : In.x) + Ir.sy; Iq = (Iu != null ? Iu * Ij : In.y) + In.dy; IA = (IE != null ? IE * i : Im.x) + Ir.ty; Ip = It != null ? It * Ij : Im.y; Ix = IB; ID = Iq * (1 - Is) + Ip * Is; Iw = IA; IC = Iq * Is + Ip * (1 - Is) } else { IB = (IF != null ? IF * i : In.x) + In.dx; Iq = (Iu != null ? Iu * Ij : In.y) + Ir.sy; IA = IE != null ? IE * i : Im.x; Ip = (It != null ? It * Ij : Im.y) + Ir.ty; Ix = IB * (1 - Is) + IA * Is; ID = Iq; Iw = IB * Is + IA * (1 - Is); IC = Ip } Iy.setShape({ x1: IB, y1: Iq, x2: IA, y2: Ip, cpx1: Ix, cpy1: ID, cpx2: Iw, cpy2: IC }); Iy.setStyle(Iz.getItemStyle()); switch (Iy.style.fill) { case "source": Iy.style.fill = Iv.node1.getVisual("color"); break; case "target": Iy.style.fill = Iv.node2.getVisual("color"); break }yn(Iy, Iv.getModel("emphasis.lineStyle").getItemStyle()); v3.add(Iy); v2.setItemGraphicEl(Iv.dataIndex, Iy) }); Ik.eachNode(function (Im) { var Io = Im.getLayout(); var Is = Im.getModel(); var It = Is.get("localX"); var Ir = Is.get("localY"); var Iu = Is.getModel("label"); var Ip = Is.getModel("emphasis.label"); var Iq = new EH({ shape: { x: It != null ? It * i : Io.x, y: Ir != null ? Ir * Ij : Io.y, width: Io.dx, height: Io.dy }, style: Is.getModel("itemStyle").getItemStyle() }); var In = Im.getModel("emphasis.itemStyle").getItemStyle(); BD(Iq.style, In, Iu, Ip, { labelFetcher: m, labelDataIndex: Im.dataIndex, defaultText: Im.id, isRectText: true }); Iq.setStyle("fill", Im.getVisual("color")); yn(Iq, In); v3.add(Iq); e.setItemGraphicEl(Im.dataIndex, Iq); Iq.dataType = "node" }); e.eachItemGraphicEl(function (Io, Im) { var In = e.getItemModel(Im); if (In.get("draggable")) { Io.drift = function (Iq, Ip) { Il._focusAdjacencyDisabled = true; this.shape.x += Iq; this.shape.y += Ip; this.dirty(); v1.dispatchAction({ type: "dragNode", seriesId: m.id, dataIndex: e.getRawIndex(Im), localX: this.shape.x / i, localY: this.shape.y / Ij }) }; Io.ondragend = function () { Il._focusAdjacencyDisabled = false }; Io.draggable = true; Io.cursor = "move" } if (In.get("focusNodeAdjacency")) { Io.off("mouseover").on("mouseover", function () { if (!Il._focusAdjacencyDisabled) { v1.dispatchAction({ type: "focusNodeAdjacency", seriesId: m.id, dataIndex: Io.dataIndex }) } }); Io.off("mouseout").on("mouseout", function () { if (!Il._focusAdjacencyDisabled) { v1.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: m.id }) } }) } }); v2.eachItemGraphicEl(function (In, Im) { var Io = v2.getItemModel(Im); if (Io.get("focusNodeAdjacency")) { In.off("mouseover").on("mouseover", function () { if (!Il._focusAdjacencyDisabled) { v1.dispatchAction({ type: "focusNodeAdjacency", seriesId: m.id, edgeDataIndex: In.dataIndex }) } }); In.off("mouseout").on("mouseout", function () { if (!Il._focusAdjacencyDisabled) { v1.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: m.id }) } }) } }); if (!this._data && m.get("animation")) { v3.setClipPath(vg(v3.getBoundingRect(), m, function () { v3.removeClipPath() })) } this._data = m.getData()
    }, dispose: function () { }, focusNodeAdjacency: function (k, v, Z, v3) { var m = this._model.getData(); var Ik = m.graph; var v2 = v3.dataIndex; var Il = m.getItemModel(v2); var v1 = v3.edgeDataIndex; if (v2 == null && v1 == null) { return } var i = Ik.getNodeByIndex(v2); var e = Ik.getEdgeByIndex(v1); Ik.eachNode(function (Im) { wT(Im, vv, 0.1) }); Ik.eachEdge(function (Im) { wT(Im, Gy, 0.1) }); if (i) { oA(i, vv); var Ij = Il.get("focusNodeAdjacency"); if (Ij === "outEdges") { o9(i.outEdges, function (Im) { if (Im.dataIndex < 0) { return } oA(Im, Gy); oA(Im.node2, vv) }) } else { if (Ij === "inEdges") { o9(i.inEdges, function (Im) { if (Im.dataIndex < 0) { return } oA(Im, Gy); oA(Im.node1, vv) }) } else { if (Ij === "allEdges") { o9(i.edges, function (Im) { if (Im.dataIndex < 0) { return } oA(Im, Gy); oA(Im.node1, vv); oA(Im.node2, vv) }) } } } } if (e) { oA(e, Gy); oA(e.node1, vv); oA(e.node2, vv) } }, unfocusNodeAdjacency: function (i, e, k, v) { var m = this._model.getGraph(); m.eachNode(function (Z) { wT(Z, vv) }); m.eachEdge(function (Z) { wT(Z, Gy) }) }
  }); function vg(m, i, e) { var k = new EH({ shape: { x: m.x - 10, y: m.y - 10, width: 0, height: m.height + 20 } }); jC(k, { shape: { width: m.width + 20, height: m.height + 20 } }, i, e); return k } b1({ type: "dragNode", event: "dragNode", update: "update" }, function (i, e) { e.eachComponent({ mainType: "series", subType: "sankey", query: i }, function (k) { k.setNodePosition(i.dataIndex, [i.localX, i.localY]) }) }); function db() { var i = []; var m = []; function e(Il, Ij) { if (Ij >= i.length) { return Il } var Ik = -1; var v1 = Il.length; var Z = i[Ij++]; var v = {}; var v2 = {}; while (++Ik < v1) { var v3 = Z(Il[Ik]); var Im = v2[v3]; if (Im) { Im.push(Il[Ik]) } else { v2[v3] = [Il[Ik]] } } o9(v2, function (Io, In) { v[In] = e(Io, Ij) }); return v } function k(v1, Z) { if (Z >= i.length) { return v1 } var v2 = []; var v = m[Z++]; o9(v1, function (Ij, v3) { v2.push({ key: v3, values: k(Ij, Z) }) }); if (v) { return v2.sort(function (Ij, v3) { return v(Ij.key, v3.key) }) } return v2 } return { key: function (v) { i.push(v); return this }, sortKeys: function (v) { m[i.length - 1] = v; return this }, entries: function (v) { return k(e(v, 0), 0) } } } var tz = function (e, i, k) {
    e.eachSeriesByType("sankey", function (v3) {
      var Im = v3.get("nodeWidth");
      var Il = v3.get("nodeGap"); var v2 = rQ(v3, i); v3.layoutInfo = v2; var v = v2.width; var Io = v2.height; var In = v3.getGraph(); var m = In.nodes; var Ik = In.edges; DD(m); var Z = q4(m, function (Ip) { return Ip.getLayout().value === 0 }); var v1 = Z.length !== 0 ? 0 : v3.get("layoutIterations"); var Ij = v3.get("orient"); yh(m, Ik, Im, Il, v, Io, v1, Ij)
    })
  }; function rQ(e, i) { return kV(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }) } function yh(m, k, i, v2, Z, e, v1, v) { H6(m, k, i, Z, e, v); yc(m, k, e, Z, v2, v1, v); d3(m, v) } function DD(e) { o9(e, function (m) { var k = By(m.outEdges, tm); var i = By(m.inEdges, tm); var v = Math.max(k, i); m.setLayout({ value: v }, true) }) } function H6(e, v3, Im, k, In, v2) { var Z = []; var m = []; var v1 = []; var v = []; var Il = 0; var Ik = 0; for (var Ij = 0; Ij < v3.length; Ij++) { Z[Ij] = 1 } for (Ij = 0; Ij < e.length; Ij++) { m[Ij] = e[Ij].inEdges.length; if (m[Ij] === 0) { v1.push(e[Ij]) } } while (v1.length) { o9(v1, function (i) { if (v2 === "vertical") { i.setLayout({ y: Il }, true); i.setLayout({ dy: Im }, true) } else { i.setLayout({ x: Il }, true); i.setLayout({ dx: Im }, true) } o9(i.outEdges, function (Ip) { var Io = v3.indexOf(Ip); Z[Io] = 0; var Iq = Ip.node2; var Ir = e.indexOf(Iq); if (--m[Ir] === 0) { v.push(Iq) } }) }); ++Il; v1 = v; v = [] } for (Ij = 0; Ij < Z.length; Ij++) { if (ok) { if (Z[Ij] === 1) { throw new Error("Sankey is a DAG, the original data has cycle!") } } } uB(e, Il); if (v2 === "vertical") { Ik = (In - Im) / (Il - 1) } else { Ik = (k - Im) / (Il - 1) } bN(e, Ik, v2) } function uB(i, e, k) { o9(i, function (m) { if (!m.outEdges.length) { if (k === "vertical") { m.setLayout({ y: e - 1 }, true) } else { m.setLayout({ x: e - 1 }, true) } } }) } function bN(e, k, i) { o9(e, function (v) { if (i === "vertical") { var m = v.getLayout().y * k; v.setLayout({ y: m }, true) } else { var Z = v.getLayout().x * k; v.setLayout({ x: Z }, true) } }) } function yc(e, v2, v3, i, Z, m, v1) { var k = db().key(p4(v1)).sortKeys(function (Ik, Ij) { return Ik - Ij }).entries(e).map(function (Ij) { return Ij.values }); wa(e, k, v2, v3, i, Z, v1); h2(k, Z, v3, i, v1); for (var v = 1; m > 0; m--) { v *= 0.99; H(k, v, v1); h2(k, Z, v3, i, v1); en(k, v, v1); h2(k, Z, v3, i, v1) } } function p4(e) { if (e === "vertical") { return function (i) { return i.getLayout().y } } return function (i) { return i.getLayout().x } } function wa(i, m, v1, v3, k, v, Z) { var v2 = []; o9(m, function (Ij) { var Im = Ij.length; var Il = 0; var Ik = 0; o9(Ij, function (In) { Il += In.getLayout().value }); if (Z === "vertical") { Ik = (k - (Im - 1) * v) / Il } else { Ik = (v3 - (Im - 1) * v) / Il } v2.push(Ik) }); v2.sort(function (Ik, Ij) { return Ik - Ij }); var e = v2[0]; o9(m, function (Ij) { o9(Ij, function (Im, Il) { var Ik = Im.getLayout().value * e; if (Z === "vertical") { Im.setLayout({ x: Il }, true); Im.setLayout({ dx: Ik }, true) } else { Im.setLayout({ y: Il }, true); Im.setLayout({ dy: Ik }, true) } }) }); o9(v1, function (Ik) { var Ij = +Ik.getValue() * e; Ik.setLayout({ dy: Ij }, true) }) } function h2(i, v, e, m, k) { o9(i, function (v1) { var Ik; var Z; var Ij = 0; var Im = v1.length; var v2; if (k === "vertical") { v1.sort(function (Io, In) { return Io.getLayout().x - In.getLayout().x }); for (v2 = 0; v2 < Im; v2++) { Ik = v1[v2]; Z = Ij - Ik.getLayout().x; if (Z > 0) { var Il = Ik.getLayout().x + Z; Ik.setLayout({ x: Il }, true) } Ij = Ik.getLayout().x + Ik.getLayout().dx + v } Z = Ij - v - m; if (Z > 0) { Il = Ik.getLayout().x - Z; Ik.setLayout({ x: Il }, true); Ij = Il; for (v2 = Im - 2; v2 >= 0; --v2) { Ik = v1[v2]; Z = Ik.getLayout().x + Ik.getLayout().dx + v - Ij; if (Z > 0) { Il = Ik.getLayout().x - Z; Ik.setLayout({ x: Il }, true) } Ij = Ik.getLayout().x } } } else { v1.sort(function (Io, In) { return Io.getLayout().y - In.getLayout().y }); for (v2 = 0; v2 < Im; v2++) { Ik = v1[v2]; Z = Ij - Ik.getLayout().y; if (Z > 0) { var v3 = Ik.getLayout().y + Z; Ik.setLayout({ y: v3 }, true) } Ij = Ik.getLayout().y + Ik.getLayout().dy + v } Z = Ij - v - e; if (Z > 0) { v3 = Ik.getLayout().y - Z; Ik.setLayout({ y: v3 }, true); Ij = v3; for (v2 = Im - 2; v2 >= 0; --v2) { Ik = v1[v2]; Z = Ik.getLayout().y + Ik.getLayout().dy + v - Ij; if (Z > 0) { v3 = Ik.getLayout().y - Z; Ik.setLayout({ y: v3 }, true) } Ij = Ik.getLayout().y } } } }) } function H(e, k, i) { o9(e.slice().reverse(), function (m) { o9(m, function (Z) { if (Z.outEdges.length) { var v2 = By(Z.outEdges, nl, i) / By(Z.outEdges, tm, i); if (i === "vertical") { var v1 = Z.getLayout().x + (v2 - nZ(Z, i)) * k; Z.setLayout({ x: v1 }, true) } else { var v = Z.getLayout().y + (v2 - nZ(Z, i)) * k; Z.setLayout({ y: v }, true) } } }) }) } function nl(i, e) { return nZ(i.node2, e) * i.getValue() } function fu(i, e) { return nZ(i.node1, e) * i.getValue() } function nZ(i, e) { if (e === "vertical") { return i.getLayout().x + i.getLayout().dx / 2 } return i.getLayout().y + i.getLayout().dy / 2 } function tm(e) { return e.getValue() } function By(v2, v1, k) { var v = 0; var e = v2.length; var m = -1; while (++m < e) { var Z = +v1.call(v2, v2[m], k); if (!isNaN(Z)) { v += Z } } return v } function en(e, k, i) { o9(e, function (m) { o9(m, function (Z) { if (Z.inEdges.length) { var v2 = By(Z.inEdges, fu, i) / By(Z.inEdges, tm, i); if (i === "vertical") { var v1 = Z.getLayout().x + (v2 - nZ(Z, i)) * k; Z.setLayout({ x: v1 }, true) } else { var v = Z.getLayout().y + (v2 - nZ(Z, i)) * k; Z.setLayout({ y: v }, true) } } }) }) } function d3(e, i) {
    o9(e, function (k) { if (i === "vertical") { k.outEdges.sort(function (v, m) { return v.node2.getLayout().x - m.node2.getLayout().x }); k.inEdges.sort(function (v, m) { return v.node1.getLayout().x - m.node1.getLayout().x }) } else { k.outEdges.sort(function (v, m) { return v.node2.getLayout().y - m.node2.getLayout().y }); k.inEdges.sort(function (v, m) { return v.node1.getLayout().y - m.node1.getLayout().y }) } }); o9(e, function (m) {
      var v = 0; var k = 0; o9(m.outEdges, function (Z) { Z.setLayout({ sy: v }, true); v += Z.getLayout().dy }); o9(m.inEdges, function (Z) {
        Z.setLayout({ ty: k }, true);
        k += Z.getLayout().dy
      })
    })
  } var dS = function (e, i) { e.eachSeriesByType("sankey", function (m) { var Z = m.getGraph(); var k = Z.nodes; if (k.length) { var v = Infinity; var v1 = -Infinity; o9(k, function (v3) { var v2 = v3.getLayout().value; if (v2 < v) { v = v2 } if (v2 > v1) { v1 = v2 } }); o9(k, function (Il) { var Ij = new mH({ type: "color", mappingMethod: "linear", dataExtent: [v, v1], visual: m.get("color") }); var v2 = Ij.mapValueToVisual(Il.getLayout().value); Il.setVisual("color", v2); var Ik = Il.getModel(); var v3 = Ik.get("itemStyle.color"); if (v3 != null) { Il.setVisual("color", v3) } }) } }) }; pr(tz); G(dS); var xr = { _baseAxisDim: null, getInitialData: function (v3, Ir) { var k; var i = Ir.getComponent("xAxis", this.get("xAxisIndex")); var v1 = Ir.getComponent("yAxis", this.get("yAxisIndex")); var Ik = i.get("type"); var m = v1.get("type"); var e; if (Ik === "category") { v3.layout = "horizontal"; k = i.getOrdinalMeta(); e = true } else { if (m === "category") { v3.layout = "vertical"; k = v1.getOrdinalMeta(); e = true } else { v3.layout = v3.layout || "horizontal" } } var Ip = ["x", "y"]; var Io = v3.layout === "horizontal" ? 0 : 1; var Z = this._baseAxisDim = Ip[Io]; var v = Ip[1 - Io]; var In = [i, v1]; var Im = In[Io].get("type"); var Il = In[1 - Io].get("type"); var Iq = v3.data; if (Iq && e) { var Ij = []; o9(Iq, function (Iu, Is) { var It; if (Iu.value && GG(Iu.value)) { It = Iu.value.slice(); Iu.value.unshift(Is) } else { if (GG(Iu)) { It = Iu.slice(); Iu.unshift(Is) } else { It = Iu } } Ij.push(It) }); v3.data = Ij } var v2 = this.defaultValueDimensions; return xi(this, { coordDimensions: [{ name: Z, type: qI(Im), ordinalMeta: k, otherDims: { tooltip: false, itemName: 0 }, dimsDef: ["base"] }, { name: v, type: qI(Il), dimsDef: v2.slice() }], dimensionsCount: v2.length + 1 }) }, getBaseAxis: function () { var e = this._baseAxisDim; return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis } }; var H2 = nU.extend({ type: "series.boxplot", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: [{ name: "min", defaultTooltip: true }, { name: "Q1", defaultTooltip: true }, { name: "median", defaultTooltip: true }, { name: "Q3", defaultTooltip: true }, { name: "max", defaultTooltip: true }], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, hoverAnimation: true, layout: null, boxWidth: [7, 50], itemStyle: { color: "#fff", borderWidth: 1 }, emphasis: { itemStyle: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: "rgba(0,0,0,0.4)" } }, animationEasing: "elasticOut", animationDuration: 800 } }); Gq(H2, xr, true); var FV = ["itemStyle"]; var jx = ["emphasis", "itemStyle"]; var aR = dF.extend({ type: "boxplot", render: function (i, e, k) { var m = i.getData(); var Z = this.group; var v1 = this._data; if (!this._data) { Z.removeAll() } var v = i.get("layout") === "horizontal" ? 1 : 0; m.diff(v1).add(function (v3) { if (m.hasValue(v3)) { var v2 = m.getItemLayout(v3); var Ij = de(v2, m, v3, v, true); m.setItemGraphicEl(v3, Ij); Z.add(Ij) } }).update(function (Ij, v2) { var Ik = v1.getItemGraphicEl(v2); if (!m.hasValue(Ij)) { Z.remove(Ik); return } var v3 = m.getItemLayout(Ij); if (!Ik) { Ik = de(v3, m, Ij, v) } else { sS(v3, Ik, m, Ij) } Z.add(Ik); m.setItemGraphicEl(Ij, Ik) }).remove(function (v2) { var v3 = v1.getItemGraphicEl(v2); v3 && Z.remove(v3) }).execute(); this._data = m }, remove: function (e) { var k = this.group; var i = this._data; this._data = null; i && i.eachItemGraphicEl(function (m) { m && k.remove(m) }) }, dispose: V }); var rL = mm.extend({ type: "boxplotBoxPath", shape: {}, buildPath: function (k, m) { var e = m.points; var v = 0; k.moveTo(e[v][0], e[v][1]); v++; for (; v < 4; v++) { k.lineTo(e[v][0], e[v][1]) } k.closePath(); for (; v < e.length; v++) { k.moveTo(e[v][0], e[v][1]); v++; k.lineTo(e[v][0], e[v][1]) } } }); function de(m, v, i, Z, v1) { var e = m.ends; var k = new rL({ shape: { points: v1 ? fI(e, Z, m) : e } }); sS(m, k, v, i, v1); return k } function sS(Ik, e, Z, Ij, v2) { var v = Z.hostModel; var v1 = yf[v2 ? "initProps" : "updateProps"]; v1(e, { shape: { points: Ik.ends } }, v, Ij); var Il = Z.getItemModel(Ij); var m = Il.getModel(FV); var i = Z.getItemVisual(Ij, "color"); var v3 = m.getItemStyle(["borderColor"]); v3.stroke = i; v3.strokeNoScale = true; e.useStyle(v3); e.z2 = 100; var k = Il.getModel(jx).getItemStyle(); yn(e, k) } function fI(i, k, e) { return Ef(i, function (m) { m = m.slice(); m[k] = e.initBaseline; return m }) } var wR = ["itemStyle", "borderColor"]; var pN = function (e, i) { var k = e.get("color"); e.eachRawSeriesByType("boxplot", function (v) { var m = k[v.seriesIndex % k.length]; var Z = v.getData(); Z.setVisual({ legendSymbol: "roundRect", color: v.get(wR) || m }); if (!e.isSeriesFiltered(v)) { Z.each(function (v1) { var v2 = Z.getItemModel(v1); Z.setItemVisual(v1, { color: v2.get(wR, true) }) }) } }) }; var tW = o9; var FN = function (e) { var i = qN(e); tW(i, function (k) { var m = k.seriesModels; if (!m.length) { return } Ic(k); tW(m, function (Z, v) { mV(Z, k.boxOffsetList[v], k.boxWidthList[v]) }) }) }; function qN(i) { var e = []; var k = []; i.eachSeriesByType("boxplot", function (v) { var Z = v.getBaseAxis(); var m = eP(k, Z); if (m < 0) { m = k.length; k[m] = Z; e[m] = { axis: Z, seriesModels: [] } } e[m].seriesModels.push(v) }); return e } function Ic(Ij) {
    var Im; var i = Ij.axis; var k = Ij.seriesModels; var v = k.length; var Z = Ij.boxWidthList = []; var v3 = Ij.boxOffsetList = []; var In = []; var m; if (i.type === "category") { m = i.getBandWidth() } else { var v2 = 0; tW(k, function (Io) { v2 = Math.max(v2, Io.getData().count()) }); Im = i.getExtent(), Math.abs(Im[1] - Im[0]) / v2 } tW(k, function (Io) {
      var Ip = Io.get("boxWidth"); if (!GG(Ip)) {
        Ip = [Ip, Ip]
      } In.push([zN(Ip[0], m) || 0, zN(Ip[1], m) || 0])
    }); var Ik = m * 0.8 - 2; var Il = Ik / v * 0.3; var v1 = (Ik - Il * (v - 1)) / v; var e = v1 / 2 - Ik / 2; tW(k, function (Ip, Io) { v3.push(e); e += Il + v1; Z.push(Math.min(Math.max(v1, In[Io][0]), In[Io][1])) })
  } function mV(Ik, k, v2) { var m = Ik.coordinateSystem; var Iv = Ik.getData(); var Z = v2 / 2; var Im = Ik.get("layout") === "horizontal" ? 0 : 1; var v3 = 1 - Im; var It = ["x", "y"]; var In = Iv.mapDimension(It[Im]); var Il = Iv.mapDimension(It[v3], true); if (In == null || Il.length < 5) { return } for (var Iu = 0; Iu < Iv.count(); Iu++) { var v1 = Iv.get(In, Iu); var v = e(v1, Il[2], Iu); var Is = e(v1, Il[0], Iu); var Ir = e(v1, Il[1], Iu); var Iq = e(v1, Il[3], Iu); var Ip = e(v1, Il[4], Iu); var Ij = []; Io(Ij, Ir, 0); Io(Ij, Iq, 1); Ij.push(Is, Ir, Ip, Iq); i(Ij, Is); i(Ij, Ip); i(Ij, v); Iv.setItemLayout(Iu, { initBaseline: v[v3], ends: Ij }) } function e(Iz, Ix, Iy) { var IB = Iv.get(Ix, Iy); var IA = []; IA[Im] = Iz; IA[v3] = IB; var Iw; if (isNaN(Iz) || isNaN(IB)) { Iw = [NaN, NaN] } else { Iw = m.dataToPoint(IA); Iw[Im] += k } return Iw } function Io(Ix, Iw, IA) { var Iz = Iw.slice(); var Iy = Iw.slice(); Iz[Im] += Z; Iy[Im] -= Z; IA ? Ix.push(Iz, Iy) : Ix.push(Iy, Iz) } function i(Iw, Ix) { var Iz = Ix.slice(); var Iy = Ix.slice(); Iz[Im] -= Z; Iy[Im] += Z; Iw.push(Iz, Iy) } } G(pN); pr(FN); var qi = nU.extend({ type: "series.candlestick", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: [{ name: "open", defaultTooltip: true }, { name: "close", defaultTooltip: true }, { name: "lowest", defaultTooltip: true }, { name: "highest", defaultTooltip: true }], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, hoverAnimation: true, layout: null, itemStyle: { color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656" }, emphasis: { itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: true, largeThreshold: 600, progressive: 3000, progressiveThreshold: 10000, progressiveChunkMode: "mod", animationUpdate: false, animationEasing: "linear", animationDuration: 300 }, getShadowDim: function () { return "open" }, brushSelector: function (i, m, e) { var k = m.getItemLayout(i); return k && e.rect(k.brushRect) } }); Gq(qi, xr, true); var Fo = ["itemStyle"]; var nS = ["emphasis", "itemStyle"]; var GH = ["color", "color0", "borderColor", "borderColor0"]; var zo = dF.extend({ type: "candlestick", render: function (i, e, k) { this._updateDrawMode(i); this._isLargeDraw ? this._renderLarge(i) : this._renderNormal(i) }, incrementalPrepareRender: function (i, e, k) { this._clear(); this._updateDrawMode(i) }, incrementalRender: function (m, i, e, k) { this._isLargeDraw ? this._incrementalRenderLarge(m, i) : this._incrementalRenderNormal(m, i) }, _updateDrawMode: function (i) { var e = i.pipelineContext.large; if (this._isLargeDraw == null || e ^ this._isLargeDraw) { this._isLargeDraw = e; this._clear() } }, _renderNormal: function (i) { var k = i.getData(); var v = this._data; var m = this.group; var e = k.getLayout("isSimpleBox"); if (!this._data) { m.removeAll() } k.diff(v).add(function (v2) { if (k.hasValue(v2)) { var v1; var Z = k.getItemLayout(v2); v1 = F3(Z, v2, true); jC(v1, { shape: { points: Z.ends } }, i, v2); Ba(v1, k, v2, e); m.add(v1); k.setItemGraphicEl(v2, v1) } }).update(function (v3, Z) { var v2 = v.getItemGraphicEl(Z); if (!k.hasValue(v3)) { m.remove(v2); return } var v1 = k.getItemLayout(v3); if (!v2) { v2 = F3(v1, v3) } else { oS(v2, { shape: { points: v1.ends } }, i, v3) } Ba(v2, k, v3, e); m.add(v2); k.setItemGraphicEl(v3, v2) }).remove(function (Z) { var v1 = v.getItemGraphicEl(Z); v1 && m.remove(v1) }).execute(); this._data = k }, _renderLarge: function (e) { this._clear(); FT(e, this.group) }, _incrementalRenderNormal: function (v1, i) { var Z = i.getData(); var e = Z.getLayout("isSimpleBox"); var k; while ((k = v1.next()) != null) { var v; var m = Z.getItemLayout(k); v = F3(m, k); Ba(v, Z, k, e); v.incremental = true; this.group.add(v) } }, _incrementalRenderLarge: function (i, e) { FT(e, this.group, true) }, remove: function (e) { this._clear() }, _clear: function () { this.group.removeAll(); this._data = null }, dispose: V }); var mf = mm.extend({ type: "normalCandlestickBox", shape: {}, buildPath: function (i, k) { var e = k.points; if (this.__simpleBox) { i.moveTo(e[4][0], e[4][1]); i.lineTo(e[6][0], e[6][1]) } else { i.moveTo(e[0][0], e[0][1]); i.lineTo(e[1][0], e[1][1]); i.lineTo(e[2][0], e[2][1]); i.lineTo(e[3][0], e[3][1]); i.closePath(); i.moveTo(e[4][0], e[4][1]); i.lineTo(e[5][0], e[5][1]); i.moveTo(e[6][0], e[6][1]); i.lineTo(e[7][0], e[7][1]) } } }); function F3(k, i, m) { var e = k.ends; return new mf({ shape: { points: m ? GJ(e, k) : e }, z2: 100 }) } function Ba(i, v1, v3, e) { var Ij = v1.getItemModel(v3); var v = Ij.getModel(Fo); var Z = v1.getItemVisual(v3, "color"); var k = v1.getItemVisual(v3, "borderColor") || Z; var v2 = v.getItemStyle(GH); i.useStyle(v2); i.style.strokeNoScale = true; i.style.fill = Z; i.style.stroke = k; i.__simpleBox = e; var m = Ij.getModel(nS).getItemStyle(); yn(i, m) } function GJ(i, e) { return Ef(i, function (k) { k = k.slice(); k[1] = e.initBaseline; return k }) } var p1 = mm.extend({ type: "largeCandlestickBox", shape: {}, buildPath: function (k, m) { var Z = m.points; for (var v = 0; v < Z.length;) { if (this.__sign === Z[v++]) { var e = Z[v++]; k.moveTo(e, Z[v++]); k.lineTo(e, Z[v++]) } else { v += 3 } } } }); function FT(e, v1, Z) {
    var m = e.getData(); var k = m.getLayout("largePoints"); var i = new p1({ shape: { points: k }, __sign: 1 }); v1.add(i); var v = new p1({ shape: { points: k }, __sign: -1 }); v1.add(v); ef(1, i, e, m); ef(-1, v, e, m); if (Z) {
      i.incremental = true;
      v.incremental = true
    }
  } function ef(e, k, i, v) { var Z = e > 0 ? "P" : "N"; var v1 = v.getVisual("borderColor" + Z) || v.getVisual("color" + Z); var m = i.getModel(Fo).getItemStyle(GH); k.useStyle(m); k.style.fill = null; k.style.stroke = v1 } var kU = function (e) { if (!e || !GG(e.series)) { return } o9(e.series, function (i) { if (tJ(i) && i.type === "k") { i.type = "candlestick" } }) }; var g = ["itemStyle", "borderColor"]; var yt = ["itemStyle", "borderColor0"]; var np = ["itemStyle", "color"]; var r5 = ["itemStyle", "color0"]; var qa = { seriesType: "candlestick", plan: Es(), performRawSeries: true, reset: function (m, e) { var Z = m.getData(); var k = m.pipelineContext.large; Z.setVisual({ legendSymbol: "roundRect", colorP: v1(1, m), colorN: v1(-1, m), borderColorP: i(1, m), borderColorN: i(-1, m) }); if (e.isSeriesFiltered(m)) { return } return !k && { progress: v }; function v(Il, Ik) { var v3; while ((v3 = Il.next()) != null) { var Ij = Ik.getItemModel(v3); var v2 = Ik.getItemLayout(v3).sign; Ik.setItemVisual(v3, { color: v1(v2, Ij), borderColor: i(v2, Ij) }) } } function v1(v2, v3) { return v3.get(v2 > 0 ? np : r5) } function i(v2, v3) { return v3.get(v2 > 0 ? g : yt) } } }; var vR = typeof Float32Array !== "undefined" ? Float32Array : Array; var F7 = { seriesType: "candlestick", plan: Es(), reset: function (m) { var v = m.coordinateSystem; var v1 = m.getData(); var Io = qx(m, v1); var Im = 0; var i = 1; var Ik = ["x", "y"]; var Il = v1.mapDimension(Ik[Im]); var In = v1.mapDimension(Ik[i], true); var Ij = In[0]; var e = In[1]; var v2 = In[2]; var Z = In[3]; v1.setLayout({ candleWidth: Io, isSimpleBox: Io <= 1.3 }); if (Il == null || In.length < 4) { return } return { progress: m.pipelineContext.large ? v3 : k }; function k(IE, IH) { var IG; while ((IG = IE.next()) != null) { var Iv = IH.get(Il, IG); var IB = IH.get(Ij, IG); var Iu = IH.get(e, IG); var Ip = IH.get(v2, IG); var Ir = IH.get(Z, IG); var IA = Math.min(IB, Iu); var It = Math.max(IB, Iu); var IF = Is(IA, Iv); var Iw = Is(It, Iv); var Iq = Is(Ip, Iv); var Iy = Is(Ir, Iv); var Iz = []; ID(Iz, Iw, 0); ID(Iz, IF, 1); Iz.push(Ix(Iy), Ix(Iw), Ix(Iq), Ix(IF)); IH.setItemLayout(IG, { sign: eH(IH, IG, IB, Iu, e), initBaseline: IB > Iu ? Iw[i] : IF[i], ends: Iz, brushRect: IC(Ip, Ir, Iv) }) } function Is(IK, II) { var IJ = []; IJ[Im] = II; IJ[i] = IK; return (isNaN(II) || isNaN(IK)) ? [NaN, NaN] : v.dataToPoint(IJ) } function ID(IJ, II, IM) { var IL = II.slice(); var IK = II.slice(); IL[Im] = Gw(IL[Im] + Io / 2, 1, false); IK[Im] = Gw(IK[Im] - Io / 2, 1, true); IM ? IJ.push(IL, IK) : IJ.push(IK, IL) } function IC(IL, II, IK) { var IM = Is(IL, IK); var IJ = Is(II, IK); IM[Im] -= Io / 2; IJ[Im] -= Io / 2; return { x: IM[0], y: IM[1], width: i ? Io : IJ[0] - IM[0], height: i ? IJ[1] - IM[1] : Io } } function Ix(II) { II[Im] = Gw(II[Im], 1); return II } } function v3(Is, Iv) { var IB = new vR(Is.count * 5); var Iu = 0; var IA; var Iw = []; var Ir = []; var Iz; while ((Iz = Is.next()) != null) { var Ix = Iv.get(Il, Iz); var It = Iv.get(Ij, Iz); var Iy = Iv.get(e, Iz); var Iq = Iv.get(v2, Iz); var Ip = Iv.get(Z, Iz); if (isNaN(Ix) || isNaN(Iq) || isNaN(Ip)) { IB[Iu++] = NaN; Iu += 4; continue } IB[Iu++] = eH(Iv, Iz, It, Iy, e); Iw[Im] = Ix; Iw[i] = Iq; IA = v.dataToPoint(Iw, null, Ir); IB[Iu++] = IA ? IA[0] : NaN; IB[Iu++] = IA ? IA[1] : NaN; Iw[i] = Ip; IA = v.dataToPoint(Iw, null, Ir); IB[Iu++] = IA ? IA[1] : NaN } Iv.setLayout("largePoints", IB) } } }; function eH(Z, v, m, k, e) { var i; if (m > k) { i = -1 } else { if (m < k) { i = 1 } else { i = v > 0 ? (Z.get(e, v - 1) <= k ? 1 : -1) : 1 } } return i } function qx(i, v2) { var v1 = i.getBaseAxis(); var Z; var e = v1.type === "category" ? v1.getBandWidth() : (Z = v1.getExtent(), Math.abs(Z[1] - Z[0]) / v2.count()); var m = zN(kb(i.get("barMaxWidth"), e), e); var k = zN(kb(i.get("barMinWidth"), 1), e); var v = i.get("barWidth"); return v != null ? zN(v, e) : Math.max(Math.min(e / 2, m), k) } y2(kU); G(qa); pr(F7); nU.extend({ type: "series.effectScatter", dependencies: ["grid", "polar"], getInitialData: function (i, e) { return a(this.getSource(), this) }, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: true, effectType: "ripple", progressive: 0, showEffectOn: "render", rippleEffect: { period: 4, scale: 2.5, brushType: "fill" }, symbolSize: 10 } }); var cZ = 3; function yZ(e) { if (!GG(e)) { e = [+e, +e] } return e } function nC(e, i) { e.eachChild(function (k) { k.attr({ z: i.z, zlevel: i.zlevel, style: { stroke: i.brushType === "stroke" ? i.color : null, fill: i.brushType === "fill" ? i.color : null } }) }) } function HI(m, e) { B8.call(this); var k = new lO(m, e); var i = new B8(); this.add(k); this.add(i); i.beforeUpdate = function () { this.attr(k.getScale()) }; this.updateData(m, e) } var q6 = HI.prototype; q6.stopEffectAnimation = function () { this.childAt(1).removeAll() }; q6.startEffectAnimation = function (Z) { var v2 = Z.symbolType; var e = Z.color; var v = this.childAt(1); for (var m = 0; m < cZ; m++) { var v1 = t9(v2, -1, -1, 2, 2, e); v1.attr({ style: { strokeNoScale: true }, z2: 99, silent: true, scale: [0.5, 0.5] }); var k = -m / cZ * Z.period + Z.effectOffset; v1.animate("", true).when(Z.period, { scale: [Z.rippleScale / 2, Z.rippleScale / 2] }).delay(k).start(); v1.animateStyle(true).when(Z.period, { opacity: 0 }).delay(k).start(); v.add(v1) } nC(v, Z) }; q6.updateEffectAnimation = function (Z) { var e = this._effectCfg; var v = this.childAt(1); var m = ["symbolType", "period", "rippleScale"]; for (var k = 0; k < m.length; k++) { var v1 = m[k]; if (e[v1] !== Z[v1]) { this.stopEffectAnimation(); this.startEffectAnimation(Z); return } } nC(v, Z) }; q6.highlight = function () { this.trigger("emphasis") }; q6.downplay = function () { this.trigger("normal") }; q6.updateData = function (Z, Il) {
    var k = Z.hostModel; this.childAt(0).updateData(Z, Il); var Ik = this.childAt(1);
    var Im = Z.getItemModel(Il); var In = Z.getItemVisual(Il, "symbol"); var i = yZ(Z.getItemVisual(Il, "symbolSize")); var v = Z.getItemVisual(Il, "color"); Ik.attr("scale", i); Ik.traverse(function (Io) { Io.attr({ fill: v }) }); var v3 = Im.getShallow("symbolOffset"); if (v3) { var Ij = Ik.position; Ij[0] = zN(v3[0], i[0]); Ij[1] = zN(v3[1], i[1]) } Ik.rotation = (Im.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0; var v2 = {}; v2.showEffectOn = k.get("showEffectOn"); v2.rippleScale = Im.get("rippleEffect.scale"); v2.brushType = Im.get("rippleEffect.brushType"); v2.period = Im.get("rippleEffect.period") * 1000; v2.effectOffset = Il / Z.count(); v2.z = Im.getShallow("z") || 0; v2.zlevel = Im.getShallow("zlevel") || 0; v2.symbolType = In; v2.color = v; this.off("mouseover").off("mouseout").off("emphasis").off("normal"); if (v2.showEffectOn === "render") { this._effectCfg ? this.updateEffectAnimation(v2) : this.startEffectAnimation(v2); this._effectCfg = v2 } else { this._effectCfg = null; this.stopEffectAnimation(); var e = this.childAt(0); var m = function () { e.highlight(); if (v2.showEffectOn !== "render") { this.startEffectAnimation(v2) } }; var v1 = function () { e.downplay(); if (v2.showEffectOn !== "render") { this.stopEffectAnimation() } }; this.on("mouseover", m, this).on("mouseout", v1, this).on("emphasis", m, this).on("normal", v1, this) } this._effectCfg = v2
  }; q6.fadeOut = function (e) { this.off("mouseover").off("mouseout").off("emphasis").off("normal"); e && e() }; mr(HI, B8); BL({ type: "effectScatter", init: function () { this._symbolDraw = new E9(HI) }, render: function (i, e, m) { var v = i.getData(); var k = this._symbolDraw; k.updateData(v); this.group.add(k.group) }, updateTransform: function (i, e, m) { var v = i.getData(); this.group.dirty(); var k = qA().reset(i); if (k.progress) { k.progress({ start: 0, end: v.count() }, v) } this._symbolDraw.updateLayout(v) }, _updateGroupTransform: function (e) { var i = e.coordinateSystem; if (i && i.getRoamTransform) { this.group.transform = uP(i.getRoamTransform()); this.group.decomposeTransform() } }, remove: function (e, i) { this._symbolDraw && this._symbolDraw.remove(i) }, dispose: function () { } }); G(ml("effectScatter", "circle")); pr(qA("effectScatter")); var rt = typeof Uint32Array === "undefined" ? Array : Uint32Array; var DH = typeof Float64Array === "undefined" ? Array : Float64Array; function bR(e) { var i = e.data; if (i && i[0] && i[0][0] && i[0][0].coord) { if (ok) { console.warn("Lines data configuration has been changed to" + " { coords:[[1,2],[2,3]] }") } e.data = Ef(i, function (v) { var k = [v[0].coord, v[1].coord]; var m = { coords: k }; if (v[0].name) { m.fromName = v[0].name } if (v[1].name) { m.toName = v[1].name } return aa([m, v[0], v[1]]) }) } } var yb = nU.extend({
    type: "series.lines", dependencies: ["grid", "polar"], visualColorAccessPath: "lineStyle.color", init: function (i) { i.data = i.data || []; bR(i); var e = this._processFlatCoordsArray(i.data); this._flatCoords = e.flatCoords; this._flatCoordsOffset = e.flatCoordsOffset; if (e.flatCoords) { i.data = new Float32Array(e.count) } yb.superApply(this, "init", arguments) }, mergeOption: function (i) { i.data = i.data || []; bR(i); if (i.data) { var e = this._processFlatCoordsArray(i.data); this._flatCoords = e.flatCoords; this._flatCoordsOffset = e.flatCoordsOffset; if (e.flatCoords) { i.data = new Float32Array(e.count) } } yb.superApply(this, "mergeOption", arguments) }, appendData: function (i) { var e = this._processFlatCoordsArray(i.data); if (e.flatCoords) { if (!this._flatCoords) { this._flatCoords = e.flatCoords; this._flatCoordsOffset = e.flatCoordsOffset } else { this._flatCoords = ld(this._flatCoords, e.flatCoords); this._flatCoordsOffset = ld(this._flatCoordsOffset, e.flatCoordsOffset) } i.data = new Float32Array(e.count) } this.getRawData().appendData(i.data) }, _getCoordsFromItemModel: function (e) { var i = this.getData().getItemModel(e); var k = (i.option instanceof Array) ? i.option : i.getShallow("coords"); if (ok) { if (!(k instanceof Array && k.length > 0 && k[0] instanceof Array)) { throw new Error("Invalid coords " + JSON.stringify(k) + ". Lines must have 2d coords array in data item.") } } return k }, getLineCoordsCount: function (e) { if (this._flatCoordsOffset) { return this._flatCoordsOffset[e * 2 + 1] } else { return this._getCoordsFromItemModel(e).length } }, getLineCoords: function (k, m) { if (this._flatCoordsOffset) { var v1 = this._flatCoordsOffset[k * 2]; var e = this._flatCoordsOffset[k * 2 + 1]; for (var v = 0; v < e; v++) { m[v] = m[v] || []; m[v][0] = this._flatCoords[v1 + v * 2]; m[v][1] = this._flatCoords[v1 + v * 2 + 1] } return e } else { var Z = this._getCoordsFromItemModel(k); for (var v = 0; v < Z.length; v++) { m[v] = m[v] || []; m[v][0] = Z[v][0]; m[v][1] = Z[v][1] } return Z.length } }, _processFlatCoordsArray: function (Z) { var Ij = 0; if (this._flatCoords) { Ij = this._flatCoords.length } if (typeof Z[0] === "number") { var v3 = Z.length; var In = new rt(v3); var v1 = new DH(v3); var Io = 0; var e = 0; var Im = 0; for (var v = 0; v < v3;) { Im++; var v2 = Z[v++]; In[e++] = Io + Ij; In[e++] = v2; for (var m = 0; m < v2; m++) { var Il = Z[v++]; var Ik = Z[v++]; v1[Io++] = Il; v1[Io++] = Ik; if (v > v3) { if (ok) { throw new Error("Invalid data format.") } } } } return { flatCoordsOffset: new Uint32Array(In.buffer, 0, e), flatCoords: v1, count: Im } } return { flatCoordsOffset: null, flatCoords: null, count: Z.length } }, getInitialData: function (k, e) {
      if (ok) { var i = fz.get(k.coordinateSystem); if (!i) { throw new Error("Unkown coordinate system " + k.coordinateSystem) } } var m = new xt(["value"], this);
      m.hasItemOption = false; m.initData(k.data, [], function (v, v3, Z, v2) { if (v instanceof Array) { return NaN } else { m.hasItemOption = true; var v1 = v.value; if (v1 != null) { return v1 instanceof Array ? v1[v2] : v1 } } }); return m
    }, formatTooltip: function (v) { var v1 = this.getData(); var Z = v1.getItemModel(v); var i = Z.get("name"); if (i) { return i } var m = Z.get("fromName"); var e = Z.get("toName"); var k = []; m != null && k.push(m); e != null && k.push(e); return mv(k.join(" > ")) }, preventIncremental: function () { return !!this.get("effect.show") }, getProgressive: function () { var e = this.option.progressive; if (e == null) { return this.option.large ? 10000 : this.get("progressive") } return e }, getProgressiveThreshold: function () { var e = this.option.progressiveThreshold; if (e == null) { return this.option.large ? 20000 : this.get("progressiveThreshold") } return e }, defaultOption: { coordinateSystem: "geo", zlevel: 0, z: 2, legendHoverLink: true, hoverAnimation: true, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: false, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: true, trailLength: 0.2 }, large: false, largeThreshold: 2000, polyline: false, label: { show: false, position: "end" }, lineStyle: { opacity: 0.5 } }
  }); function x5(k, e, i) { B8.call(this); this.add(this.createLine(k, e, i)); this._updateEffectSymbol(k, e) } var mZ = x5.prototype; mZ.createLine = function (k, e, i) { return new mM(k, e, i) }; mZ._updateEffectSymbol = function (v2, e) { var v = v2.getItemModel(e); var k = v.getModel("effect"); var m = k.get("symbolSize"); var v1 = k.get("symbol"); if (!GG(m)) { m = [m, m] } var i = k.get("color") || v2.getItemVisual(e, "color"); var Z = this.childAt(1); if (this._symbolType !== v1) { this.remove(Z); Z = t9(v1, -0.5, -0.5, 1, 1, i); Z.z2 = 100; Z.culling = true; this.add(Z) } if (!Z) { return } Z.setStyle("shadowColor", i); Z.setStyle(k.getItemStyle(["color"])); Z.attr("scale", m); Z.setColor(i); Z.attr("scale", m); this._symbolType = v1; this._updateEffectAnimation(v2, k, e) }; mZ._updateEffectAnimation = function (k, Il, Ij) { var m = this.childAt(1); if (!m) { return } var Im = this; var Ik = k.getItemLayout(Ij); var v3 = Il.get("period") * 1000; var Z = Il.get("loop"); var v2 = Il.get("constantSpeed"); var e = gu(Il.get("delay"), function (In) { return In / k.count() * v3 / 3 }); var v1 = typeof e === "function"; m.ignore = true; this.updateAnimationPoints(m, Ik); if (v2 > 0) { v3 = this.getLineLength(m) / v2 * 1000 } if (v3 !== this._period || Z !== this._loop) { m.stopAnimation(); var v = e; if (v1) { v = e(Ij) } if (m.__t > 0) { v = -v3 * m.__t } m.__t = 0; var i = m.animate("", Z).when(v3, { __t: 1 }).delay(v).during(function () { Im.updateSymbolPosition(m) }); if (!Z) { i.done(function () { Im.remove(m) }) } i.start() } this._period = v3; this._loop = Z }; mZ.getLineLength = function (e) { return (DV(e.__p1, e.__cp1) + DV(e.__cp1, e.__p2)) }; mZ.updateAnimationPoints = function (i, e) { i.__p1 = e[0]; i.__p2 = e[1]; i.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2] }; mZ.updateData = function (k, e, i) { this.childAt(0).updateData(k, e, i); this._updateEffectSymbol(k, e) }; mZ.updateSymbolPosition = function (e) { var v3 = e.__p1; var v2 = e.__p2; var v = e.__cp1; var Ij = e.__t; var v1 = e.position; var Z = kw; var i = vw; v1[0] = Z(v3[0], v[0], v2[0], Ij); v1[1] = Z(v3[1], v[1], v2[1], Ij); var m = i(v3[0], v[0], v2[0], Ij); var k = i(v3[1], v[1], v2[1], Ij); e.rotation = -Math.atan2(k, m) - Math.PI / 2; e.ignore = false }; mZ.updateLayout = function (k, e) { this.childAt(0).updateLayout(k, e); var i = k.getItemModel(e).getModel("effect"); this._updateEffectAnimation(k, i, e) }; mr(x5, B8); function iJ(k, e, i) { B8.call(this); this._createPolyline(k, e, i) } var ar = iJ.prototype; ar._createPolyline = function (v, e, k) { var m = v.getItemLayout(e); var i = new z7({ shape: { points: m } }); this.add(i); this._updateCommonStl(v, e, k) }; ar.updateData = function (Z, e, m) { var k = Z.hostModel; var i = this.childAt(0); var v = { shape: { points: Z.getItemLayout(e) } }; oS(i, v, k, e); this._updateCommonStl(Z, e, m) }; ar._updateCommonStl = function (v2, i, v) { var k = this.childAt(0); var Z = v2.getItemModel(i); var m = v2.getItemVisual(i, "color"); var e = v && v.lineStyle; var v1 = v && v.hoverLineStyle; if (!v || v2.hasItemOption) { e = Z.getModel("lineStyle").getLineStyle(); v1 = Z.getModel("emphasis.lineStyle").getLineStyle() } k.useStyle(De({ strokeNoScale: true, fill: "none", stroke: m }, e)); k.hoverStyle = v1; yn(this) }; ar.updateLayout = function (k, e) { var i = this.childAt(0); i.setShape("points", k.getItemLayout(e)) }; mr(iJ, B8); function f(k, e, i) { x5.call(this, k, e, i); this._lastFrame = 0; this._lastFramePercent = 0 } var ra = f.prototype; ra.createLine = function (k, e, i) { return new iJ(k, e, i) }; ra.updateAnimationPoints = function (v, m) { this._points = m; var v2 = [0]; var k = 0; for (var e = 1; e < m.length; e++) { var v1 = m[e - 1]; var Z = m[e]; k += DV(v1, Z); v2.push(k) } if (k === 0) { return } for (var e = 0; e < v2.length; e++) { v2[e] /= k } this._offsets = v2; this._length = k }; ra.getLineLength = function (e) { return this._length }; ra.updateSymbolPosition = function (m) {
    var Ij = m.__t; var v3 = this._points; var v = this._offsets; var v2 = v3.length; if (!v) { return } var i = this._lastFrame; var k; if (Ij < this._lastFramePercent) { var e = Math.min(i + 1, v2 - 1); for (k = e; k >= 0; k--) { if (v[k] <= Ij) { break } } k = Math.min(k, v2 - 2) } else { for (var k = i; k < v2; k++) { if (v[k] > Ij) { break } } k = Math.min(k - 1, v2 - 2) } rH(m.position, v3[k], v3[k + 1], (Ij - v[k]) / (v[k + 1] - v[k])); var v1 = v3[k + 1][0] - v3[k][0]; var Z = v3[k + 1][1] - v3[k][1]; m.rotation = -Math.atan2(Z, v1) - Math.PI / 2;
    this._lastFrame = k; this._lastFramePercent = Ij; m.ignore = false
  }; mr(f, x5); var i4 = Hw({ shape: { polyline: false, curveness: 0, segs: [] }, buildPath: function (Io, Ik) { var v = Ik.segs; var v2 = Ik.curveness; if (Ik.polyline) { for (var v3 = 0; v3 < v.length;) { var Ij = v[v3++]; if (Ij > 0) { Io.moveTo(v[v3++], v[v3++]); for (var v1 = 1; v1 < Ij; v1++) { Io.lineTo(v[v3++], v[v3++]) } } } } else { for (var v3 = 0; v3 < v.length;) { var Z = v[v3++]; var In = v[v3++]; var m = v[v3++]; var Im = v[v3++]; Io.moveTo(Z, In); if (v2 > 0) { var e = (Z + m) / 2 - (In - Im) * v2; var Il = (In + Im) / 2 - (m - Z) * v2; Io.quadraticCurveTo(e, Il, m, Im) } else { Io.lineTo(m, Im) } } } }, findDataIndex: function (Ip, Im) { var Ik = this.shape; var v = Ik.segs; var v2 = Ik.curveness; if (Ik.polyline) { var Io = 0; for (var v3 = 0; v3 < v.length;) { var Ij = v[v3++]; if (Ij > 0) { var Z = v[v3++]; var Iq = v[v3++]; for (var v1 = 1; v1 < Ij; v1++) { var m = v[v3++]; var In = v[v3++]; if (qU(Z, Iq, m, In)) { return Io } } } Io++ } } else { var Io = 0; for (var v3 = 0; v3 < v.length;) { var Z = v[v3++]; var Iq = v[v3++]; var m = v[v3++]; var In = v[v3++]; if (v2 > 0) { var e = (Z + m) / 2 - (Iq - In) * v2; var Il = (Iq + In) / 2 - (m - Z) * v2; if (qS(Z, Iq, e, Il, m, In)) { return Io } } else { if (qU(Z, Iq, m, In)) { return Io } } Io++ } } return -1 } }); function HC() { this.group = new B8() } var eY = HC.prototype; eY.isPersistent = function () { return !this._incremental }; eY.updateData = function (i) { this.group.removeAll(); var e = new i4({ rectHover: true, cursor: "default" }); e.setShape({ segs: i.getLayout("linesPoints") }); this._setCommon(e, i); this.group.add(e); this._incremental = null }; eY.incrementalPrepareUpdate = function (e) { this.group.removeAll(); this._clearIncremental(); if (e.count() > 500000) { if (!this._incremental) { this._incremental = new zL({ silent: true }) } this.group.add(this._incremental) } else { this._incremental = null } }; eY.incrementalUpdate = function (k, i) { var e = new i4(); e.setShape({ segs: i.getLayout("linesPoints") }); this._setCommon(e, i, !!this._incremental); if (!this._incremental) { e.rectHover = true; e.cursor = "default"; e.__startIndex = k.start; this.group.add(e) } else { this._incremental.addDisplayable(e, true) } }; eY.remove = function () { this._clearIncremental(); this._incremental = null; this.group.removeAll() }; eY._setCommon = function (k, m, e) { var v = m.hostModel; k.setShape({ polyline: v.get("polyline"), curveness: v.get("lineStyle.curveness") }); k.useStyle(v.getModel("lineStyle").getLineStyle()); k.style.strokeNoScale = true; var i = m.getVisual("color"); if (i) { k.setStyle("stroke", i) } k.setStyle("fill"); if (!e) { k.seriesIndex = v.seriesIndex; k.on("mousemove", function (v1) { k.dataIndex = null; var Z = k.findDataIndex(v1.offsetX, v1.offsetY); if (Z > 0) { k.dataIndex = Z + k.__startIndex } }) } }; eY._clearIncremental = function () { var e = this._incremental; if (e) { e.clearDisplaybles() } }; var bX = { seriesType: "lines", plan: Es(), reset: function (e) { var k = e.coordinateSystem; var v = e.get("polyline"); var m = e.pipelineContext.large; function i(v3, v1) { var Ip = []; if (m) { var Iq; var Z = v3.end - v3.start; if (v) { var Im = 0; for (var In = v3.start; In < v3.end; In++) { Im += e.getLineCoordsCount(In) } Iq = new Float32Array(Z + Im * 2) } else { Iq = new Float32Array(Z * 4) } var Il = 0; var It = []; for (var In = v3.start; In < v3.end; In++) { var Io = e.getLineCoords(In, Ip); if (v) { Iq[Il++] = Io } for (var v2 = 0; v2 < Io; v2++) { It = k.dataToPoint(Ip[v2], false, It); Iq[Il++] = It[0]; Iq[Il++] = It[1] } } v1.setLayout("linesPoints", Iq) } else { for (var In = v3.start; In < v3.end; In++) { var Ir = v1.getItemModel(In); var Io = e.getLineCoords(In, Ip); var Is = []; if (v) { for (var Ik = 0; Ik < Io; Ik++) { Is.push(k.dataToPoint(Ip[Ik])) } } else { Is[0] = k.dataToPoint(Ip[0]); Is[1] = k.dataToPoint(Ip[1]); var Ij = Ir.get("lineStyle.curveness"); if (+Ij) { Is[2] = [(Is[0][0] + Is[1][0]) / 2 - (Is[0][1] - Is[1][1]) * Ij, (Is[0][1] + Is[1][1]) / 2 - (Is[1][0] - Is[0][0]) * Ij] } } v1.setItemLayout(In, Is) } } } return { progress: i } } }; BL({
    type: "lines", init: function () { }, render: function (i, v1, v2) { var m = i.getData(); var Ij = this._updateLineDraw(m, i); var Z = i.get("zlevel"); var v = i.get("effect.trailLength"); var v3 = v2.getZr(); var k = v3.painter.getType() === "svg"; if (!k) { v3.painter.getLayer(Z).clear(true) } if (this._lastZlevel != null && !k) { v3.configLayer(this._lastZlevel, { motionBlur: false }) } if (this._showEffect(i) && v) { if (ok) { var e = false; v1.eachSeries(function (Ik) { if (Ik !== i && Ik.get("zlevel") === Z) { e = true } }); e && console.warn("Lines with trail effect should have an individual zlevel") } if (!k) { v3.configLayer(Z, { motionBlur: true, lastFrameAlpha: Math.max(Math.min(v / 10 + 0.9, 1), 0) }) } } Ij.updateData(m); this._lastZlevel = Z; this._finished = true }, incrementalPrepareRender: function (i, e, m) { var v = i.getData(); var k = this._updateLineDraw(v, i); k.incrementalPrepareUpdate(v); this._clearLayer(m); this._finished = false }, incrementalRender: function (k, i, e) { this._lineDraw.incrementalUpdate(k, i.getData()); this._finished = k.end === i.getData().count() }, updateTransform: function (i, e, m) { var Z = i.getData(); var v = i.pipelineContext; if (!this._finished || v.large || v.progressiveRender) { return { update: true } } else { var k = bX.reset(i); if (k.progress) { k.progress({ start: 0, end: Z.count() }, Z) } this._lineDraw.updateLayout(); this._clearLayer(m) } }, _updateLineDraw: function (Z, k) {
      var m = this._lineDraw; var e = this._showEffect(k); var v1 = !!k.get("polyline"); var v = k.pipelineContext; var i = v.large; if (ok) { if (e && i) { console.warn("Large lines not support effect") } } if (!m || e !== this._hasEffet || v1 !== this._isPolyline || i !== this._isLargeDraw) {
        if (m) {
          m.remove()
        } m = this._lineDraw = i ? new HC() : new hw(v1 ? (e ? f : iJ) : (e ? x5 : mM)); this._hasEffet = e; this._isPolyline = v1; this._isLargeDraw = i; this.group.removeAll()
      } this.group.add(m.group); return m
    }, _showEffect: function (e) { return !!e.get("effect.show") }, _clearLayer: function (e) { var k = e.getZr(); var i = k.painter.getType() === "svg"; if (!i && this._lastZlevel != null) { k.painter.getLayer(this._lastZlevel).clear(true) } }, remove: function (e, i) { this._lineDraw && this._lineDraw.remove(); this._lineDraw = null; this._clearLayer(i) }, dispose: function () { }
  }); function ls(e) { if (!(e instanceof Array)) { e = [e, e] } return e } var zP = "lineStyle.opacity".split("."); var FE = { seriesType: "lines", reset: function (i, e, m) { var v1 = ls(i.get("symbol")); var Z = ls(i.get("symbolSize")); var v = i.getData(); v.setVisual("fromSymbol", v1 && v1[0]); v.setVisual("toSymbol", v1 && v1[1]); v.setVisual("fromSymbolSize", Z && Z[0]); v.setVisual("toSymbolSize", Z && Z[1]); v.setVisual("opacity", i.get(zP)); function k(Il, v2) { var Ij = Il.getItemModel(v2); var Im = ls(Ij.getShallow("symbol", true)); var Ik = ls(Ij.getShallow("symbolSize", true)); var v3 = Ij.get(zP); Im[0] && Il.setItemVisual(v2, "fromSymbol", Im[0]); Im[1] && Il.setItemVisual(v2, "toSymbol", Im[1]); Ik[0] && Il.setItemVisual(v2, "fromSymbolSize", Ik[0]); Ik[1] && Il.setItemVisual(v2, "toSymbolSize", Ik[1]); Il.setItemVisual(v2, "opacity", v3) } return { dataEach: v.hasItemOption ? k : null } } }; pr(bX); G(FE); nU.extend({ type: "series.heatmap", getInitialData: function (i, e) { return a(this.getSource(), this, { generateCoord: "value" }) }, preventIncremental: function () { var e = fz.get(this.get("coordinateSystem")); if (e && e.dimensions) { return e.dimensions[0] === "lng" && e.dimensions[1] === "lat" } }, defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0 } }); var oN = 256; function mu() { var e = Dc(); this.canvas = e; this.blurSize = 30; this.pointSize = 20; this.maxOpacity = 1; this.minOpacity = 0; this._gradientPixels = {} } mu.prototype = { update: function (IC, It, Ir, Iw, k, e) { var v = this._getBrush(); var Io = this._getGradient(IC, k, "inRange"); var v2 = this._getGradient(IC, k, "outOfRange"); var Ip = this.pointSize + this.blurSize; var Z = this.canvas; var Iv = Z.getContext("2d"); var Iz = IC.length; Z.width = It; Z.height = Ir; for (var Iy = 0; Iy < Iz; ++Iy) { var Is = IC[Iy]; var Il = Is[0]; var Ik = Is[1]; var Iu = Is[2]; var v1 = Iw(Iu); Iv.globalAlpha = v1; Iv.drawImage(v, Il - Ip, Ik - Ip) } if (!Z.width || !Z.height) { return Z } var IA = Iv.getImageData(0, 0, Z.width, Z.height); var Iq = IA.data; var v3 = 0; var Ij = Iq.length; var Ix = this.minOpacity; var IB = this.maxOpacity; var Im = IB - Ix; while (v3 < Ij) { var v1 = Iq[v3 + 3] / 256; var In = Math.floor(v1 * (oN - 1)) * 4; if (v1 > 0) { var m = e(v1) ? Io : v2; v1 > 0 && (v1 = v1 * Im + Ix); Iq[v3++] = m[In]; Iq[v3++] = m[In + 1]; Iq[v3++] = m[In + 2]; Iq[v3++] = m[In + 3] * v1 * 256 } else { v3 += 4 } } Iv.putImageData(IA, 0, 0); return Z }, _getBrush: function () { var k = this._brushCanvas || (this._brushCanvas = Dc()); var i = this.pointSize + this.blurSize; var m = i * 2; k.width = m; k.height = m; var e = k.getContext("2d"); e.clearRect(0, 0, m, m); e.shadowOffsetX = m; e.shadowBlur = this.blurSize; e.shadowColor = "#000"; e.beginPath(); e.arc(-i, i, this.pointSize, 0, Math.PI * 2, true); e.closePath(); e.fill(); return k }, _getGradient: function (v2, v, v1) { var m = this._gradientPixels; var k = m[v1] || (m[v1] = new Uint8ClampedArray(256 * 4)); var e = [0, 0, 0, 0]; var v3 = 0; for (var Z = 0; Z < 256; Z++) { v[v1](Z / 255, true, e); k[v3++] = e[0]; k[v3++] = e[1]; k[v3++] = e[2]; k[v3++] = e[3] } return k } }; function cR(v, i, m) { var k = v[1] - v[0]; i = Ef(i, function (v1) { return { interval: [(v1.interval[0] - v[0]) / k, (v1.interval[1] - v[0]) / k] } }); var e = i.length; var Z = 0; return function (v3) { for (var v2 = Z; v2 < e; v2++) { var v1 = i[v2].interval; if (v1[0] <= v3 && v3 <= v1[1]) { Z = v2; break } } if (v2 === e) { for (var v2 = Z - 1; v2 >= 0; v2--) { var v1 = i[v2].interval; if (v1[0] <= v3 && v3 <= v1[1]) { Z = v2; break } } } return v2 >= 0 && v2 < e && m[v2] } } function q(k, i) { var e = k[1] - k[0]; i = [(i[0] - k[0]) / e, (i[1] - k[0]) / e]; return function (m) { return m >= i[0] && m <= i[1] } } function sx(e) { var i = e.dimensions; return i[0] === "lng" && i[1] === "lat" } BL({
    type: "heatmap", render: function (i, e, m) { var v; e.eachComponent("visualMap", function (Z) { Z.eachTargetSeries(function (v1) { if (v1 === i) { v = Z } }) }); if (ok) { if (!v) { throw new Error("Heatmap must use with visualMap") } } this.group.removeAll(); this._incrementalDisplayable = null; var k = i.coordinateSystem; if (k.type === "cartesian2d" || k.type === "calendar") { this._renderOnCartesianAndCalendar(i, m, 0, i.getData().count()) } else { if (sx(k)) { this._renderOnGeo(k, i, v, m) } } }, incrementalPrepareRender: function (i, e, k) { this.group.removeAll() }, incrementalRender: function (v, i, e, m) { var k = i.coordinateSystem; if (k) { this._renderOnCartesianAndCalendar(i, m, v.start, v.end, true) } }, _renderOnCartesianAndCalendar: function (Iq, Im, v1, Z, Is) {
      var v2 = Iq.coordinateSystem; var Ir; var Io; if (v2.type === "cartesian2d") { var Ij = v2.getAxis("x"); var e = v2.getAxis("y"); if (ok) { if (!(Ij.type === "category" && e.type === "category")) { throw new Error("Heatmap on cartesian must have two category axes") } if (!(Ij.onBand && e.onBand)) { throw new Error("Heatmap on cartesian must have two axes with boundaryGap true") } } Ir = Ij.getBandWidth(); Io = e.getBandWidth() } var v3 = this.group; var IB = Iq.getData(); var m = "itemStyle"; var k = "emphasis.itemStyle"; var Il = "label"; var Iz = "emphasis.label";
      var Iy = Iq.getModel(m).getItemStyle(["color"]); var Iu = Iq.getModel(k).getItemStyle(); var Ik = Iq.getModel(Il); var Ix = Iq.getModel(Iz); var IA = v2.type; var v = IA === "cartesian2d" ? [IB.mapDimension("x"), IB.mapDimension("y"), IB.mapDimension("value")] : [IB.mapDimension("time"), IB.mapDimension("value")]; for (var In = v1; In < Z; In++) { var i; if (IA === "cartesian2d") { if (isNaN(IB.get(v[2], In))) { continue } var It = v2.dataToPoint([IB.get(v[0], In), IB.get(v[1], In)]); i = new EH({ shape: { x: It[0] - Ir / 2, y: It[1] - Io / 2, width: Ir, height: Io }, style: { fill: IB.getItemVisual(In, "color"), opacity: IB.getItemVisual(In, "opacity") } }) } else { if (isNaN(IB.get(v[1], In))) { continue } i = new EH({ z2: 1, shape: v2.dataToRect([IB.get(v[0], In)]).contentShape, style: { fill: IB.getItemVisual(In, "color"), opacity: IB.getItemVisual(In, "opacity") } }) } var Iw = IB.getItemModel(In); if (IB.hasItemOption) { Iy = Iw.getModel(m).getItemStyle(["color"]); Iu = Iw.getModel(k).getItemStyle(); Ik = Iw.getModel(Il); Ix = Iw.getModel(Iz) } var Iv = Iq.getRawValue(In); var Ip = "-"; if (Iv && Iv[2] != null) { Ip = Iv[2] } BD(Iy, Iu, Ik, Ix, { labelFetcher: Iq, labelDataIndex: In, defaultText: Ip, isRectText: true }); i.setStyle(Iy); yn(i, IB.hasItemOption ? Iu : b0({}, Iu)); i.incremental = Is; if (Is) { i.useHoverLayer = true } v3.add(i); IB.setItemGraphicEl(In, i) }
    }, _renderOnGeo: function (Iu, In, v2, Ik) { var v = v2.targetVisuals.inRange; var Ij = v2.targetVisuals.outOfRange; var Is = In.getData(); var Z = this._hmLayer || (this._hmLayer || new mu()); Z.blurSize = In.get("blurSize"); Z.pointSize = In.get("pointSize"); Z.minOpacity = In.get("minOpacity"); Z.maxOpacity = In.get("maxOpacity"); var i = Iu.getViewRect().clone(); var m = Iu.getRoamTransform(); i.applyTransform(m); var v3 = Math.max(i.x, 0); var v1 = Math.max(i.y, 0); var Ir = Math.min(i.width + i.x, Ik.getWidth()); var k = Math.min(i.height + i.y, Ik.getHeight()); var Io = Ir - v3; var Il = k - v1; var Im = [Is.mapDimension("lng"), Is.mapDimension("lat"), Is.mapDimension("value")]; var Iq = Is.mapArray(Im, function (Iv, Iy, Iw) { var Ix = Iu.dataToPoint([Iv, Iy]); Ix[0] -= v3; Ix[1] -= v1; Ix.push(Iw); return Ix }); var Ip = v2.getExtent(); var e = v2.type === "visualMap.continuous" ? q(Ip, v2.option.range) : cR(Ip, v2.getPieceList(), v2.option.selected); Z.update(Iq, Io, Il, v.color.getNormalizer(), { inRange: v.color.getColorMapper(), outOfRange: Ij.color.getColorMapper() }, e); var It = new Ft({ style: { width: Io, height: Il, x: v3, y: v1, image: Z.canvas }, silent: true }); this.group.add(It) }, dispose: function () { }
  }); var gE = wN.extend({ type: "series.pictorialBar", dependencies: ["grid"], defaultOption: { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: false, symbolRepeatDirection: "end", symbolClip: false, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", progressive: 0, hoverAnimation: false }, getInitialData: function (e) { e.stack = null; return gE.superApply(this, "getInitialData", arguments) } }); var AP = ["itemStyle", "borderWidth"]; var yL = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }]; var Ch = new GI(); var fg = BL({ type: "pictorialBar", render: function (k, v1, v2) { var Ij = this.group; var m = k.getData(); var v = this._data; var Z = k.coordinateSystem; var i = Z.getBaseAxis(); var v3 = !!i.isHorizontal(); var Ik = Z.grid.getRect(); var e = { ecSize: { width: v2.getWidth(), height: v2.getHeight() }, seriesModel: k, coordSys: Z, coordSysExtent: [[Ik.x, Ik.x + Ik.width], [Ik.y, Ik.y + Ik.height]], isHorizontal: v3, valueDim: yL[+v3], categoryDim: yL[1 - v3] }; m.diff(v).add(function (Im) { if (!m.hasValue(Im)) { return } var In = zn(m, Im); var Il = ou(m, Im, In, e); var Io = pb(m, e, Il); m.setItemGraphicEl(Im, Io); Ij.add(Io); iW(Io, e, Il) }).update(function (Im, Iq) { var Io = v.getItemGraphicEl(Iq); if (!m.hasValue(Im)) { Ij.remove(Io); return } var In = zn(m, Im); var Il = ou(m, Im, In, e); var Ip = cr(m, Il); if (Io && Ip !== Io.__pictorialShapeStr) { Ij.remove(Io); m.setItemGraphicEl(Im, null); Io = null } if (Io) { c0(Io, e, Il) } else { Io = pb(m, e, Il, true) } m.setItemGraphicEl(Im, Io); Io.__pictorialSymbolMeta = Il; Ij.add(Io); iW(Io, e, Il) }).remove(function (Il) { var Im = v.getItemGraphicEl(Il); Im && wv(v, Il, Im.__pictorialSymbolMeta.animationModel, Im) }).execute(); this._data = m; return this.group }, dispose: V, remove: function (e, i) { var m = this.group; var k = this._data; if (e.get("animation")) { if (k) { k.eachItemGraphicEl(function (v) { wv(k, v.dataIndex, e, v) }) } } else { m.removeAll() } } }); function ou(v1, Il, Io, e) {
    var v2 = v1.getItemLayout(Il); var Z = Io.get("symbolRepeat"); var v3 = Io.get("symbolClip"); var Im = Io.get("symbolPosition") || "start"; var Ik = Io.get("symbolRotate"); var In = (Ik || 0) * Math.PI / 180 || 0; var v = Io.get("symbolPatternSize") || 2; var i = Io.isAnimationEnabled(); var k = { dataIndex: Il, layout: v2, itemModel: Io, symbolType: v1.getItemVisual(Il, "symbol") || "circle", color: v1.getItemVisual(Il, "color"), symbolClip: v3, symbolRepeat: Z, symbolRepeatDirection: Io.get("symbolRepeatDirection"), symbolPatternSize: v, rotation: In, animationModel: i ? Io : null, hoverAnimation: i && Io.get("hoverAnimation"), z2: Io.getShallow("z", true) || 0 }; o(Io, Z, v2, e, k); zX(v1, Il, v2, Z, v3, k.boundingLength, k.pxSign, v, e, k); pZ(Io, k.symbolScale, In, e, k); var m = k.symbolSize; var Ij = Io.get("symbolOffset"); if (GG(Ij)) { Ij = [zN(Ij[0], m[0]), zN(Ij[1], m[1])] } kS(Io, m, v2, Z, v3, Ij, Im, k.valueLineWidth, k.boundingLength, k.repeatCutLength, e, k);
    return k
  } function o(Il, m, Z, e, i) { var v2 = e.valueDim; var v1 = Il.get("symbolBoundingData"); var Ij = e.coordSys.getOtherAxis(e.coordSys.getBaseAxis()); var Ik = Ij.toGlobalCoord(Ij.dataToCoord(0)); var k = 1 - +(Z[v2.wh] <= 0); var v3; if (GG(v1)) { var v = [h(Ij, v1[0]) - Ik, h(Ij, v1[1]) - Ik]; v[1] < v[0] && (v.reverse()); v3 = v[k] } else { if (v1 != null) { v3 = h(Ij, v1) - Ik } else { if (m) { v3 = e.coordSysExtent[v2.index][k] - Ik } else { v3 = Z[v2.wh] } } } i.boundingLength = v3; if (m) { i.repeatCutLength = Z[v2.wh] } i.pxSign = v3 > 0 ? 1 : v3 < 0 ? -1 : 0 } function h(e, i) { return e.toGlobalCoord(e.dataToCoord(e.scale.parse(i))) } function zX(v1, In, Ij, Z, Ik, Im, v2, v, e, k) { var Il = e.valueDim; var Io = e.categoryDim; var i = Math.abs(Ij[Io.wh]); var m = v1.getItemVisual(In, "symbolSize"); if (GG(m)) { m = m.slice() } else { if (m == null) { m = "100%" } m = [m, m] } m[Io.index] = zN(m[Io.index], i); m[Il.index] = zN(m[Il.index], Z ? i : Math.abs(Im)); k.symbolSize = m; var v3 = k.symbolScale = [m[0] / v, m[1] / v]; v3[Il.index] *= (e.isHorizontal ? -1 : 1) * v2 } function pZ(m, Z, k, i, e) { var v = m.get(AP) || 0; if (v) { Ch.attr({ scale: Z.slice(), rotation: k }); Ch.updateTransform(); v /= Ch.getLineScale(); v *= Z[i.valueDim.index] } e.valueLineWidth = v } function kS(It, IB, Iz, Ix, v1, Is, Ir, Iw, Ij, Ip, m, Il) { var IA = m.categoryDim; var Z = m.valueDim; var ID = Il.pxSign; var Iy = Math.max(IB[Z.index] + Iw, 0); var Iu = Iy; if (Ix) { var Iq = Math.abs(Ij); var Io = gu(It.get("symbolMargin"), "15%") + ""; var Im = false; if (Io.lastIndexOf("!") === Io.length - 1) { Im = true; Io = Io.slice(0, Io.length - 1) } Io = zN(Io, IB[Z.index]); var In = Math.max(Iy + Io * 2, 0); var k = Im ? 0 : Io * 2; var i = lC(Ix); var v = i ? Ix : wS((Iq + k) / In); var e = Iq - v * Iy; Io = e / 2 / (Im ? v : v - 1); In = Iy + Io * 2; k = Im ? 0 : Io * 2; if (!i && Ix !== "fixed") { v = Ip ? wS((Math.abs(Ip) + k) / In) : 0 } Iu = v * In - k; Il.repeatTimes = v; Il.symbolMargin = Io } var v2 = ID * (Iu / 2); var IC = Il.pathPosition = []; IC[IA.index] = Iz[IA.wh] / 2; IC[Z.index] = Ir === "start" ? v2 : Ir === "end" ? Ij - v2 : Ij / 2; if (Is) { IC[0] += Is[0]; IC[1] += Is[1] } var Ik = Il.bundlePosition = []; Ik[IA.index] = Iz[IA.xy]; Ik[Z.index] = Iz[Z.xy]; var Iv = Il.barRectShape = b0({}, Iz); Iv[Z.wh] = ID * Math.max(Math.abs(Iz[Z.wh]), Math.abs(IC[Z.index] + v2)); Iv[IA.wh] = Iz[IA.wh]; var v3 = Il.clipShape = {}; v3[IA.xy] = -Iz[IA.xy]; v3[IA.wh] = m.ecSize[IA.wh]; v3[Z.xy] = 0; v3[Z.wh] = Iz[Z.wh] } function uK(e) { var i = e.symbolPatternSize; var k = t9(e.symbolType, -i / 2, -i / 2, i, i, e.color); k.attr({ culling: true }); k.type !== "image" && k.setStyle({ strokeNoScale: true }); return k } function ii(Ik, i, m, Ip) { var Iq = Ik.__pictorialBundle; var v = m.symbolSize; var e = m.valueLineWidth; var v1 = m.pathPosition; var Ij = i.valueDim; var Io = m.repeatTimes || 0; var v2 = 0; var Im = v[i.valueDim.index] + e + m.symbolMargin * 2; lB(Ik, function (Ir) { Ir.__pictorialAnimationIndex = v2; Ir.__pictorialRepeatTimes = Io; if (v2 < Io) { uo(Ir, null, k(v2), m, Ip) } else { uo(Ir, null, { scale: [0, 0] }, m, Ip, function () { Iq.remove(Ir) }) } uY(Ir, m); v2++ }); for (; v2 < Io; v2++) { var In = uK(m); In.__pictorialAnimationIndex = v2; In.__pictorialRepeatTimes = Io; Iq.add(In); var v3 = k(v2); uo(In, { position: v3.position, scale: [0, 0] }, { scale: v3.scale, rotation: v3.rotation }, m, Ip); In.on("mouseover", Z).on("mouseout", Il); uY(In, m) } function k(It) { var Ir = v1.slice(); var Is = m.pxSign; var Iu = It; if (m.symbolRepeatDirection === "start" ? Is > 0 : Is < 0) { Iu = Io - 1 - It } Ir[Ij.index] = Im * (Iu - Io / 2 + 0.5) + v1[Ij.index]; return { position: Ir, scale: m.symbolScale.slice(), rotation: m.rotation } } function Z() { lB(Ik, function (Ir) { Ir.trigger("emphasis") }) } function Il() { lB(Ik, function (Ir) { Ir.trigger("normal") }) } } function gh(v1, v, i, v2) { var k = v1.__pictorialBundle; var m = v1.__pictorialMainPath; if (!m) { m = v1.__pictorialMainPath = uK(i); k.add(m); uo(m, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, v2); m.on("mouseover", Z).on("mouseout", e) } else { uo(m, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, v2) } uY(m, i); function Z() { this.trigger("emphasis") } function e() { this.trigger("normal") } } function xz(k, e, m) { var i = b0({}, e.barRectShape); var v = k.__pictorialBarRect; if (!v) { v = k.__pictorialBarRect = new EH({ z2: 2, shape: i, silent: true, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }); k.add(v) } else { uo(v, null, { shape: i }, e, m) } } function mC(v1, e, k, Ij) { if (k.symbolClip) { var v2 = v1.__pictorialClipPath; var i = b0({}, k.clipShape); var Z = e.valueDim; var m = k.animationModel; var v3 = k.dataIndex; if (v2) { oS(v2, { shape: i }, m, v3) } else { i[Z.wh] = 0; v2 = new EH({ shape: i }); v1.__pictorialBundle.setClipPath(v2); v1.__pictorialClipPath = v2; var v = {}; v[Z.wh] = k.clipShape[Z.wh]; yf[Ij ? "updateProps" : "initProps"](v2, { shape: v }, m, v3) } } } function zn(k, e) { var i = k.getItemModel(e); i.getAnimationDelayParams = gb; i.isAnimationEnabled = al; return i } function gb(e) { return { index: e.__pictorialAnimationIndex, count: e.__pictorialRepeatTimes } } function al() { return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation") } function uY(i, e) { i.off("emphasis").off("normal"); var k = e.symbolScale.slice(); e.hoverAnimation && i.on("emphasis", function () { this.animateTo({ scale: [k[0] * 1.1, k[1] * 1.1] }, 400, "elasticOut") }).on("normal", function () { this.animateTo({ scale: k.slice() }, 400, "elasticOut") }) } function pb(Z, k, e, v) {
    var m = new B8(); var i = new B8(); m.add(i); m.__pictorialBundle = i; i.attr("position", e.bundlePosition.slice()); if (e.symbolRepeat) {
      ii(m, k, e)
    } else { gh(m, k, e) } xz(m, e, v); mC(m, k, e, v); m.__pictorialShapeStr = cr(Z, e); m.__pictorialSymbolMeta = e; return m
  } function c0(Z, v, e) { var m = e.animationModel; var k = e.dataIndex; var i = Z.__pictorialBundle; oS(i, { position: e.bundlePosition.slice() }, m, k); if (e.symbolRepeat) { ii(Z, v, e, true) } else { gh(Z, v, e, true) } xz(Z, e, true); mC(Z, v, e, true) } function wv(Z, m, k, v) { var i = v.__pictorialBarRect; i && (i.style.text = null); var e = []; lB(v, function (v1) { e.push(v1) }); v.__pictorialMainPath && e.push(v.__pictorialMainPath); v.__pictorialClipPath && (k = null); o9(e, function (v1) { oS(v1, { scale: [0, 0] }, k, m, function () { v.parent && v.parent.remove(v) }) }); Z.setItemGraphicEl(m, null) } function cr(i, e) { return [i.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":") } function lB(k, e, i) { o9(k.__pictorialBundle.children(), function (m) { m !== k.__pictorialBarRect && e.call(i, m) }) } function uo(m, Z, k, i, v, e) { Z && m.attr(Z); if (i.symbolClip && !v) { k && m.attr(k) } else { k && yf[v ? "updateProps" : "initProps"](m, k, i.animationModel, i.dataIndex, e) } } function iW(v1, i, k) { var Z = k.color; var v3 = k.dataIndex; var Ik = k.itemModel; var e = Ik.getModel("itemStyle").getItemStyle(["color"]); var m = Ik.getModel("emphasis.itemStyle").getItemStyle(); var Ij = Ik.getShallow("cursor"); lB(v1, function (Im) { Im.setColor(Z); Im.setStyle(De({ fill: Z, opacity: k.opacity }, e)); yn(Im, m); Ij && (Im.cursor = Ij); Im.z2 = k.z2 }); var v = {}; var v2 = i.valueDim.posDesc[+(k.boundingLength > 0)]; var Il = v1.__pictorialBarRect; EL(Il.style, v, Ik, Z, i.seriesModel, v3, v2); yn(Il, v) } function wS(i) { var e = Math.round(i); return Math.abs(i - e) < 0.0001 ? e : Math.ceil(i) } pr(sv(bA, "pictorialBar")); G(ml("pictorialBar", "roundRect")); var rJ = function (m, v, k, i, e) { BS.call(this, m, v, k); this.type = i || "value"; this.position = e || "bottom"; this.orient = null }; rJ.prototype = { constructor: rJ, model: null, isHorizontal: function () { var e = this.position; return e === "top" || e === "bottom" }, pointToData: function (e, i) { return this.coordinateSystem.pointToData(e, i)[0] }, toGlobalCoord: null, toLocalCoord: null }; mr(rJ, BS); function b6(i, e, k) { this.dimension = "single"; this.dimensions = ["single"]; this._axis = null; this._rect; this._init(i, e, k); this.model = i } b6.prototype = { type: "singleAxis", axisPointerEnabled: true, constructor: b6, _init: function (k, e, v) { var Z = this.dimension; var m = new rJ(Z, nq(k), [0, 0], k.get("type"), k.get("position")); var i = m.type === "category"; m.onBand = i && k.get("boundaryGap"); m.inverse = k.get("inverse"); m.orient = k.get("orient"); k.axis = m; m.model = k; m.coordinateSystem = this; this._axis = m }, update: function (e, i) { e.eachSeries(function (k) { if (k.coordinateSystem === this) { var m = k.getData(); o9(m.mapDimension(this.dimension, true), function (v) { this._axis.scale.unionExtentFromData(m, v) }, this); nL(this._axis.scale, this._axis.model) } }, this) }, resize: function (e, i) { this._rect = kV({ left: e.get("left"), top: e.get("top"), right: e.get("right"), bottom: e.get("bottom"), width: e.get("width"), height: e.get("height") }, { width: i.getWidth(), height: i.getHeight() }); this._adjustAxis() }, getRect: function () { return this._rect }, _adjustAxis: function () { var m = this._rect; var k = this._axis; var v = k.isHorizontal(); var i = v ? [0, m.width] : [0, m.height]; var e = k.reverse ? 1 : 0; k.setExtent(i[e], i[1 - e]); this._updateAxisTransform(k, v ? m.x : m.y) }, _updateAxisTransform: function (i, e) { var v = i.getExtent(); var m = v[0] + v[1]; var k = i.isHorizontal(); i.toGlobalCoord = k ? function (Z) { return Z + e } : function (Z) { return m - Z + e }; i.toLocalCoord = k ? function (Z) { return Z - e } : function (Z) { return m - Z + e } }, getAxis: function () { return this._axis }, getBaseAxis: function () { return this._axis }, getAxes: function () { return [this._axis] }, getTooltipAxes: function () { return { baseAxes: [this.getAxis()] } }, containPoint: function (e) { var m = this.getRect(); var k = this.getAxis(); var i = k.orient; if (i === "horizontal") { return k.contain(k.toLocalCoord(e[0])) && (e[1] >= m.y && e[1] <= (m.y + m.height)) } else { return k.contain(k.toLocalCoord(e[1])) && (e[0] >= m.y && e[0] <= (m.y + m.height)) } }, pointToData: function (e) { var i = this.getAxis(); return [i.coordToData(i.toLocalCoord(e[i.orient === "horizontal" ? 0 : 1]))] }, dataToPoint: function (v) { var i = this.getAxis(); var k = this.getRect(); var m = []; var e = i.orient === "horizontal" ? 0 : 1; if (v instanceof Array) { v = v[0] } m[e] = i.toGlobalCoord(i.dataToCoord(+v)); m[1 - e] = e === 0 ? (k.y + k.height / 2) : (k.x + k.width / 2); return m } }; function Cx(e, i) { var k = []; e.eachComponent("singleAxis", function (v, m) { var Z = new b6(v, e, i); Z.name = "single_" + m; Z.resize(v, i); v.coordinateSystem = Z; k.push(Z) }); e.eachSeries(function (m) { if (m.get("coordinateSystem") === "singleAxis") { var v = e.queryComponents({ mainType: "singleAxis", index: m.get("singleAxisIndex"), id: m.get("singleAxisId") })[0]; m.coordinateSystem = v && v.coordinateSystem } }); return k } fz.register("single", { create: Cx, dimensions: b6.prototype.dimensions }); function eg(Ik, i) {
    i = i || {}; var Ij = Ik.coordinateSystem; var k = Ik.axis; var v = {}; var Z = k.position; var m = k.orient; var v3 = Ij.getRect(); var v1 = [v3.x, v3.x + v3.width, v3.y, v3.y + v3.height]; var Im = { horizontal: { top: v1[2], bottom: v1[3] }, vertical: { left: v1[0], right: v1[1] } }; v.position = [m === "vertical" ? Im.vertical[Z] : v1[0], m === "horizontal" ? Im.horizontal[Z] : v1[3]]; var e = { horizontal: 0, vertical: 1 }; v.rotation = Math.PI / 2 * e[m];
    var v2 = { top: -1, bottom: 1, right: 1, left: -1 }; v.labelDirection = v.tickDirection = v.nameDirection = v2[Z]; if (Ik.get("axisTick.inside")) { v.tickDirection = -v.tickDirection } if (gu(i.labelInside, Ik.get("axisLabel.inside"))) { v.labelDirection = -v.labelDirection } var Il = i.rotate; Il == null && (Il = Ik.get("axisLabel.rotate")); v.labelRotation = Z === "top" ? -Il : Il; v.z2 = 1; return v
  } var ER = ["axisLine", "axisTickLabel", "axisName"]; var uE = "splitLine"; var EJ = f2.extend({ type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function (i, e, k, v1) { var Z = this.group; Z.removeAll(); var m = eg(i); var v = new da(i, m); o9(ER, v.add, v); Z.add(v.getGroup()); if (i.get(uE + ".show")) { this["_" + uE](i) } EJ.superCall(this, "render", i, e, k, v1) }, _splitLine: function (In) { var v = In.axis; if (v.scale.isBlank()) { return } var m = In.getModel("splitLine"); var Ij = m.getModel("lineStyle"); var v1 = Ij.get("width"); var Iq = Ij.get("color"); Iq = Iq instanceof Array ? Iq : [Iq]; var e = In.coordinateSystem.getRect(); var Ik = v.isHorizontal(); var v2 = []; var Ip = 0; var v3 = v.getTicksCoords({ tickModel: m }); var Io = []; var Im = []; for (var Z = 0; Z < v3.length; ++Z) { var k = v.toGlobalCoord(v3[Z].coord); if (Ik) { Io[0] = k; Io[1] = e.y; Im[0] = k; Im[1] = e.y + e.height } else { Io[0] = e.x; Io[1] = k; Im[0] = e.x + e.width; Im[1] = k } var Il = (Ip++) % Iq.length; v2[Il] = v2[Il] || []; v2[Il].push(new zB(dn({ shape: { x1: Io[0], y1: Io[1], x2: Im[0], y2: Im[1] }, style: { lineWidth: v1 }, silent: true }))) } for (var Z = 0; Z < v2.length; ++Z) { this.group.add(q8(v2[Z], { style: { stroke: Iq[Z % Iq.length], lineDash: Ij.getLineDash(v1), lineWidth: v1 }, silent: true })) } } }); var mk = aH.extend({ type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel: function () { return this } }); var qh = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: true, lineStyle: { width: 2, type: "solid" } }, tooltip: { show: true }, axisTick: { show: true, length: 6, lineStyle: { width: 2 } }, axisLabel: { show: true, interval: "auto" }, splitLine: { show: true, lineStyle: { type: "dashed", opacity: 0.2 } } }; function sb(i, e) { return e.type || (e.data ? "category" : "value") } v4(mk.prototype, nB); mR("single", mk, sb, qh); var ui = function (e, v1) { var Ij = []; var v = e.seriesIndex; var k; if (v == null || !(k = v1.getSeriesByIndex(v))) { return { point: [] } } var Z = k.getData(); var v3 = xe(Z, e); if (v3 == null || v3 < 0 || GG(v3)) { return { point: [] } } var i = Z.getItemGraphicEl(v3); var m = k.coordinateSystem; if (k.getTooltipPosition) { Ij = k.getTooltipPosition(v3) || [] } else { if (m && m.dataToPoint) { Ij = m.dataToPoint(Z.getValues(Ef(m.dimensions, function (Ik) { return Z.mapDimension(Ik) }), v3, true)) || [] } else { if (i) { var v2 = i.getBoundingRect().clone(); v2.applyTransform(i.transform); Ij = [v2.x + v2.width / 2, v2.y + v2.height / 2] } } } return { point: Ij, el: i } }; var tU = o9; var uj = sv; var hH = fK(); var tt = function (Ik, v1, v2) { var Io = Ik.currTrigger; var Il = [Ik.x, Ik.y]; var i = Ik; var v = Ik.dispatchAction || km(v2.dispatchAction, v2); var m = v1.getComponent("axisPointer").coordSysAxesInfo; if (!m) { return } if (wQ(Il)) { Il = ui({ seriesIndex: i.seriesIndex, dataIndex: i.dataIndex }, v1).point } var Ij = wQ(Il); var v3 = i.axesInfo; var k = m.axesInfo; var Iq = Io === "leave" || wQ(Il); var Im = {}; var Z = {}; var In = { list: [], map: {} }; var Ip = { showPointer: uj(v5, Z), showTooltip: uj(gz, In) }; tU(m.coordSysMap, function (Is, Ir) { var It = Ij || Is.containPoint(Il); tU(m.coordSysAxesInfo[Ir], function (Iv, Iw) { var Ix = Iv.axis; var Iu = CO(v3, Iv); if (!Iq && It && (!v3 || Iu)) { var Iy = Iu && Iu.value; if (Iy == null && !Ij) { Iy = Ix.pointToData(Il) } Iy != null && vn(Iv, Iy, Ip, false, Im) } }) }); var e = {}; tU(k, function (Is, Ir) { var It = Is.linkGroup; if (It && !Z[Ir]) { tU(It.axesInfo, function (Iu, Ix) { var Iv = Z[Ix]; if (Iu !== Is && Iv) { var Iw = Iv.value; It.mapper && (Iw = Is.axis.scale.parse(It.mapper(Iw, xA(Iu), xA(Is)))); e[Is.key] = Iw } }) } }); tU(e, function (Is, Ir) { vn(k[Ir], Is, Ip, true, Im) }); A7(Z, k, Im); er(In, Il, Ik, v); DW(k, v, v2); return Im }; function vn(v, e, v3, Z, v1) { var k = v.axis; if (k.scale.isBlank() || !k.containData(e)) { return } if (!v.involveSeries) { v3.showPointer(v, e); return } var m = zJ(e, v); var v2 = m.payloadBatch; var i = m.snapToValue; if (v2[0] && v1.seriesIndex == null) { b0(v1, v2[0]) } if (!Z && v.snap) { if (k.containData(i) && i != null) { e = i } } v3.showPointer(v, e, v2, v1); v3.showTooltip(v, m, i) } function zJ(v1, m) { var v = m.axis; var v2 = v.dim; var e = v1; var Z = []; var k = Number.MAX_VALUE; var i = -1; tU(m.seriesModels, function (Il, Ij) { var Ik = Il.getData().mapDimension(v2, true); var In; var Im; if (Il.getAxisTooltipData) { var v3 = Il.getAxisTooltipData(Ik, v1, v); Im = v3.dataIndices; In = v3.nestestValue } else { Im = Il.getData().indicesOfNearest(Ik[0], v1, v.type === "category" ? 0.5 : null); if (!Im.length) { return } In = Il.getData().get(Ik[0], Im[0]) } if (In == null || !isFinite(In)) { return } var Io = v1 - In; var Ip = Math.abs(Io); if (Ip <= k) { if (Ip < k || (Io >= 0 && i < 0)) { k = Ip; i = Io; e = In; Z.length = 0 } tU(Im, function (Iq) { Z.push({ seriesIndex: Il.seriesIndex, dataIndexInside: Iq, dataIndex: Il.getData().getRawIndex(Iq) }) }) } }); return { payloadBatch: Z, snapToValue: e } } function v5(i, e, m, k) { i[e.key] = { value: m, payloadBatch: k } } function gz(Ik, Z, m, v2) {
    var v3 = m.payloadBatch; var i = Z.axis; var Ij = i.model; var v1 = Z.axisPointerModel; if (!Z.triggerTooltip || !v3.length) { return } var v = Z.coordSys.model; var k = GD(v); var e = Ik.map[k]; if (!e) {
      e = Ik.map[k] = { coordSysId: v.id, coordSysIndex: v.componentIndex, coordSysType: v.type, coordSysMainType: v.mainType, dataByAxis: [] };
      Ik.list.push(e)
    } e.dataByAxis.push({ axisDim: i.dim, axisIndex: Ij.componentIndex, axisType: Ij.type, axisId: Ij.id, value: v2, valueLabelOpt: { precision: v1.get("label.precision"), formatter: v1.get("label.formatter") }, seriesDataIndices: v3.slice() })
  } function A7(e, k, m) { var i = m.axesInfo = []; tU(k, function (v, Z) { var v1 = v.axisPointerModel.option; var v2 = e[Z]; if (v2) { !v.useHandle && (v1.status = "show"); v1.value = v2.value; v1.seriesDataIndices = (v2.payloadBatch || []).slice() } else { !v.useHandle && (v1.status = "hide") } v1.status === "show" && i.push({ axisDim: v.axis.dim, axisIndex: v.axis.model.componentIndex, value: v1.value }) }) } function er(k, e, v, m) { if (wQ(e) || !k.list.length) { m({ type: "hideTip" }); return } var i = ((k.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}; m({ type: "showTip", escapeConnect: true, x: e[0], y: e[1], tooltipOption: v.tooltipOption, position: v.position, dataIndexInside: i.dataIndexInside, dataIndex: i.dataIndex, seriesIndex: i.seriesIndex, dataByCoordSys: k.list }) } function DW(e, k, v) { var Z = v.getZr(); var m = "axisPointerLastHighlights"; var v1 = hH(Z)[m] || {}; var i = hH(Z)[m] = {}; tU(e, function (Ij, Ik) { var Il = Ij.axisPointerModel.option; Il.status === "show" && tU(Il.seriesDataIndices, function (In) { var Im = In.seriesIndex + " | " + In.dataIndex; i[Im] = In }) }); var v2 = []; var v3 = []; o9(v1, function (Ik, Ij) { !i[Ij] && v3.push(Ik) }); o9(i, function (Ik, Ij) { !v1[Ij] && v2.push(Ik) }); v3.length && v.dispatchAction({ type: "downplay", escapeConnect: true, batch: v3 }); v2.length && v.dispatchAction({ type: "highlight", escapeConnect: true, batch: v2 }) } function CO(v, k) { for (var m = 0; m < (v || []).length; m++) { var e = v[m]; if (k.axis.dim === e.axisDim && k.axis.model.componentIndex === e.axisIndex) { return e } } } function xA(e) { var i = e.axis.model; var k = {}; var m = k.axisDim = e.axis.dim; k.axisIndex = k[m + "AxisIndex"] = i.componentIndex; k.axisName = k[m + "AxisName"] = i.name; k.axisId = k[m + "AxisId"] = i.id; return k } function wQ(e) { return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]) } var a7 = p2({ type: "axisPointer", coordSysAxesInfo: null, defaultOption: { show: "auto", triggerOn: null, zlevel: 0, z: 50, type: "line", snap: false, triggerTooltip: true, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#aaa", width: 1, type: "solid" }, shadowStyle: { color: "rgba(150,150,150,0.3)" }, label: { show: true, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa" }, handle: { show: false, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } }); var eK = fK(); var tT = o9; function vW(i, m, k) { if (sW.node) { return } var v = m.getZr(); eK(v).records || (eK(v).records = {}); FC(v, m); var e = eK(v).records[i] || (eK(v).records[i] = {}); e.handler = k } function FC(k, i) { if (eK(k).initialized) { return } eK(k).initialized = true; e("click", sv(kW, "click")); e("mousemove", sv(kW, "mousemove")); e("globalout", d5); function e(v, m) { k.on(v, function (v1) { var Z = dR(i); tT(eK(k).records, function (v2) { v2 && m(v2, v1, Z.dispatchAction) }); sw(Z.pendings, i) }) } } function sw(k, i) { var v = k.showTip.length; var e = k.hideTip.length; var m; if (v) { m = k.showTip[v - 1] } else { if (e) { m = k.hideTip[e - 1] } } if (m) { m.dispatchAction = null; i.dispatchAction(m) } } function d5(i, m, k) { i.handler("leave", null, k) } function kW(v, i, m, k) { i.handler(v, m, k) } function dR(i) { var e = { showTip: [], hideTip: [] }; var k = function (m) { var v = e[m.type]; if (v) { v.push(m) } else { m.dispatchAction = k; i.dispatchAction(m) } }; return { dispatchAction: k, pendings: e } } function ae(i, k) { if (sW.node) { return } var m = k.getZr(); var e = (eK(m).records || {})[i]; if (e) { eK(m).records[i] = null } } var za = qy({ type: "axisPointer", render: function (v, e, m) { var k = e.getComponent("tooltip"); var i = v.get("triggerOn") || (k && k.get("triggerOn") || "mousemove|click"); vW("axisPointer", m, function (v2, v1, Z) { if (i !== "none" && (v2 === "leave" || i.indexOf(v2) >= 0)) { Z({ type: "updateAxisPointer", currTrigger: v2, x: v1 && v1.offsetX, y: v1 && v1.offsetY }) } }) }, remove: function (e, i) { ae(i.getZr(), "axisPointer"); za.superApply(this._model, "remove", arguments) }, dispose: function (e, i) { ae("axisPointer", i); za.superApply(this._model, "dispose", arguments) } }); var eJ = fK(); var uN = C5; var pA = km; function Gp() { } Gp.prototype = {
    _group: null, _lastGraphicKey: null, _handle: null, _dragging: false, _lastValue: null, _lastStatus: null, _payloadInfo: null, animationThreshold: 15, render: function (Ik, v2, Z, k) {
      var v3 = v2.get("value"); var i = v2.get("status"); this._axisModel = Ik; this._axisPointerModel = v2; this._api = Z; if (!k && this._lastValue === v3 && this._lastStatus === i) { return } this._lastValue = v3; this._lastStatus = i; var Ij = this._group; var v = this._handle; if (!i || i === "hide") { Ij && Ij.hide(); v && v.hide(); return } Ij && Ij.show(); v && v.show(); var e = {}; this.makeElOption(e, v3, Ik, v2, Z); var Il = e.graphicKey; if (Il !== this._lastGraphicKey) { this.clear(Z) } this._lastGraphicKey = Il; var v1 = this._moveAnimation = this.determineAnimation(Ik, v2); if (!Ij) {
        Ij = this._group = new B8(); this.createPointerEl(Ij, e, Ik, v2); this.createLabelEl(Ij, e, Ik, v2);
        Z.getZr().add(Ij)
      } else { var m = sv(jg, v2, v1); this.updatePointerEl(Ij, e, m, v2); this.updateLabelEl(Ij, e, m, v2) } l6(Ij, v2, true); this._renderHandle(v3)
    }, remove: function (e) { this.clear(e) }, dispose: function (e) { this.clear(e) }, determineAnimation: function (v2, v1) { var m = v1.get("animation"); var i = v2.axis; var Z = i.type === "category"; var v = v1.get("snap"); if (!v && !Z) { return false } if (m === "auto" || m == null) { var v3 = this.animationThreshold; if (Z && i.getBandWidth() > v3) { return true } if (v) { var e = Du(v2).seriesDataCount; var k = i.getExtent(); return Math.abs(k[0] - k[1]) / e > v3 } return false } return m === true }, makeElOption: function (k, v, e, m, i) { }, createPointerEl: function (v, k, i, m) { var Z = k.pointer; if (Z) { var e = eJ(v).pointerEl = new yf[Z.type](uN(k.pointer)); v.add(e) } }, createLabelEl: function (v, k, i, m) { if (k.label) { var e = eJ(v).labelEl = new EH(uN(k.label)); v.add(e); rP(e, m) } }, updatePointerEl: function (k, i, m) { var e = eJ(k).pointerEl; if (e) { e.setStyle(i.pointer.style); m(e, { shape: i.pointer.shape }) } }, updateLabelEl: function (m, i, v, k) { var e = eJ(m).labelEl; if (e) { e.setStyle(i.label.style); v(e, { shape: i.label.shape, position: i.label.position }); rP(e, k) } }, _renderHandle: function (v2) { if (this._dragging || !this.updateHandleTransform) { return } var Z = this._axisPointerModel; var v = this._api.getZr(); var m = this._handle; var e = Z.getModel("handle"); var i = Z.get("status"); if (!e.get("show") || !i || i === "hide") { m && v.remove(m); this._handle = null; return } var k; if (!this._handle) { k = true; m = this._handle = Gb(e.get("icon"), { cursor: "move", draggable: true, onmousemove: function (Ij) { GP(Ij.event) }, onmousedown: pA(this._onHandleDragMove, this, 0, 0), drift: pA(this._onHandleDragMove, this), ondragend: pA(this._onHandleDragEnd, this) }); v.add(m) } l6(m, Z, false); var v3 = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]; m.setStyle(e.getItemStyle(null, v3)); var v1 = e.get("size"); if (!GG(v1)) { v1 = [v1, v1] } m.attr("scale", [v1[0] / 2, v1[1] / 2]); mK(this, "_doDispatchAxisPointer", e.get("throttle") || 0, "fixRate"); this._moveHandleToValue(v2, k) }, _moveHandleToValue: function (e, i) { jg(this._axisPointerModel, !i && this._moveAnimation, this._handle, lr(this.getHandleTransform(e, this._axisModel, this._axisPointerModel))) }, _onHandleDragMove: function (i, e) { var m = this._handle; if (!m) { return } this._dragging = true; var k = this.updateHandleTransform(lr(m), [i, e], this._axisModel, this._axisPointerModel); this._payloadInfo = k; m.stopAnimation(); m.attr(lr(k)); eJ(m).lastProp = null; this._doDispatchAxisPointer() }, _doDispatchAxisPointer: function () { var i = this._handle; if (!i) { return } var k = this._payloadInfo; var e = this._axisModel; this._api.dispatchAction({ type: "updateAxisPointer", x: k.cursorPoint[0], y: k.cursorPoint[1], tooltipOption: k.tooltipOption, axesInfo: [{ axisDim: e.axis.dim, axisIndex: e.componentIndex }] }) }, _onHandleDragEnd: function (e) { this._dragging = false; var k = this._handle; if (!k) { return } var i = this._axisPointerModel.get("value"); this._moveHandleToValue(i); this._api.dispatchAction({ type: "hideTip" }) }, getHandleTransform: null, updateHandleTransform: null, clear: function (e) { this._lastValue = null; this._lastStatus = null; var m = e.getZr(); var k = this._group; var i = this._handle; if (m && k) { this._lastGraphicKey = null; k && m.remove(k); i && m.remove(i); this._group = null; this._handle = null; this._payloadInfo = null } }, doClear: function () { }, buildLabel: function (k, e, i) { i = i || 0; return { x: k[i], y: k[1 - i], width: e[i], height: e[1 - i] } }
  }; Gp.prototype.constructor = Gp; function jg(i, e, m, k) { if (!qq(eJ(m).lastProp, k)) { eJ(m).lastProp = k; e ? oS(m, k, i) : (m.stopAnimation(), m.attr(k)) } } function qq(e, k) { if (tJ(e) && tJ(k)) { var i = true; o9(k, function (v, m) { i = i && qq(e[m], v) }); return !!i } else { return e === k } } function rP(e, i) { e[i.get("label.show") ? "show" : "hide"]() } function lr(e) { return { position: e.position.slice(), rotation: e.rotation || 0 } } function l6(m, k, i) { var v = k.get("z"); var e = k.get("zlevel"); m && m.traverse(function (Z) { if (Z.type !== "group") { v != null && (Z.z = v); e != null && (Z.zlevel = e); Z.silent = i } }) } AG(Gp); function y4(i) { var k = i.get("type"); var m = i.getModel(k + "Style"); var e; if (k === "line") { e = m.getLineStyle(); e.fill = null } else { if (k === "shadow") { e = m.getAreaStyle(); e.stroke = null } } return e } function Fr(e, In, Ij, v2, v) {
    var Im = Ij.get("value"); var Ip = sG(Im, In.axis, In.ecModel, Ij.get("seriesDataIndices"), { precision: Ij.get("label.precision"), formatter: Ij.get("label.formatter") }); var Iq = Ij.getModel("label"); var m = Bj(Iq.get("padding") || 0); var k = Iq.getFont(); var Il = Gr(Ip, k); var v1 = v.position; var i = Il.width + m[1] + m[3]; var Io = Il.height + m[0] + m[2]; var v3 = v.align; v3 === "right" && (v1[0] -= i); v3 === "center" && (v1[0] -= i / 2); var Z = v.verticalAlign; Z === "bottom" && (v1[1] -= Io); Z === "middle" && (v1[1] -= Io / 2); ds(v1, i, Io, v2); var Ik = Iq.get("backgroundColor"); if (!Ik || Ik === "auto") { Ik = In.get("axisLine.lineStyle.color") } e.label = { shape: { x: 0, y: 0, width: i, height: Io, r: Iq.get("borderRadius") }, position: v1.slice(), style: { text: Ip, textFont: k, textFill: Iq.getTextColor(), textPosition: "inside", fill: Ik, stroke: Iq.get("borderColor") || "transparent", lineWidth: Iq.get("borderWidth") || 0, shadowBlur: Iq.get("shadowBlur"), shadowColor: Iq.get("shadowColor"), shadowOffsetX: Iq.get("shadowOffsetX"), shadowOffsetY: Iq.get("shadowOffsetY") }, z2: 10 }
  } function ds(i, Z, e, v) { var m = v.getWidth(); var k = v.getHeight(); i[0] = Math.min(i[0] + Z, m) - Z; i[1] = Math.min(i[1] + e, k) - e; i[0] = Math.max(i[0], 0); i[1] = Math.max(i[1], 0) } function sG(Z, v, e, i, m) { Z = v.scale.parse(Z); var v2 = v.scale.getLabel(Z, { precision: m.precision }); var k = m.formatter; if (k) { var v1 = { value: nV(v, Z), seriesData: [] }; o9(i, function (Il) { var Ik = e.getSeriesByIndex(Il.seriesIndex); var Ij = Il.dataIndexInside; var v3 = Ik && Ik.getDataParams(Ij); v3 && v1.seriesData.push(v3) }); if (wb(k)) { v2 = k.replace("{value}", v2) } else { if (E5(k)) { v2 = k(v1) } } } return v2 } function ve(i, k, m) { var e = CB(); ki(e, e, m.rotation); vm(e, e, m.position); return v7([i.dataToCoord(k), (m.labelOffset || 0) + (m.labelDirection || 1) * (m.labelMargin || 0)], e) } function qw(Z, m, v1, i, v, k) { var e = da.innerTextLayout(v1.rotation, 0, v1.labelDirection); v1.labelMargin = v.get("label.margin"); Fr(m, i, v, k, { position: ve(i.axis, Z, v1), align: e.textAlign, verticalAlign: e.textVerticalAlign }) } function GE(k, i, e) { e = e || 0; return { x1: k[e], y1: k[1 - e], x2: i[e], y2: i[1 - e] } } function fx(k, e, i) { i = i || 0; return { x: k[i], y: k[1 - i], width: e[i], height: e[1 - i] } } function kn(e, Z, k, v, m, i) { return { cx: e, cy: Z, r0: k, r: v, startAngle: m, endAngle: i, clockwise: true } } var kN = Gp.extend({ makeElOption: function (e, Ij, Il, v2, v1) { var k = Il.axis; var i = k.grid; var v3 = v2.get("type"); var Z = cD(i, k).getOtherAxis(k).getGlobalExtent(); var v = k.toGlobalCoord(k.dataToCoord(Ij, true)); if (v3 && v3 !== "none") { var Ik = y4(v2); var Im = cX[v3](k, v, Z, Ik); Im.style = Ik; e.graphicKey = Im.type; e.pointer = Im } var m = ei(i.model, Il); qw(Ij, e, m, Il, v2, v1) }, getHandleTransform: function (k, e, i) { var m = ei(e.axis.grid.model, e, { labelInside: false }); m.labelMargin = i.get("handle.margin"); return { position: ve(e.axis, k, m), rotation: m.rotation + (m.labelDirection < 0 ? Math.PI : 0) } }, updateHandleTransform: function (i, Ik, Il, Ij) { var m = Il.axis; var e = m.grid; var v = m.getGlobalExtent(true); var v2 = cD(e, m).getOtherAxis(m).getGlobalExtent(); var Im = m.dim === "x" ? 0 : 1; var Z = i.position; Z[Im] += Ik[Im]; Z[Im] = Math.min(v[1], Z[Im]); Z[Im] = Math.max(v[0], Z[Im]); var v1 = (v2[1] + v2[0]) / 2; var v3 = [v1, v1]; v3[Im] = Z[Im]; var k = [{ verticalAlign: "middle" }, { align: "center" }]; return { position: Z, rotation: i.rotation, cursorPoint: v3, tooltipOption: k[Im] } } }); function cD(i, k) { var e = {}; e[k.dim + "AxisIndex"] = k.index; return i.getCartesian(e) } var cX = { line: function (m, i, v, k) { var e = GE([i, v[0]], [i, v[1]], di(m)); dn({ shape: e, style: k }); return { type: "Line", shape: e } }, shadow: function (v, i, Z, k) { var e = Math.max(1, v.getBandWidth()); var m = Z[1] - Z[0]; return { type: "Rect", shape: fx([i - e / 2, Z[0]], [e, m], di(v)) } } }; function di(e) { return e.dim === "x" ? 0 : 1 } f2.registerAxisPointerClass("CartesianAxisPointer", kN); y2(function (e) { if (e) { (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {}); var i = e.axisPointer.link; if (i && !GG(i)) { e.axisPointer.link = [i] } } }); eb(B6.PROCESSOR.STATISTIC, function (e, i) { e.getComponent("axisPointer").coordSysAxesInfo = ij(e, i) }); b1({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, tt); var b3 = ["x", "y"]; var cE = ["width", "height"]; var jo = Gp.extend({ makeElOption: function (e, Ij, Il, v2, v1) { var i = Il.axis; var v = i.coordinateSystem; var Z = xq(v, 1 - yP(i)); var m = v.dataToPoint(Ij)[0]; var v3 = v2.get("type"); if (v3 && v3 !== "none") { var Ik = y4(v2); var Im = rV[v3](i, m, Z, Ik); Im.style = Ik; e.graphicKey = Im.type; e.pointer = Im } var k = eg(Il); qw(Ij, e, k, Il, v2, v1) }, getHandleTransform: function (k, e, i) { var m = eg(e, { labelInside: false }); m.labelMargin = i.get("handle.margin"); return { position: ve(e.axis, k, m), rotation: m.rotation + (m.labelDirection < 0 ? Math.PI : 0) } }, updateHandleTransform: function (e, Ij, Ik, v3) { var i = Ik.axis; var m = i.coordinateSystem; var Il = yP(i); var k = xq(m, Il); var v = e.position; v[Il] += Ij[Il]; v[Il] = Math.min(k[1], v[Il]); v[Il] = Math.max(k[0], v[Il]); var v1 = xq(m, 1 - Il); var Z = (v1[1] + v1[0]) / 2; var v2 = [Z, Z]; v2[Il] = v[Il]; return { position: v, rotation: e.rotation, cursorPoint: v2, tooltipOption: { verticalAlign: "middle" } } } }); var rV = { line: function (m, i, v, k) { var e = GE([i, v[0]], [i, v[1]], yP(m)); dn({ shape: e, style: k }); return { type: "Line", shape: e } }, shadow: function (v, i, Z, k) { var e = v.getBandWidth(); var m = Z[1] - Z[0]; return { type: "Rect", shape: fx([i - e / 2, Z[0]], [e, m], yP(v)) } } }; function yP(e) { return e.isHorizontal() ? 0 : 1 } function xq(e, k) { var i = e.getRect(); return [i[b3[k]], i[b3[k]] + i[cE[k]]] } f2.registerAxisPointerClass("SingleAxisPointer", jo); qy({ type: "single" }); var ac = 2; var d2 = nU.extend({
    type: "series.themeRiver", dependencies: ["singleAxis"], nameMap: null, init: function (e) { d2.superApply(this, "init", arguments); this.legendDataProvider = function () { return this.getRawData() } }, fixData: function (Il) { var v2 = Il.length; var Is = db().key(function (i) { return i[2] }).entries(Il); var In = Ef(Is, function (i) { return { name: i.key, dataList: i.values } }); var Ik = In.length; var Ir = -1; var Ip = -1; for (var Im = 0; Im < Ik; ++Im) { var Io = In[Im].dataList.length; if (Io > Ir) { Ir = Io; Ip = Im } } for (var v3 = 0; v3 < Ik; ++v3) { if (v3 === Ip) { continue } var e = In[v3].name; for (var Ij = 0; Ij < Ir; ++Ij) { var Z = In[Ip].dataList[Ij][0]; var v = In[v3].dataList.length; var m = -1; for (var v1 = 0; v1 < v; ++v1) { var Iq = In[v3].dataList[v1][0]; if (Iq === Z) { m = v1; break } } if (m === -1) { Il[v2] = []; Il[v2][0] = Z; Il[v2][1] = 0; Il[v2][2] = e; v2++ } } } return Il }, getInitialData: function (v1, v2) {
      var e = v2.queryComponents({ mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId") })[0];
      var Im = e.get("type"); var Il = q4(v1.data, function (i) { return i[2] !== undefined }); var Z = this.fixData(Il || []); var m = []; var Ik = this.nameMap = CJ(); var v3 = 0; for (var v = 0; v < Z.length; ++v) { m.push(Z[v][ac]); if (!Ik.get(Z[v][ac])) { Ik.set(Z[v][ac], v3); v3++ } } var k = yw(Z, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: qI(Im) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }); var Ij = new xt(k, this); Ij.initData(Z); return Ij
    }, getLayerSeries: function () { var Z = this.getData(); var m = Z.count(); var e = []; for (var v1 = 0; v1 < m; ++v1) { e[v1] = v1 } var Ij = db().key(function (i) { return Z.get("name", i) }).entries(e); var k = Ef(Ij, function (i) { return { name: i.key, indices: i.values } }); var v3 = Z.mapDimension("single"); for (var v = 0; v < k.length; ++v) { k[v].indices.sort(v2) } function v2(Ik, i) { return Z.get(v3, Ik) - Z.get(v3, i) } return k }, getAxisTooltipData: function (Ij, Im, m) { if (!GG(Ij)) { Ij = Ij ? [Ij] : [] } var v3 = this.getData(); var v = this.getLayerSeries(); var In = []; var v1 = v.length; var Io; for (var v2 = 0; v2 < v1; ++v2) { var Il = Number.MAX_VALUE; var Ip = -1; var e = v[v2].indices.length; for (var Z = 0; Z < e; ++Z) { var k = v3.get(Ij[0], v[v2].indices[Z]); var Ik = Math.abs(k - Im); if (Ik <= Il) { Io = k; Il = Ik; Ip = v[v2].indices[Z] } } In.push(Ip) } return { dataIndices: In, nestestValue: Io } }, formatTooltip: function (k) { var m = this.getData(); var i = m.getName(k); var e = m.get(m.mapDimension("value"), k); if (isNaN(e) || e == null) { e = "-" } return mv(i + " : " + e) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { margin: 4, show: true, position: "left", color: "#000", fontSize: 11 }, emphasis: { label: { show: true } } }
  }); BL({ type: "themeRiver", init: function () { this._layers = [] }, render: function (v, Ij, Ik) { var v2 = v.getData(); var Im = this.group; var v1 = v.getLayerSeries(); var m = v2.getLayout("layoutInfo"); var Il = m.rect; var k = m.boundaryGap; Im.attr("position", [0, Il.y + k[0]]); function v3(In) { return In.name } var e = new Gx(this._layersSeries || [], v1, v3, v3); var Z = {}; e.add(km(i, this, "add")).update(km(i, this, "update")).remove(km(i, this, "remove")).execute(); function i(IB, IA, Io) { var IE = this._layers; if (IB === "remove") { Im.remove(IE[IA]); return } var II = []; var IG = []; var IC; var Ir = v1[IA].indices; for (var IF = 0; IF < Ir.length; IF++) { var IH = v2.getItemLayout(Ir[IF]); var Iw = IH.x; var Iq = IH.y0; var Iv = IH.y; II.push([Iw, Iq]); IG.push([Iw, Iq + Iv]); IC = v2.getItemVisual(Ir[IF], "color") } var Ix; var Iy; var Is = v2.getItemLayout(Ir[0]); var ID = v2.getItemModel(Ir[IF - 1]); var Iu = ID.getModel("label"); var Iz = Iu.get("margin"); if (IB === "add") { var It = Z[IA] = new B8(); Ix = new i8({ shape: { points: II, stackedOnPoints: IG, smooth: 0.4, stackedOnSmooth: 0.4, smoothConstraint: false }, z2: 0 }); Iy = new iR({ style: { x: Is.x - Iz, y: Is.y0 + Is.y / 2 } }); It.add(Ix); It.add(Iy); Im.add(It); Ix.setClipPath(vf(Ix.getBoundingRect(), v, function () { Ix.removeClipPath() })) } else { var It = IE[Io]; Ix = It.childAt(0); Iy = It.childAt(1); Im.add(It); Z[IA] = It; oS(Ix, { shape: { points: II, stackedOnPoints: IG } }, v); oS(Iy, { style: { x: Is.x - Iz, y: Is.y0 + Is.y / 2 } }, v) } var In = ID.getModel("emphasis.itemStyle"); var Ip = ID.getModel("itemStyle"); pe(Iy.style, Iu, { text: Iu.get("show") ? v.getFormattedLabel(Ir[IF - 1], "normal") || v2.getName(Ir[IF - 1]) : null, textVerticalAlign: "middle" }); Ix.setStyle(b0({ fill: IC }, Ip.getItemStyle(["color"]))); yn(Ix, In.getItemStyle()) } this._layersSeries = v1; this._layers = Z }, dispose: function () { } }); function vf(m, i, e) { var k = new EH({ shape: { x: m.x - 10, y: m.y - 10, width: 0, height: m.height + 20 } }); jC(k, { shape: { width: m.width + 20, height: m.height + 20 } }, i, e); return k } var xU = function (e, i) { e.eachSeriesByType("themeRiver", function (v1) { var v2 = v1.getData(); var Ij = v1.coordinateSystem; var Z = {}; var v3 = Ij.getRect(); Z.rect = v3; var m = v1.get("boundaryGap"); var v = Ij.getAxis(); Z.boundaryGap = m; if (v.orient === "horizontal") { m[0] = zN(m[0], v3.height); m[1] = zN(m[1], v3.height); var Ik = v3.height - m[0] - m[1]; pm(v2, v1, Ik) } else { m[0] = zN(m[0], v3.width); m[1] = zN(m[1], v3.width); var k = v3.width - m[0] - m[1]; pm(v2, v1, k) } v2.setLayout("layoutInfo", Z) }) }; function pm(Ik, Z, Iq) { if (!Ik.count()) { return } var v3 = Z.coordinateSystem; var v1 = Z.getLayerSeries(); var Ip = Ik.mapDimension("single"); var In = Ik.mapDimension("value"); var Io = Ef(v1, function (i) { return Ef(i.indices, function (m) { var Is = v3.dataToPoint(Ik.get(Ip, m)); Is[1] = Ik.get(In, m); return Is }) }); var e = wj(Io); var Ir = e.y0; var Il = Iq / e.max; var k = v1.length; var v = v1[0].indices.length; var Im; for (var v2 = 0; v2 < v; ++v2) { Im = Ir[v2] * Il; Ik.setItemLayout(v1[0].indices[v2], { layerIndex: 0, x: Io[0][v2][0], y0: Im, y: Io[0][v2][1] * Il }); for (var Ij = 1; Ij < k; ++Ij) { Im += Io[Ij - 1][v2][1] * Il; Ik.setItemLayout(v1[Ij].indices[v2], { layerIndex: Ij, x: Io[Ij][v2][0], y0: Im, y: Io[Ij][v2][1] * Il }) } } } function wj(Ij) { var v2 = Ij.length; var e = Ij[0].length; var Ik = []; var In = []; var Im = 0; var Io; var m = {}; for (var v3 = 0; v3 < e; ++v3) { for (var v1 = 0, Io = 0; v1 < v2; ++v1) { Io += Ij[v1][v3][1] } if (Io > Im) { Im = Io } Ik.push(Io) } for (var Z = 0; Z < e; ++Z) { In[Z] = (Im - Ik[Z]) / 2 } Im = 0; for (var v = 0; v < e; ++v) { var Il = Ik[v] + In[v]; if (Il > Im) { Im = Il } } m.y0 = In; m.max = Im; return m } var hx = function (e) {
    e.eachSeriesByType("themeRiver", function (i) {
      var m = i.getData(); var Z = i.getRawData(); var k = i.get("color");
      var v = CJ(); m.each(function (v1) { v.set(m.getRawIndex(v1), v1) }); Z.each(function (Ij) { var v3 = Z.getName(Ij); var v2 = k[(i.nameMap.get(v3) - 1) % k.length]; Z.setItemVisual(Ij, "color", v2); var v1 = v.get(Ij); if (v1 != null) { m.setItemVisual(v1, "color", v2) } })
    })
  }; pr(xU); G(hx); eb(D7("themeRiver")); nU.extend({ type: "series.sunburst", _viewRoot: null, getInitialData: function (m, e) { var i = { name: m.name, children: m.data }; Dg(i); var v = m.levels || []; var k = {}; k.levels = v; return nA.createTree(i, this, k).data }, optionUpdated: function () { this.resetViewRoot() }, getDataParams: function (e) { var k = nU.prototype.getDataParams.apply(this, arguments); var i = this.getData().tree.getNodeByDataIndex(e); k.treePathInfo = dM(i, this); return k }, defaultOption: { zlevel: 0, z: 2, center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, minAngle: 0, percentPrecision: 2, stillShowZeroSum: true, highlightPolicy: "descendant", nodeClick: "rootToNode", renderLabelForZeroData: false, label: { rotate: "radial", show: true, opacity: 1, align: "center", position: "inside", distance: 5, silent: true, emphasis: {} }, itemStyle: { borderWidth: 1, borderColor: "white", opacity: 1, emphasis: {}, highlight: { opacity: 1 }, downplay: { opacity: 0.9 } }, animationType: "expansion", animationDuration: 1000, animationDurationUpdate: 500, animationEasing: "cubicOut", data: [], levels: [], sort: "desc" }, getViewRoot: function () { return this._viewRoot }, resetViewRoot: function (i) { i ? (this._viewRoot = i) : (i = this._viewRoot); var e = this.getRawData().tree.root; if (!i || (i !== e && !e.contains(i))) { this._viewRoot = e } } }); function Dg(i) { var k = 0; o9(i.children, function (v) { Dg(v); var m = v.value; GG(m) && (m = m[0]); k += m }); var e = i.value; if (GG(e)) { e = e[0] } if (e == null || isNaN(e)) { e = k } if (e < 0) { e = 0 } GG(i.value) ? (i.value[0] = e) : (i.value = e) } var Eb = { NONE: "none", DESCENDANT: "descendant", ANCESTOR: "ancestor", SELF: "self" }; var rB = 2; var mE = 4; function zD(Z, m, k) { B8.call(this); var v = new tx({ z2: rB }); v.seriesIndex = m.seriesIndex; var v1 = new iR({ z2: mE, silent: Z.getModel("label").get("silent") }); this.add(v); this.add(v1); this.updateData(true, Z, "normal", m, k); function i() { v1.ignore = v1.hoverIgnore } function e() { v1.ignore = v1.normalIgnore } this.on("emphasis", i).on("normal", e).on("mouseover", i).on("mouseout", e) } var it = zD.prototype; it.updateData = function (Ik, v, m, v1, v3) { this.node = v; v.piece = this; v1 = v1 || this._seriesModel; v3 = v3 || this._ecModel; var Z = this.childAt(0); Z.dataIndex = v.dataIndex; var Io = v.getModel(); var v2 = v.getLayout(); if (!v2) { console.log(v.getLayout()) } var Im = b0({}, v2); Im.label = null; var Il = zV(v, v1, v3); var k = Io.getModel("itemStyle").getItemStyle(); var i; if (m === "normal") { i = k } else { var Ij = Io.getModel(m + ".itemStyle").getItemStyle(); i = v4(Ij, k) } i = De({ lineJoin: "bevel", fill: i.fill || Il }, i); if (Ik) { Z.setShape(Im); Z.shape.r = v2.r0; oS(Z, { shape: { r: v2.r } }, v1, v.dataIndex); Z.useStyle(i) } else { if (typeof i.fill === "object" && i.fill.type || typeof Z.style.fill === "object" && Z.style.fill.type) { oS(Z, { shape: Im }, v1); Z.useStyle(i) } else { oS(Z, { shape: Im, style: i }, v1) } } this._updateLabel(v1, Il, m); var In = Io.getShallow("cursor"); In && Z.attr("cursor", In); if (Ik) { var e = v1.getShallow("highlightPolicy"); this._initEvents(Z, v, v1, e) } this._seriesModel = v1 || this._seriesModel; this._ecModel = v3 || this._ecModel }; it.onEmphasis = function (e) { var i = this; this.node.hostTree.root.eachNode(function (k) { if (k.piece) { if (i.node === k) { k.piece.updateData(false, k, "emphasis") } else { if (gG(k, i.node, e)) { k.piece.childAt(0).trigger("highlight") } else { if (e !== Eb.NONE) { k.piece.childAt(0).trigger("downplay") } } } } }) }; it.onNormal = function () { this.node.hostTree.root.eachNode(function (e) { if (e.piece) { e.piece.updateData(false, e, "normal") } }) }; it.onHighlight = function () { this.updateData(false, this.node, "highlight") }; it.onDownplay = function () { this.updateData(false, this.node, "downplay") }; it._updateLabel = function (Io, k, v) {
    var Is = this.node.getModel(); var Ir = Is.getModel("label"); var v1 = v === "normal" || v === "emphasis" ? Ir : Is.getModel(v + ".label"); var Ip = Is.getModel("emphasis.label"); var Ik = gu(Io.getFormattedLabel(this.node.dataIndex, "normal", null, null, "label"), this.node.name); if (Iq("show") === false) { Ik = "" } var Iw = this.node.getLayout(); var Iu = v1.get("minAngle"); if (Iu == null) { Iu = Ir.get("minAngle") } Iu = Iu / 180 * Math.PI; var Iv = Iw.endAngle - Iw.startAngle; if (Iu != null && Math.abs(Iv) < Iu) { Ik = "" } var Z = this.childAt(1); BD(Z.style, Z.hoverStyle || {}, Ir, Ip, { defaultText: v1.getShallow("show") ? Ik : null, autoColor: k, useInsideStyle: true }); var v2 = (Iw.startAngle + Iw.endAngle) / 2; var Ij = Math.cos(v2); var v3 = Math.sin(v2); var Il; var e = Iq("position"); var Ix = Iq("distance") || 0; var m = Iq("align"); if (e === "outside") { Il = Iw.r + Ix; m = v2 > Math.PI / 2 ? "right" : "left" } else { if (!m || m === "center") { Il = (Iw.r + Iw.r0) / 2; m = "center" } else { if (m === "left") { Il = Iw.r0 + Ix; if (v2 > Math.PI / 2) { m = "right" } } else { if (m === "right") { Il = Iw.r - Ix; if (v2 > Math.PI / 2) { m = "left" } } } } } Z.attr("style", { text: Ik, textAlign: m, textVerticalAlign: Iq("verticalAlign") || "middle", opacity: Iq("opacity") }); var In = Il * Ij + Iw.cx; var Im = Il * v3 + Iw.cy; Z.attr("position", [In, Im]); var i = Iq("rotate"); var It = 0; if (i === "radial") { It = -v2; if (It < -Math.PI / 2) { It += Math.PI } } else {
      if (i === "tangential") { It = Math.PI / 2 - v2; if (It > Math.PI / 2) { It -= Math.PI } else { if (It < -Math.PI / 2) { It += Math.PI } } } else {
        if (typeof i === "number") {
          It = i * Math.PI / 180
        }
      }
    } Z.attr("rotation", It); function Iq(Iy) { var Iz = v1.get(Iy); if (Iz == null) { return Ir.get(Iy) } else { return Iz } }
  }; it._initEvents = function (m, i, v, e) { m.off("mouseover").off("mouseout").off("emphasis").off("normal"); var v3 = this; var Z = function () { v3.onEmphasis(e) }; var v1 = function () { v3.onNormal() }; var k = function () { v3.onDownplay() }; var v2 = function () { v3.onHighlight() }; if (v.isAnimationEnabled()) { m.on("mouseover", Z).on("mouseout", v1).on("emphasis", Z).on("normal", v1).on("downplay", k).on("highlight", v2) } }; mr(zD, B8); function zV(v1, k, e) { var v = v1.getVisual("color"); var m = v1.getVisual("visualMeta"); if (!m || m.length === 0) { v = null } var i = v1.getModel("itemStyle").get("color"); if (i) { return i } else { if (v) { return v } else { if (v1.depth === 0) { return e.option.color[0] } else { var Z = e.option.color.length; i = e.option.color[t5(v1) % Z] } } } return i } function t5(k) { var e = k; while (e.depth > 1) { e = e.parentNode } var i = k.getAncestors()[0]; return eP(i.children, e) } function gG(e, k, i) { if (i === Eb.NONE) { return false } else { if (i === Eb.SELF) { return e === k } else { if (i === Eb.ANCESTOR) { return e === k || e.isAncestorOf(k) } else { return e === k || e.isDescendantOf(k) } } } } var BI = "sunburstRootToNode"; var gC = dF.extend({ type: "sunburst", init: function () { }, render: function (v3, Ir, v2, Ij) { var v = this; this.seriesModel = v3; this.api = v2; this.ecModel = Ir; var Iq = v3.getData(); var k = Iq.tree.root; var i = v3.getViewRoot(); var Z = this.group; var Im = v3.get("renderLabelForZeroData"); var Io = []; i.eachNode(function (Is) { Io.push(Is) }); var In = this._oldChildren || []; v1(Io, In); Ip(k, i); if (Ij && Ij.highlight && Ij.highlight.piece) { var e = v3.getShallow("highlightPolicy"); Ij.highlight.piece.onEmphasis(e) } else { if (Ij && Ij.unhighlight) { var m = this.virtualPiece; if (!m && k.children.length) { m = k.children[0].piece } if (m) { m.onNormal() } } } this._initEvents(); this._oldChildren = Io; function v1(Iv, Iu) { if (Iv.length === 0 && Iu.length === 0) { return } new Gx(Iu, Iv, Is, Is).add(It).update(It).remove(sv(It, null)).execute(); function Is(Iw) { return Iw.getId() } function It(Iw, Iz) { var Ix = Iw == null ? null : Iv[Iw]; var Iy = Iz == null ? null : Iu[Iz]; Ik(Ix, Iy) } } function Ik(Is, Iu) { if (!Im && Is && !Is.getValue()) { Is = null } if (Is !== k && Iu !== k) { if (Iu && Iu.piece) { if (Is) { Iu.piece.updateData(false, Is, "normal", v3, Ir); Iq.setItemGraphicEl(Is.dataIndex, Iu.piece) } else { Il(Iu) } } else { if (Is) { var It = new zD(Is, v3, Ir); Z.add(It); Iq.setItemGraphicEl(Is.dataIndex, It) } } } } function Il(Is) { if (!Is) { return } if (Is.piece) { Z.remove(Is.piece); Is.piece = null } } function Ip(It, Iu) { if (Iu.depth > 0) { if (v.virtualPiece) { v.virtualPiece.updateData(false, It, "normal", v3, Ir) } else { v.virtualPiece = new zD(It, v3, Ir); Z.add(v.virtualPiece) } if (Iu.piece._onclickEvent) { Iu.piece.off("click", Iu.piece._onclickEvent) } var Is = function (Iv) { v._rootToNode(Iu.parentNode) }; Iu.piece._onclickEvent = Is; v.virtualPiece.on("click", Is) } else { if (v.virtualPiece) { Z.remove(v.virtualPiece); v.virtualPiece = null } } } }, dispose: function () { }, _initEvents: function () { var i = this; var e = function (v) { var k = false; var m = i.seriesModel.getViewRoot(); m.eachNode(function (v3) { if (!k && v3.piece && v3.piece.childAt(0) === v.target) { var Z = v3.getModel().get("nodeClick"); if (Z === "rootToNode") { i._rootToNode(v3) } else { if (Z === "link") { var v1 = v3.getModel(); var v2 = v1.get("link"); if (v2) { var Ij = v1.get("target", true) || "_blank"; window.open(v2, Ij) } } } k = true } }) }; if (this.group._onclickEvent) { this.group.off("click", this.group._onclickEvent) } this.group.on("click", e); this.group._onclickEvent = e }, _rootToNode: function (e) { if (e !== this.seriesModel.getViewRoot()) { this.api.dispatchAction({ type: BI, from: this.uid, seriesId: this.seriesModel.id, targetNode: e }) } }, containPoint: function (i, Z) { var v = Z.getData(); var v1 = v.getItemLayout(0); if (v1) { var m = i[0] - v1.cx; var k = i[1] - v1.cy; var e = Math.sqrt(m * m + k * k); return e <= v1.r && e >= v1.r0 } } }); var vK = "sunburstRootToNode"; b1({ type: vK, update: "updateView" }, function (k, e) { e.eachComponent({ mainType: "series", subType: "sunburst", query: k }, i); function i(Z, v) { var v1 = uT(k, [vK], Z); if (v1) { var m = Z.getViewRoot(); if (m) { k.direction = wM(m, v1.node) ? "rollUp" : "drillDown" } Z.resetViewRoot(v1.node) } } }); var oo = "sunburstHighlight"; b1({ type: oo, update: "updateView" }, function (k, i) { i.eachComponent({ mainType: "series", subType: "sunburst", query: k }, e); function e(v, m) { var Z = uT(k, [oo], v); if (Z) { k.highlight = Z.node } } }); var se = "sunburstUnhighlight"; b1({ type: se, update: "updateView" }, function (k, e) { e.eachComponent({ mainType: "series", subType: "sunburst", query: k }, i); function i(v, m) { k.unhighlight = true } }); var fY = Math.PI / 180; var lW = function (i, e, k, m) {
    e.eachSeriesByType(i, function (Ix) {
      var IG = Ix.get("center"); var Ik = Ix.get("radius"); if (!GG(Ik)) { Ik = [0, Ik] } if (!GG(IG)) { IG = [IG, IG] } var Iy = k.getWidth(); var It = k.getHeight(); var Is = Math.min(Iy, It); var Ij = zN(IG[0], Iy); var v2 = zN(IG[1], It); var IC = zN(Ik[0], Is / 2); var Ir = zN(Ik[1], Is / 2); var IB = -Ix.get("startAngle") * fY; var IA = Ix.get("minAngle") * fY; var v3 = Ix.getData().tree.root; var Iz = Ix.getViewRoot(); var Z = Iz.depth; var IF = Ix.get("sort"); if (IF != null) { A2(Iz, IF) } var Iw = 0; o9(Iz.children, function (IH) { !isNaN(IH.getValue()) && Iw++ }); var v1 = Iz.getValue(); var Iv = Math.PI / (v1 || Iw) * 2; var Im = Iz.depth > 0; var Io = Iz.height - (Im ? -1 : 1); var v = (Ir - IC) / (Io || 1); var ID = Ix.get("clockwise");
      var Il = Ix.get("stillShowZeroSum"); var Iu = ID ? 1 : -1; var In = function (II, IL) { if (!II) { return } var IH = IL; if (II !== v3) { var IN = II.getValue(); var IJ = (v1 === 0 && Il) ? Iv : (IN * Iv); if (IJ < IA) { IJ = IA } else { } IH = IL + Iu * IJ; var IK = II.depth - Z - (Im ? -1 : 1); var IP = IC + v * IK; var IM = IC + v * (IK + 1); var IQ = II.getModel(); if (IQ.get("r0") != null) { IP = zN(IQ.get("r0"), Is / 2) } if (IQ.get("r") != null) { IM = zN(IQ.get("r"), Is / 2) } II.setLayout({ angle: IJ, startAngle: IL, endAngle: IH, clockwise: ID, cx: Ij, cy: v2, r0: IP, r: IM }) } if (II.children && II.children.length) { var IO = 0; o9(II.children, function (IR) { IO += In(IR, IL + IO) }) } return IH - IL }; if (Im) { var Iq = IC; var Ip = IC + v; var IE = Math.PI * 2; v3.setLayout({ angle: IE, startAngle: IB, endAngle: IB + IE, clockwise: ID, cx: Ij, cy: v2, r0: Iq, r: Ip }) } In(Iz, IB)
    })
  }; function A2(k, e) { var i = k.children || []; k.children = fA(i, e); if (i.length) { o9(k.children, function (m) { A2(m, e) }) } } function fA(i, k) { if (typeof k === "function") { return i.sort(k) } else { var e = k === "asc"; return i.sort(function (v, m) { var Z = (v.getValue() - m.getValue()) * (e ? 1 : -1); return Z === 0 ? (v.dataIndex - m.dataIndex) * (e ? -1 : 1) : Z }) } } G(sv(eN, "sunburst")); pr(sv(lW, "sunburst")); eb(sv(D7, "sunburst")); function ht(e, i) { i = i || [0, 0]; return Ef(["x", "y"], function (Z, k) { var v = this.getAxis(Z); var v1 = i[k]; var m = e[k] / 2; return v.type === "category" ? v.getBandWidth() : Math.abs(v.dataToCoord(v1 - m) - v.dataToCoord(v1 + m)) }, this) } var Hz = function (e) { var i = e.grid.getRect(); return { coordSys: { type: "cartesian2d", x: i.x, y: i.y, width: i.width, height: i.height }, api: { coord: function (k) { return e.dataToPoint(k) }, size: km(ht, e) } } }; function cM(e, i) { i = i || [0, 0]; return Ef([0, 1], function (k) { var v1 = i[k]; var m = e[k] / 2; var Z = []; var v = []; Z[k] = v1 - m; v[k] = v1 + m; Z[1 - k] = v[1 - k] = i[1 - k]; return Math.abs(this.dataToPoint(Z)[k] - this.dataToPoint(v)[k]) }, this) } var Hg = function (e) { var i = e.getBoundingRect(); return { coordSys: { type: "geo", x: i.x, y: i.y, width: i.width, height: i.height, zoom: e.getZoom() }, api: { coord: function (k) { return e.dataToPoint(k) }, size: km(cM, e) } } }; function cK(e, i) { var m = this.getAxis(); var v = i instanceof Array ? i[0] : i; var k = (e instanceof Array ? e[0] : e) / 2; return m.type === "category" ? m.getBandWidth() : Math.abs(m.dataToCoord(v - k) - m.dataToCoord(v + k)) } var jV = function (e) { var i = e.getRect(); return { coordSys: { type: "singleAxis", x: i.x, y: i.y, width: i.width, height: i.height }, api: { coord: function (k) { return e.dataToPoint(k) }, size: km(cK, e) } } }; function cI(e, i) { return Ef(["Radius", "Angle"], function (v1, m) { var Z = this["get" + v1 + "Axis"](); var v2 = i[m]; var v = e[m] / 2; var v3 = "dataTo" + v1; var k = Z.type === "category" ? Z.getBandWidth() : Math.abs(Z[v3](v2 - v) - Z[v3](v2 + v)); if (v1 === "Angle") { k = k * Math.PI / 180 } return k }, this) } var G1 = function (k) { var m = k.getRadiusAxis(); var i = k.getAngleAxis(); var e = m.getExtent(); e[0] > e[1] && e.reverse(); return { coordSys: { type: "polar", cx: k.cx, cy: k.cy, r: e[1], r0: e[0] }, api: { coord: km(function (Z) { var v = m.dataToRadius(Z[0]); var v1 = i.dataToAngle(Z[1]); var v2 = k.coordToPoint([v, v1]); v2.push(v, v1 * Math.PI / 180); return v2 }), size: km(cI, k) } } }; var z4 = function (i) { var k = i.getRect(); var e = i.getRangeInfo(); return { coordSys: { type: "calendar", x: k.x, y: k.y, width: k.width, height: k.height, cellWidth: i.getCellWidth(), cellHeight: i.getCellHeight(), rangeInfo: { start: e.start, end: e.end, weeks: e.weeks, dayCount: e.allDay } }, api: { coord: function (m, v) { return i.dataToPoint(m, v) } } } }; var wf = ["itemStyle"]; var Ge = ["emphasis", "itemStyle"]; var xI = ["label"]; var xl = ["emphasis", "label"]; var t8 = "e\0\0"; var iQ = { cartesian2d: Hz, geo: Hg, singleAxis: jV, polar: G1, calendar: z4 }; B3({ type: "series.custom", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: true, useTransform: true }, getInitialData: function (i, e) { return a(this.getSource(), this) } }); BL({ type: "custom", _data: null, render: function (i, e, k, v1) { var v2 = this._data; var v = i.getData(); var Z = this.group; var m = F5(i, v, e, k); v.diff(v2).add(function (v3) { bg(null, v3, m(v3, v1), i, Z, v) }).update(function (Ik, v3) { var Ij = v2.getItemGraphicEl(v3); bg(Ij, Ik, m(Ik, v1), i, Z, v) }).remove(function (v3) { var Ij = v2.getItemGraphicEl(v3); Ij && Z.remove(Ij) }).execute(); this._data = v }, incrementalPrepareRender: function (i, e, k) { this.group.removeAll(); this._data = null }, incrementalRender: function (i, k, Z, v1, Ij) { var v = k.getData(); var m = F5(k, v, Z, v1); function v2(Ik) { if (!Ik.isGroup) { Ik.incremental = true; Ik.useHoverLayer = true } } for (var v3 = i.start; v3 < i.end; v3++) { var e = bg(null, v3, m(v3, Ij), k, this.group, v); e.traverse(v2) } }, dispose: V, filterForExposedEvent: function (e, m, v, k) { var i = m.target; if (i == null || v.name === i) { return true } while ((v = v.parent) && v !== this.group) { if (v.name === i) { return true } } return false } }); function pQ(v) { var k = v.type; var m; if (k === "path") { var i = v.shape; m = Bd(i.pathData, null, { x: i.x || 0, y: i.y || 0, width: i.width || 0, height: i.height || 0 }, "center"); m.__customPathData = v.pathData } else { if (k === "image") { m = new Ft({}); m.__customImagePath = v.style.image } else { if (k === "text") { m = new iR({}); m.__customText = v.style.text } else { var e = yf[k.charAt(0).toUpperCase() + k.slice(1)]; if (ok) { bM(e, 'graphic type "' + k + '" can not be found.') } m = new e() } } } m.__customGraphicType = k; m.name = v.name; return m } function rR(k, Il, e, Z, v1, v2, v) {
    var m = {}; var Im = e.style || {};
    e.shape && (m.shape = C5(e.shape)); e.position && (m.position = e.position.slice()); e.scale && (m.scale = e.scale.slice()); e.origin && (m.origin = e.origin.slice()); e.rotation && (m.rotation = e.rotation); if (k.type === "image" && e.style) { var Ij = m.style = {}; o9(["x", "y", "width", "height"], function (In) { m1(In, Ij, Im, k.style, v2) }) } if (k.type === "text" && e.style) { var Ij = m.style = {}; o9(["x", "y"], function (In) { m1(In, Ij, Im, k.style, v2) }); !Im.hasOwnProperty("textFill") && Im.fill && (Im.textFill = Im.fill); !Im.hasOwnProperty("textStroke") && Im.stroke && (Im.textStroke = Im.stroke) } if (k.type !== "group") { k.useStyle(Im); if (v2) { k.style.opacity = 0; var Ik = Im.opacity; Ik == null && (Ik = 1); jC(k, { style: { opacity: Ik } }, Z, Il) } } if (v2) { k.attr(m) } else { oS(k, m, Z, Il) } k.attr({ z2: e.z2 || 0, silent: e.silent, invisible: e.invisible, ignore: e.ignore }); var i = e.styleEmphasis; var v3 = i === false; if (!((k.__cusHasEmphStl && i == null) || (!k.__cusHasEmphStl && v3))) { li(k, i); k.__cusHasEmphStl = !v3 } v && yJ(k, !v3)
  } function m1(v, k, i, e, m) { if (i[v] != null && !m) { k[v] = i[v]; i[v] = e[v] } } function F5(i, Iu, Iw, Ij) { var v1 = i.get("renderItem"); var m = i.coordinateSystem; var k = {}; if (m) { if (ok) { bM(v1, "series.render is required."); bM(m.prepareCustoms || iQ[m.type], "This coordSys does not support custom series.") } k = m.prepareCustoms ? m.prepareCustoms() : iQ[m.type](m) } var v2 = De({ getWidth: Ij.getWidth, getHeight: Ij.getHeight, getZr: Ij.getZr, getDevicePixelRatio: Ij.getDevicePixelRatio, value: Io, style: Iq, styleEmphasis: Is, visual: Ir, barLayout: e, currentSeriesIndices: v3, font: Ik }, k.api || {}); var Im = { context: {}, seriesId: i.id, seriesName: i.name, seriesIndex: i.seriesIndex, coordSys: k.coordSys, dataInsideLength: Iu.count(), encode: bw(i.getData()) }; var Iv; var Ip = true; var Z; var Il; var It; var In; return function (Ix, Iy) { Iv = Ix; Ip = true; return v1 && v1(De({ dataIndexInside: Ix, dataIndex: Iu.getRawIndex(Ix), actionType: Iy ? Iy.type : null }, Im), v2) || {} }; function v(Ix) { Ix == null && (Ix = Iv); if (Ip) { Z = Iu.getItemModel(Ix); Il = Z.getModel(xI); It = Z.getModel(xl); In = Iu.getItemVisual(Ix, "color"); Ip = false } } function Io(Iy, Ix) { Ix == null && (Ix = Iv); return Iu.get(Iu.getDimension(Iy || 0), Ix) } function Iq(Ix, IA) { IA == null && (IA = Iv); v(IA); var Iz = Z.getModel(wf).getItemStyle(); In != null && (Iz.fill = In); var Iy = Iu.getItemVisual(IA, "opacity"); Iy != null && (Iz.opacity = Iy); pe(Iz, Il, null, { autoColor: In, isRectText: true }); Iz.text = Il.getShallow("show") ? kb(i.getFormattedLabel(IA, "normal"), dX(Iu, IA)) : null; Ix && b0(Iz, Ix); return Iz } function Is(Ix, Iz) { Iz == null && (Iz = Iv); v(Iz); var Iy = Z.getModel(Ge).getItemStyle(); pe(Iy, It, null, { isRectText: true }, true); Iy.text = It.getShallow("show") ? ka(i.getFormattedLabel(Iz, "emphasis"), i.getFormattedLabel(Iz, "normal"), dX(Iu, Iz)) : null; Ix && b0(Iy, Ix); return Iy } function Ir(Iy, Ix) { Ix == null && (Ix = Iv); return Iu.getItemVisual(Ix, Iy) } function e(Ix) { if (m.getBaseAxis) { var Iy = m.getBaseAxis(); return og(De({ axis: Iy }, Ix), Ij) } } function v3() { return Iw.getCurrentSeriesIndices() } function Ik(Ix) { return jZ(Ix, Iw) } } function bw(e) { var i = {}; o9(e.dimensions, function (v1, k) { var m = e.getDimensionInfo(v1); if (!m.isExtraCoord) { var v = m.coordDim; var Z = i[v] = i[v] || []; Z[m.coordDimIndex] = k } }); return i } function bg(i, e, k, Z, v, m) { i = qg(i, e, k, Z, v, m, true); i && m.setItemGraphicEl(e, i); return i } function qg(i, v2, e, m, v3, v, k) { e = e || {}; var v1 = e.type; if (i && (v1 == null || e.$merge === false || (v1 !== i.__customGraphicType && (v1 !== "path" || e.pathData !== i.__customPathData) && (v1 !== "image" || e.style.image !== i.__customImagePath) && (v1 !== "text" || e.style.text !== i.__customText)))) { v3.remove(i); i = null } if (v1 == null) { return } var Z = !i; !i && (i = pQ(e)); rR(i, v2, e, m, v, Z, k); if (v1 === "group") { q9(i, v2, e, m, v) } v3.add(i); return i } function q9(i, v3, e, m, v) { var k = e.children; var v1 = k ? k.length : 0; var Ij = e.$mergeChildren; var Ik = Ij === "byName" || e.diffChildrenByName; var Z = Ij === false; if (!v1 && !Ik && !Z) { return } if (Ik) { bu({ oldChildren: i.children() || [], newChildren: k || [], dataIndex: v3, animatableModel: m, group: i, data: v }); return } Z && i.removeAll(); var v2 = 0; for (; v2 < v1; v2++) { k[v2] && qg(i.childAt(v2), v3, k[v2], m, i, v) } if (ok) { bM(!Z || i.childCount() === v2, "MUST NOT contain empty item in children array when `group.$mergeChildren` is `false`.") } } function bu(e) { (new Gx(e.oldChildren, e.newChildren, f8, f8, e)).add(ly).update(ly).remove(zb).execute() } function f8(k, e) { var i = k && k.name; return i != null ? i : t8 + e } function ly(i, v) { var e = this.context; var k = i != null ? e.newChildren[i] : null; var m = v != null ? e.oldChildren[v] : null; qg(m, e.dataIndex, k, e.animatableModel, e.group, e.data) } function zb(k) { var e = this.context; var i = e.oldChildren[k]; i && e.group.remove(i) } y2(function (i) { var e = i.graphic; if (GG(e)) { if (!e[0] || !e[0].elements) { i.graphic = [{ elements: e }] } else { i.graphic = [i.graphic[0]] } } else { if (e && !e.elements) { i.graphic = [{ elements: [e] }] } } }); var HK = p2({
    type: "graphic", defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption: function (e) { var i = this.option.elements; this.option.elements = null; HK.superApply(this, "mergeOption", arguments); this.option.elements = i }, optionUpdated: function (v1, v) {
      var v3 = this.option; var e = (v ? v3 : v1).elements; var k = v3.elements = v ? [] : v3.elements; var Ij = []; this._flatten(e, Ij); var Z = c9(k, Ij); z3(Z); var v2 = this._elOptionsToUpdate = []; o9(Z, function (Ik, Il) {
        var i = Ik.option;
        if (ok) { bM(tJ(i) || Ik.exist, "Empty graphic option definition") } if (!i) { return } v2.push(i); GN(Ik, i); EB(k, Il, i); uV(k[Il], i)
      }, this); for (var m = k.length - 1; m >= 0; m--) { if (k[m] == null) { k.splice(m, 1) } else { delete k[m].$action } }
    }, _flatten: function (i, e, k) { o9(i, function (v) { if (!v) { return } if (k) { v.parentOption = k } e.push(v); var m = v.children; if (v.type === "group" && m) { this._flatten(m, e, v) } delete v.children }, this) }, useElOptionsToUpdate: function () { var e = this._elOptionsToUpdate; this._elOptionsToUpdate = null; return e }
  }); qy({ type: "graphic", init: function (e, i) { this._elMap = CJ(); this._lastGraphicModel }, render: function (k, e, i) { if (k !== this._lastGraphicModel) { this._clear() } this._lastGraphicModel = k; this._updateElements(k, i); this._relocate(k, i) }, _updateElements: function (v, k) { var i = v.useElOptionsToUpdate(); if (!i) { return } var e = this._elMap; var m = this.group; o9(i, function (v1) { var In = v1.$action; var v2 = v1.id; var Z = e.get(v2); var Ik = v1.parentId; var Ij = Ik != null ? e.get(Ik) : m; if (v1.type === "text") { var Il = v1.style; if (v1.hv && v1.hv[1]) { Il.textVerticalAlign = Il.textBaseline = null } !Il.hasOwnProperty("textFill") && Il.fill && (Il.textFill = Il.fill); !Il.hasOwnProperty("textStroke") && Il.stroke && (Il.textStroke = Il.stroke) } var Im = ye(v1); if (ok) { Z && bM(Ij === Z.parent, "Changing parent is not supported.") } if (!In || In === "merge") { Z ? Z.attr(Im) : xT(v2, Ij, Im, e) } else { if (In === "replace") { x3(Z, e); xT(v2, Ij, Im, e) } else { if (In === "remove") { x3(Z, e) } } } var v3 = e.get(v2); if (v3) { v3.__ecGraphicWidth = v1.width; v3.__ecGraphicHeight = v1.height } }) }, _relocate: function (v1, v3) { var Ik = v1.option.elements; var Ij = this.group; var m = this._elMap; for (var Z = Ik.length - 1; Z >= 0; Z--) { var e = Ik[Z]; var k = m.get(e.id); if (!k) { continue } var v2 = k.parent; var v = v2 === Ij ? { width: v3.getWidth(), height: v3.getHeight() } : { width: v2.__ecGraphicWidth || 0, height: v2.__ecGraphicHeight || 0 }; Ax(k, e, v, null, { hv: e.hv, boundingMode: e.bounding }) } }, _clear: function () { var e = this._elMap; e.each(function (i) { x3(i, e) }); this._elMap = CJ() }, dispose: function () { this._clear() } }); function xT(v1, k, Z, e) { var m = Z.type; if (ok) { bM(m, "graphic type MUST be set") } var i = yf[m.charAt(0).toUpperCase() + m.slice(1)]; if (ok) { bM(i, "graphic type can not be found") } var v = new i(Z); k.add(v); e.set(v1, v); v.__ecGraphicId = v1 } function x3(k, e) { var i = k && k.parent; if (i) { k.type === "group" && k.traverse(function (m) { x3(m, e) }); e.removeKey(k.__ecGraphicId); i.remove(k) } } function ye(e) { e = b0({}, e); o9(["id", "parentId", "$action", "hv", "bounding"].concat(rq), function (i) { delete e[i] }); return e } function e7(k, i) { var e; o9(i, function (m) { k[m] != null && k[m] !== "auto" && (e = true) }); return e } function GN(k, i) { var m = k.exist; i.id = k.keyInfo.id; !i.type && m && (i.type = m.type); if (i.parentId == null) { var e = i.parentOption; if (e) { i.parentId = e.id } else { if (m) { i.parentId = m.parentId } } } i.parentOption = null } function EB(e, m, i) { var Z = b0({}, i); var v = e[m]; var v1 = i.$action || "merge"; if (v1 === "merge") { if (v) { if (ok) { var k = i.type; bM(!k || v.type === k, 'Please set $action: "replace" to change `type`') } v4(v, Z, true); he(v, Z, { ignoreSize: true }); FJ(i, v) } else { e[m] = Z } } else { if (v1 === "replace") { e[m] = Z } else { if (v1 === "remove") { v && (e[m] = null) } } } } function uV(i, e) { if (!i) { return } i.hv = e.hv = [e7(e, ["left", "right"]), e7(e, ["top", "bottom"])]; if (i.type === "group") { i.width == null && (i.width = e.width = 0); i.height == null && (i.height = e.height = 0) } } var fb = p2({ type: "legend.plain", dependencies: ["series"], layoutMode: { type: "box", ignoreSize: true }, init: function (k, i, e) { this.mergeDefaultAndTheme(k, e); k.selected = k.selected || {} }, mergeOption: function (e) { fb.superCall(this, "mergeOption", e) }, optionUpdated: function () { this._updateData(this.ecModel); var k = this._data; if (k[0] && this.get("selectedMode") === "single") { var e = false; for (var v = 0; v < k.length; v++) { var m = k[v].get("name"); if (this.isSelected(m)) { this.select(m); e = true; break } } !e && this.select(k[0].get("name")) } }, _updateData: function (e) { var k = []; var m = []; e.eachRawSeries(function (v2) { var Z = v2.name; m.push(Z); var v1; if (v2.legendDataProvider) { var v3 = v2.legendDataProvider(); var Ij = v3.mapArray(v3.getName); if (!e.isSeriesFiltered(v2)) { m = m.concat(Ij) } if (Ij.length) { k = k.concat(Ij) } else { v1 = true } } else { v1 = true } if (v1 && qV(v2)) { k.push(v2.name) } }); this._availableNames = m; var v = this.get("data") || k; var i = Ef(v, function (Z) { if (typeof Z === "string" || typeof Z === "number") { Z = { name: Z } } return new fv(Z, this, this.ecModel) }, this); this._data = i }, getData: function () { return this._data }, select: function (e) { var i = this.option.selected; var m = this.get("selectedMode"); if (m === "single") { var k = this._data; o9(k, function (v) { i[v.get("name")] = false }) } i[e] = true }, unSelect: function (e) { if (this.get("selectedMode") !== "single") { this.option.selected[e] = false } }, toggleSelected: function (e) { var i = this.option.selected; if (!i.hasOwnProperty(e)) { i[e] = true } this[i[e] ? "unSelect" : "select"](e) }, isSelected: function (e) { var i = this.option.selected; return !(i.hasOwnProperty(e) && !i[e]) && eP(this._availableNames, e) >= 0 }, defaultOption: { zlevel: 0, z: 4, show: true, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", textStyle: { color: "#333" }, selectedMode: true, tooltip: { show: false } } });
  function jO(i, Z, e) { var v = {}; var m = i === "toggleSelected"; var k; e.eachComponent("legend", function (v2) { if (m && k != null) { v2[k ? "select" : "unSelect"](Z.name) } else { v2[i](Z.name); k = v2.isSelected(Z.name) } var v1 = v2.getData(); o9(v1, function (Ij) { var v3 = Ij.get("name"); if (v3 === "\n" || v3 === "") { return } var Ik = v2.isSelected(v3); if (v.hasOwnProperty(v3)) { v[v3] = v[v3] && Ik } else { v[v3] = Ik } }) }); return { name: Z.name, selected: v } } b1("legendToggleSelect", "legendselectchanged", sv(jO, "toggleSelected")); b1("legendSelect", "legendselected", sv(jO, "select")); b1("legendUnSelect", "legendunselected", sv(jO, "unSelect")); function ee(v1, k, m) { var i = k.getBoxLayoutParams(); var Z = k.get("padding"); var e = { width: m.getWidth(), height: m.getHeight() }; var v = kV(i, e, Z); fl(k.get("orient"), v1, k.get("itemGap"), v.width, v.height); Ax(v1, i, e, Z) } function An(k, e) { var m = Bj(e.get("padding")); var i = e.getItemStyle(["color", "opacity"]); i.fill = e.get("backgroundColor"); var k = new EH({ shape: { x: k.x - m[3], y: k.y - m[0], width: k.width + m[1] + m[3], height: k.height + m[0] + m[2], r: e.get("borderRadius") }, style: i, silent: true, z2: -1 }); return k } var uh = sv; var tS = o9; var ri = B8; var aJ = qy({ type: "legend.plain", newlineDisabled: false, init: function () { this.group.add(this._contentGroup = new ri()); this._backgroundEl }, getContentGroup: function () { return this._contentGroup }, render: function (k, v, Z) { this.resetInner(); if (!k.get("show", true)) { return } var i = k.get("align"); if (!i || i === "auto") { i = (k.get("left") === "right" && k.get("orient") === "vertical") ? "right" : "left" } this.renderInner(i, k, v, Z); var e = k.getBoxLayoutParams(); var m = { width: Z.getWidth(), height: Z.getHeight() }; var v2 = k.get("padding"); var Ij = kV(e, m, v2); var v1 = this.layoutInner(k, i, Ij); var v3 = kV(De({ width: v1.width, height: v1.height }, e), m, v2); this.group.attr("position", [v3.x - v1.x, v3.y - v1.y]); this.group.add(this._backgroundEl = An(v1, k)) }, resetInner: function () { this.getContentGroup().removeAll(); this._backgroundEl && this.group.remove(this._backgroundEl) }, renderInner: function (i, Z, e, v) { var m = this.getContentGroup(); var v2 = CJ(); var v1 = Z.get("selectedMode"); var k = []; e.eachRawSeries(function (v3) { !v3.get("legendHoverLink") && k.push(v3.id) }); tS(Z.getData(), function (Ip, Io) { var v3 = Ip.get("name"); if (!this.newlineDisabled && (v3 === "" || v3 === "\n")) { m.add(new ri({ newline: true })); return } var Ij = e.getSeriesByName(v3)[0]; if (v2.get(v3)) { return } if (Ij) { var Im = Ij.getData(); var Il = Im.getVisual("color"); if (typeof Il === "function") { Il = Il(Ij.getDataParams(0)) } var In = Im.getVisual("legendSymbol") || "roundRect"; var Iq = Im.getVisual("symbol"); var Ik = this._createItem(v3, Io, Ip, Z, In, Iq, i, Il, v1); Ik.on("click", uh(DR, v3, v)).on("mouseover", uh(uX, Ij, null, v, k)).on("mouseout", uh(kD, Ij, null, v, k)); v2.set(v3, true) } else { e.eachRawSeries(function (It) { if (v2.get(v3)) { return } if (It.legendDataProvider) { var Iv = It.legendDataProvider(); var Ir = Iv.indexOfName(v3); if (Ir < 0) { return } var Is = Iv.getItemVisual(Ir, "color"); var Iu = "roundRect"; var Iw = this._createItem(v3, Io, Ip, Z, Iu, null, i, Is, v1); Iw.on("click", uh(DR, v3, v)).on("mouseover", uh(uX, It, v3, v, k)).on("mouseout", uh(kD, It, v3, v, k)); v2.set(v3, true) } }, this) } if (ok) { if (!v2.get(v3)) { console.warn(v3 + " series not exists. Legend data should be same with series name or data name.") } } }, this) }, _createItem: function (Iy, Ix, It, i, k, Il, v2, Is, Iw) { var Z = i.get("itemWidth"); var Iq = i.get("itemHeight"); var v = i.get("inactiveColor"); var m = i.get("symbolKeepAspect"); var Ik = i.isSelected(Iy); var Iv = new ri(); var Ij = It.getModel("textStyle"); var Ip = It.get("icon"); var v3 = It.getModel("tooltip"); var e = v3.parentModel; k = Ip || k; Iv.add(t9(k, 0, 0, Z, Iq, Ik ? Is : v, m == null ? true : m)); if (!Ip && Il && ((Il !== k) || Il == "none")) { var In = Iq * 0.8; if (Il === "none") { Il = "circle" } Iv.add(t9(Il, (Z - In) / 2, (Iq - In) / 2, In, In, Ik ? Is : v, m == null ? true : m)) } var Io = v2 === "left" ? Z + 5 : -5; var v1 = v2; var Iu = i.get("formatter"); var Ir = Iy; if (typeof Iu === "string" && Iu) { Ir = Iu.replace("{name}", Iy != null ? Iy : "") } else { if (typeof Iu === "function") { Ir = Iu(Iy) } } Iv.add(new iR({ style: pe({}, Ij, { text: Ir, x: Io, y: Iq / 2, textFill: Ik ? Ij.getTextColor() : v, textAlign: v1, textVerticalAlign: "middle" }) })); var Im = new EH({ shape: Iv.getBoundingRect(), invisible: true, tooltip: v3.get("show") ? b0({ content: Iy, formatter: e.get("formatter", true) || function () { return Iy }, formatterParams: { componentType: "legend", legendIndex: i.componentIndex, name: Iy, $vars: ["name"] } }, v3.option) : null }); Iv.add(Im); Iv.eachChild(function (Iz) { Iz.silent = true }); Im.silent = !Iw; this.getContentGroup().add(Iv); yn(Iv); Iv.__legendDataIndex = Ix; return Iv }, layoutInner: function (m, i, v) { var k = this.getContentGroup(); fl(m.get("orient"), k, m.get("itemGap"), v.width, v.height); var e = k.getBoundingRect(); k.attr("position", [-e.x, -e.y]); return this.group.getBoundingRect() } }); function DR(e, i) { i.dispatchAction({ type: "legendToggleSelect", name: e }) } function uX(i, e, v, k) { var m = v.getZr().storage.getDisplayList()[0]; if (!(m && m.useHoverLayer)) { v.dispatchAction({ type: "highlight", seriesName: i.name, name: e, excludeSeriesId: k }) } } function kD(i, e, v, k) { var m = v.getZr().storage.getDisplayList()[0]; if (!(m && m.useHoverLayer)) { v.dispatchAction({ type: "downplay", seriesName: i.name, name: e, excludeSeriesId: k }) } } var wX = function (e) {
    var i = e.findComponents({ mainType: "legend" });
    if (i && i.length) { e.filterSeries(function (m) { for (var k = 0; k < i.length; k++) { if (!i[k].isSelected(m.name)) { return false } } return true }) }
  }; eb(wX); aH.registerSubTypeDefaulter("legend", function () { return "plain" }); var je = fb.extend({ type: "legend.scroll", setScrollDataIndex: function (e) { this.option.scrollDataIndex = e }, defaultOption: { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }, init: function (k, i, e, m) { var v = g2(k); je.superCall(this, "init", k, i, e, m); us(this, k, v) }, mergeOption: function (e, i) { je.superCall(this, "mergeOption", e, i); us(this, this.option, e) }, getOrient: function () { return this.get("orient") === "vertical" ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" } } }); function us(m, v, k) { var i = m.getOrient(); var e = [1, 1]; e[i.index] = 0; he(v, k, { type: "box", ignoreSize: e }) } var rh = B8; var dJ = ["width", "height"]; var cT = ["x", "y"]; var sC = aJ.extend({
    type: "legend.scroll", newlineDisabled: true, init: function () { sC.superCall(this, "init"); this._currentIndex = 0; this.group.add(this._containerGroup = new rh()); this._containerGroup.add(this.getContentGroup()); this.group.add(this._controllerGroup = new rh()); this._showController }, resetInner: function () { sC.superCall(this, "resetInner"); this._controllerGroup.removeAll(); this._containerGroup.removeClipPath(); this._containerGroup.__rectSize = null }, renderInner: function (e, m, v1, v2) { var v3 = this; sC.superCall(this, "renderInner", e, m, v1, v2); var k = this._controllerGroup; var i = m.get("pageIconSize", true); if (!GG(i)) { i = [i, i] } v("pagePrev", 0); var Z = m.getModel("pageTextStyle"); k.add(new iR({ name: "pageText", style: { textFill: Z.getTextColor(), font: Z.getFont(), textVerticalAlign: "middle", textAlign: "center" }, silent: true })); v("pageNext", 1); function v(Ik, Ij) { var Il = Ik + "DataIndex"; var Im = Gb(m.get("pageIcons", true)[m.getOrient().name][Ij], { onclick: km(v3._pageGo, v3, Il, m, v2) }, { x: -i[0] / 2, y: -i[1] / 2, width: i[0], height: i[1] }); Im.name = Ik; k.add(Im) } }, layoutInner: function (i, Ij, Z) { var Il = this.getContentGroup(); var v1 = this._containerGroup; var m = this._controllerGroup; var Io = i.getOrient().index; var v3 = dJ[Io]; var Is = dJ[1 - Io]; var Ip = cT[1 - Io]; fl(i.get("orient"), Il, i.get("itemGap"), !Io ? null : Z.width, Io ? null : Z.height); fl("horizontal", m, i.get("pageButtonItemGap", true)); var Iq = Il.getBoundingRect(); var Iu = m.getBoundingRect(); var It = this._showController = Iq[v3] > Z[v3]; var Im = [-Iq.x, -Iq.y]; Im[Io] = Il.position[Io]; var v2 = [0, 0]; var k = [-Iu.x, -Iu.y]; var In = kb(i.get("pageButtonGap", true), i.get("itemGap", true)); if (It) { var e = i.get("pageButtonPosition", true); if (e === "end") { k[Io] += Z[v3] - Iu[v3] } else { v2[Io] += Iu[v3] + In } } k[1 - Io] += Iq[Is] / 2 - Iu[Is] / 2; Il.attr("position", Im); v1.attr("position", v2); m.attr("position", k); var Ir = this.group.getBoundingRect(); var Ir = { x: 0, y: 0 }; Ir[v3] = It ? Z[v3] : Iq[v3]; Ir[Is] = Math.max(Iq[Is], Iu[Is]); Ir[Ip] = Math.min(0, Iu[Ip] + k[1 - Io]); v1.__rectSize = Z[v3]; if (It) { var Ik = { x: 0, y: 0 }; Ik[v3] = Math.max(Z[v3] - Iu[v3] - In, 0); Ik[Is] = Ir[Is]; v1.setClipPath(new EH({ shape: Ik })); v1.__rectSize = Ik[v3] } else { m.eachChild(function (Iv) { Iv.attr({ invisible: true, silent: true }) }) } var v = this._getPageInfo(i); v.pageIndex != null && oS(Il, { position: v.contentPosition }, It ? i : false); this._updatePageInfoView(i, v); return Ir }, _pageGo: function (m, i, e) { var k = this._getPageInfo(i)[m]; k != null && e.dispatchAction({ type: "legendScroll", scrollDataIndex: k, legendId: i.id }) }, _updatePageInfoView: function (k, i) { var v2 = this._controllerGroup; o9(["pagePrev", "pageNext"], function (v3) { var Ik = i[v3 + "DataIndex"] != null; var Ij = v2.childOfName(v3); if (Ij) { Ij.setStyle("fill", Ik ? k.get("pageIconColor", true) : k.get("pageIconInactiveColor", true)); Ij.cursor = Ik ? "pointer" : "default" } }); var v = v2.childOfName("pageText"); var v1 = k.get("pageFormatter"); var e = i.pageIndex; var Z = e != null ? e + 1 : 0; var m = i.pageCount; v && v1 && v.setStyle("text", wb(v1) ? v1.replace("{current}", Z).replace("{total}", m) : v1({ current: Z, total: m })) }, _getPageInfo: function (i) {
      var Iq = i.get("scrollDataIndex", true); var Ik = this.getContentGroup(); var Ir = Ik.getBoundingRect(); var e = this._containerGroup.__rectSize; var Im = i.getOrient().index; var v3 = dJ[Im]; var Iv = dJ[1 - Im]; var v1 = cT[Im]; var Il = Ik.position.slice(); var Io; var In; var k; var Is; if (this._showController) { Ik.eachChild(function (Ix) { if (Ix.__legendDataIndex === Iq) { Is = Ix } }) } else { Is = Ik.childAt(0) } var Ip = e ? Math.ceil(Ir[v3] / e) : 0; if (Is) {
        var Iw = Is.getBoundingRect(); var v2 = Is.position[Im] + Iw[v1]; Il[Im] = -v2 - Ir[v1]; Io = Math.floor(Ip * (v2 + Iw[v1] + e / 2) / Ir[v3]); Io = (Ir[v3] && Ip) ? Math.max(0, Math.min(Ip - 1, Io)) : -1; var Iu = { x: 0, y: 0 }; Iu[v3] = e; Iu[Iv] = Ir[Iv]; Iu[v1] = -Il[Im] - Ir[v1]; var Z; var v = Ik.children(); Ik.eachChild(function (Iz, Ix) { var Iy = It(Iz); if (Iy.intersect(Iu)) { Z == null && (Z = Ix); k = Iz.__legendDataIndex } if (Ix === v.length - 1 && Iy[v1] + Iy[v3] <= Iu[v1] + Iu[v3]) { k = null } }); if (Z != null) {
          var m = v[Z]; var Ij = It(m); Iu[v1] = Ij[v1] + Ij[v3] - Iu[v3]; if (Z <= 0 && Ij[v1] >= Iu[v1]) { In = null } else {
            while (Z > 0 && It(v[Z - 1]).intersect(Iu)) {
              Z--
            } In = v[Z].__legendDataIndex
          }
        }
      } return { contentPosition: Il, pageIndex: Io, pageCount: Ip, pagePrevDataIndex: In, pageNextDataIndex: k }; function It(Ix) { var Iy = Ix.getBoundingRect().clone(); Iy[v1] += Ix.position[Im]; return Iy }
    }
  }); b1("legendScroll", "legendscroll", function (k, e) { var i = k.scrollDataIndex; i != null && e.eachComponent({ mainType: "legend", subType: "scroll", query: k }, function (m) { m.setScrollDataIndex(i) }) }); p2({ type: "tooltip", dependencies: ["axisPointer"], defaultOption: { zlevel: 0, z: 8, show: true, showContent: true, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: false, displayMode: "single", renderMode: "auto", confine: false, showDelay: 0, hideDelay: 100, transitionDuration: 0.4, enterable: false, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#fff", fontSize: 14 } } }); var tQ = o9; var iV = re; var qm = ["", "-webkit-", "-moz-", "-o-"]; var by = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;"; function mJ(k) { var i = "cubic-bezier(0.23, 1, 0.32, 1)"; var e = "left " + k + "s " + i + "," + "top " + k + "s " + i; return Ef(qm, function (m) { return m + "transition:" + e }).join(";") } function BF(i) { var k = []; var m = i.get("fontSize"); var e = i.getTextColor(); e && k.push("color:" + e); k.push("font:" + i.getFont()); m && k.push("line-height:" + Math.round(m * 3 / 2) + "px"); tQ(["decoration", "align"], function (v) { var Z = i.get(v); Z && k.push("text-" + v + ":" + Z) }); return k.join(";") } function m6(v) { var m = []; var e = v.get("transitionDuration"); var i = v.get("backgroundColor"); var k = v.getModel("textStyle"); var Z = v.get("padding"); e && m.push(mJ(e)); if (i) { if (sW.canvasSupported) { m.push("background-Color:" + i) } else { m.push("background-Color:#" + zf(i)); m.push("filter:alpha(opacity=70)") } } tQ(["width", "color", "radius"], function (v2) { var v1 = "border-" + v2; var v3 = iV(v1); var Ij = v.get(v3); Ij != null && m.push(v1 + ":" + Ij + (v2 === "color" ? "" : "px")) }); m.push(BF(k)); if (Z != null) { m.push("padding:" + Bj(Z).join("px ") + "px") } return m.join(";") + ";" } function t(e, m) { if (sW.wxa) { return null } var k = document.createElement("div"); var v = this._zr = m.getZr(); this.el = k; this._x = m.getWidth() / 2; this._y = m.getHeight() / 2; e.appendChild(k); this._container = e; this._show = false; this._hideTimeout; var i = this; k.onmouseenter = function () { if (i._enterable) { clearTimeout(i._hideTimeout); i._show = true } i._inContent = true }; k.onmousemove = function (v1) { v1 = v1 || window.event; if (!i._enterable) { var Z = v.handler; Bc(e, v1, true); Z.dispatch("mousemove", v1) } }; k.onmouseleave = function () { if (i._enterable) { if (i._show) { i.hideLater(i._hideDelay) } } i._inContent = false } } t.prototype = { constructor: t, _enterable: true, update: function () { var e = this._container; var k = e.currentStyle || document.defaultView.getComputedStyle(e); var i = e.style; if (i.position !== "absolute" && k.position !== "absolute") { i.position = "relative" } }, show: function (i) { clearTimeout(this._hideTimeout); var e = this.el; e.style.cssText = by + m6(i) + ";left:" + this._x + "px;top:" + this._y + "px;" + (i.get("extraCssText") || ""); e.style.display = e.innerHTML ? "block" : "none"; e.style.pointerEvents = this._enterable ? "auto" : "none"; this._show = true }, setContent: function (e) { this.el.innerHTML = e == null ? "" : e }, setEnterable: function (e) { this._enterable = e }, getSize: function () { var e = this.el; return [e.clientWidth, e.clientHeight] }, moveTo: function (e, v) { var m = this._zr; var i; if (m && m.painter && (i = m.painter.getViewportRootOffset())) { e += i.offsetLeft; v += i.offsetTop } var k = this.el.style; k.left = e + "px"; k.top = v + "px"; this._x = e; this._y = v }, hide: function () { this.el.style.display = "none"; this._show = false }, hideLater: function (e) { if (this._show && !(this._inContent && this._enterable)) { if (e) { this._hideDelay = e; this._show = false; this._hideTimeout = setTimeout(km(this.hide, this), e) } else { this.hide() } } }, isShow: function () { return this._show }, getOuterSize: function () { var k = this.el.clientWidth; var e = this.el.clientHeight; if (document.defaultView && document.defaultView.getComputedStyle) { var i = document.defaultView.getComputedStyle(this.el); if (i) { k += parseInt(i.paddingLeft, 10) + parseInt(i.paddingRight, 10) + parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10); e += parseInt(i.paddingTop, 10) + parseInt(i.paddingBottom, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10) } } return { width: k, height: e } } }; function DJ(e) { var i = this._zr = e.getZr(); this._show = false; this._hideTimeout } DJ.prototype = {
    constructor: DJ, _enterable: true, update: function () { }, show: function (e) { if (this._hideTimeout) { clearTimeout(this._hideTimeout) } this.el.attr("show", true); this._show = true }, setContent: function (Z, v2, v1) {
      if (this.el) { this._zr.remove(this.el) } var i = {}; var v3 = Z; var v = "{marker"; var Ij = "|}"; var k = v3.indexOf(v); while (k >= 0) {
        var m = v3.indexOf(Ij); var e = v3.substr(k + v.length, m - k - v.length); if (e.indexOf("sub") > -1) { i["marker" + e] = { textWidth: 4, textHeight: 4, textBorderRadius: 2, textBackgroundColor: v2[e], textOffset: [3, 0] } } else {
          i["marker" + e] = { textWidth: 10, textHeight: 10, textBorderRadius: 5, textBackgroundColor: v2[e] }
        } v3 = v3.substr(m + 1); k = v3.indexOf("{marker")
      } this.el = new iR({ style: { rich: i, text: Z, textLineHeight: 20, textBackgroundColor: v1.get("backgroundColor"), textBorderRadius: v1.get("borderRadius"), textFill: v1.get("textStyle.color"), textPadding: v1.get("padding") }, z: v1.get("z") }); this._zr.add(this.el); var Ik = this; this.el.on("mouseover", function () { if (Ik._enterable) { clearTimeout(Ik._hideTimeout); Ik._show = true } Ik._inContent = true }); this.el.on("mouseout", function () { if (Ik._enterable) { if (Ik._show) { Ik.hideLater(Ik._hideDelay) } } Ik._inContent = false })
    }, setEnterable: function (e) { this._enterable = e }, getSize: function () { var e = this.el.getBoundingRect(); return [e.width, e.height] }, moveTo: function (e, i) { if (this.el) { this.el.attr("position", [e, i]) } }, hide: function () { this.el.hide(); this._show = false }, hideLater: function (e) { if (this._show && !(this._inContent && this._enterable)) { if (e) { this._hideDelay = e; this._show = false; this._hideTimeout = setTimeout(km(this.hide, this), e) } else { this.hide() } } }, isShow: function () { return this._show }, getOuterSize: function () { return this.getSize() }
  }; var pz = km; var tR = o9; var zI = zN; var aM = new EH({ shape: { x: -1, y: -1, width: 2, height: 2 } }); qy({
    type: "tooltip", init: function (e, k) { if (sW.node) { return } var i = e.getComponent("tooltip"); var v = i.get("renderMode"); this._renderMode = wg(v); var m; if (this._renderMode === "html") { m = new t(k.getDom(), k); this._newLine = "<br/>" } else { m = new DJ(k); this._newLine = "\n" } this._tooltipContent = m }, render: function (k, e, i) { if (sW.node) { return } this.group.removeAll(); this._tooltipModel = k; this._ecModel = e; this._api = i; this._lastDataByCoordSys = null; this._alwaysShowContent = k.get("alwaysShowContent"); var m = this._tooltipContent; m.update(); m.setEnterable(k.get("enterable")); this._initGlobalListener(); this._keepShow() }, _initGlobalListener: function () { var i = this._tooltipModel; var e = i.get("triggerOn"); vW("itemTooltip", this._api, pz(function (v, m, k) { if (e !== "none") { if (e.indexOf(v) >= 0) { this._tryShow(m, k) } else { if (v === "leave") { this._hide(k) } } } }, this)) }, _keepShow: function () { var m = this._tooltipModel; var e = this._ecModel; var k = this._api; if (this._lastX != null && this._lastY != null && m.get("triggerOn") !== "none") { var i = this; clearTimeout(this._refreshUpdateTimeout); this._refreshUpdateTimeout = setTimeout(function () { i.manuallyShowTip(m, e, k, { x: i._lastX, y: i._lastY }) }) } }, manuallyShowTip: function (v3, v, Z, v2) { if (v2.from === this.uid || sW.node) { return } var m = Bx(v2, Z); this._ticket = ""; var Ij = v2.dataByCoordSys; if (v2.tooltip && v2.x != null && v2.y != null) { var e = aM; e.position = [v2.x, v2.y]; e.update(); e.tooltip = v2.tooltip; this._tryShow({ offsetX: v2.x, offsetY: v2.y, target: e }, m) } else { if (Ij) { this._tryShow({ offsetX: v2.x, offsetY: v2.y, position: v2.position, event: {}, dataByCoordSys: v2.dataByCoordSys, tooltipOption: v2.tooltipOption }, m) } else { if (v2.seriesIndex != null) { if (this._manuallyAxisShowTip(v3, v, Z, v2)) { return } var v1 = ui(v2, v); var k = v1.point[0]; var i = v1.point[1]; if (k != null && i != null) { this._tryShow({ offsetX: k, offsetY: i, position: v2.position, target: v1.el, event: {} }, m) } } else { if (v2.x != null && v2.y != null) { Z.dispatchAction({ type: "updateAxisPointer", x: v2.x, y: v2.y }); this._tryShow({ offsetX: v2.x, offsetY: v2.y, position: v2.position, target: Z.getZr().findHover(v2.x, v2.y).target, event: {} }, m) } } } } }, manuallyHideTip: function (k, e, i, v) { var m = this._tooltipContent; if (!this._alwaysShowContent && this._tooltipModel) { m.hideLater(this._tooltipModel.get("hideDelay")) } this._lastX = this._lastY = null; if (v.from !== this.uid) { this._hide(Bx(v, i)) } }, _manuallyAxisShowTip: function (v3, v, Z, v2) { var k = v2.seriesIndex; var v1 = v2.dataIndex; var e = v.getComponent("axisPointer").coordSysAxesInfo; if (k == null || v1 == null || e == null) { return } var i = v.getSeriesByIndex(k); if (!i) { return } var m = i.getData(); var v3 = Dd([m.getItemModel(v1), i, (i.coordinateSystem || {}).model, v3]); if (v3.get("trigger") !== "axis") { return } Z.dispatchAction({ type: "updateAxisPointer", seriesIndex: k, dataIndex: v1, position: v2.position }); return true }, _tryShow: function (Z, v) { var k = Z.target; var i = this._tooltipModel; if (!i) { return } this._lastX = Z.offsetX; this._lastY = Z.offsetY; var m = Z.dataByCoordSys; if (m && m.length) { this._showAxisTooltip(m, Z) } else { if (k && k.dataIndex != null) { this._lastDataByCoordSys = null; this._showSeriesItemTooltip(Z, k, v) } else { if (k && k.tooltip) { this._lastDataByCoordSys = null; this._showComponentItemTooltip(Z, k, v) } else { this._lastDataByCoordSys = null; this._hide(v) } } } }, _showOrMove: function (k, e) { var i = k.get("showDelay"); e = km(e, this); clearTimeout(this._showTimout); i > 0 ? (this._showTimout = setTimeout(e, i)) : e() }, _showAxisTooltip: function (Ij, Z) {
      var m = this._ecModel; var Im = this._tooltipModel; var v3 = [Z.offsetX, Z.offsetY]; var i = []; var v2 = []; var Il = Dd([Z.tooltipOption, Im]); var Ik = this._renderMode; var v = this._newLine; var k = {}; tR(Ij, function (e) {
        tR(e.dataByAxis, function (Iq) {
          var Ip = m.getComponent(Iq.axisDim + "Axis", Iq.axisIndex); var Ir = Iq.value; var Io = []; if (!Ip || Ir == null) { return } var Is = sG(Ir, Ip.axis, m, Iq.seriesDataIndices, Iq.valueLabelOpt); o9(Iq.seriesDataIndices, function (Iz) {
            var Ix = m.getSeriesByIndex(Iz.seriesIndex); var Iw = Iz.dataIndexInside; var It = Ix && Ix.getDataParams(Iw); It.axisDim = Iq.axisDim; It.axisIndex = Iq.axisIndex; It.axisType = Iq.axisType;
            It.axisId = Iq.axisId; It.axisValue = nV(Ip.axis, Ir); It.axisValueLabel = Is; if (It) { v2.push(It); var Iy = Ix.formatTooltip(Iw, true, null, Ik); var Iv; if (tJ(Iy)) { Iv = Iy.html; var Iu = Iy.markers; v4(k, Iu) } else { Iv = Iy } Io.push(Iv) }
          }); var In = Is; if (Ik !== "html") { i.push(Io.join(v)) } else { i.push((In ? mv(In) + v : "") + Io.join(v)) }
        })
      }, this); i.reverse(); i = i.join(this._newLine + this._newLine); var v1 = Z.position; this._showOrMove(Il, function () { if (this._updateContentNotChangedOnAxis(Ij)) { this._updatePosition(Il, v1, v3[0], v3[1], this._tooltipContent, v2) } else { this._showTooltipContent(Il, i, v2, Math.random(), v3[0], v3[1], v1, undefined, k) } })
    }, _showSeriesItemTooltip: function (Il, k, v1) { var Ik = this._ecModel; var v3 = k.seriesIndex; var v = Ik.getSeriesByIndex(v3); var Im = k.dataModel || v; var Ip = k.dataIndex; var Io = k.dataType; var Ij = Im.getData(); var Iq = Dd([Ij.getItemModel(Ip), Im, v && (v.coordinateSystem || {}).model, this._tooltipModel]); var In = Iq.get("trigger"); if (In != null && In !== "item") { return } var Z = Im.getDataParams(Ip, Io); var i = Im.formatTooltip(Ip, false, Io, this._renderMode); var m; var v2; if (tJ(i)) { m = i.html; v2 = i.markers } else { m = i; v2 = null } var Ir = "item_" + Im.name + "_" + Ip; this._showOrMove(Iq, function () { this._showTooltipContent(Iq, m, Z, Ir, Il.offsetX, Il.offsetY, Il.position, Il.target, v2) }); v1({ type: "showTip", dataIndexInside: Ip, dataIndex: Ij.getRawIndex(Ip), seriesIndex: v3, from: this.uid }) }, _showComponentItemTooltip: function (v2, k, v1) { var i = k.tooltip; if (typeof i === "string") { var v = i; i = { content: v, formatter: v } } var Z = new fv(i, this._tooltipModel, this._ecModel); var v3 = Z.get("content"); var m = Math.random(); this._showOrMove(Z, function () { this._showTooltipContent(Z, v3, Z.get("formatterParams") || {}, m, v2.offsetX, v2.offsetY, v2.position, k) }); v1({ type: "showTip", from: this.uid }) }, _showTooltipContent: function (Ij, i, k, Im, v2, v1, Z, e, m) { this._ticket = ""; if (!Ij.get("showContent") || !Ij.get("show")) { return } var Ik = this._tooltipContent; var v3 = Ij.get("formatter"); Z = Z || Ij.get("position"); var v = i; if (v3 && typeof v3 === "string") { v = ew(v3, k, true) } else { if (typeof v3 === "function") { var Il = pz(function (Io, In) { if (Io === this._ticket) { Ik.setContent(In, m, Ij); this._updatePosition(Ij, Z, v2, v1, Ik, k, e) } }, this); this._ticket = Im; v = v3(k, Im, Il) } } Ik.setContent(v, m, Ij); Ik.show(Ij); this._updatePosition(Ij, Z, v2, v1, Ik, k, e) }, _updatePosition: function (Io, v3, Im, Il, v2, m, i) { var v = this._api.getWidth(); var k = this._api.getHeight(); v3 = v3 || Io.get("position"); var e = v2.getSize(); var v1 = Io.get("align"); var Z = Io.get("verticalAlign"); var Ik = i && i.getBoundingRect().clone(); i && Ik.applyTransform(i.transform); if (typeof v3 === "function") { v3 = v3([Im, Il], m, v2.el, Ik, { viewSize: [v, k], contentSize: e.slice() }) } if (GG(v3)) { Im = zI(v3[0], v); Il = zI(v3[1], k) } else { if (tJ(v3)) { v3.width = e[0]; v3.height = e[1]; var In = kV(v3, { width: v, height: k }); Im = In.x; Il = In.y; v1 = null; Z = null } else { if (typeof v3 === "string" && i) { var Ij = B(v3, Ik, e); Im = Ij[0]; Il = Ij[1] } else { var Ij = dr(Im, Il, v2, v, k, v1 ? null : 20, Z ? null : 20); Im = Ij[0]; Il = Ij[1] } } } v1 && (Im -= C3(v1) ? e[0] / 2 : v1 === "right" ? e[0] : 0); Z && (Il -= C3(Z) ? e[1] / 2 : Z === "bottom" ? e[1] : 0); if (Io.get("confine")) { var Ij = nt(Im, Il, v2, v, k); Im = Ij[0]; Il = Ij[1] } v2.moveTo(Im, Il) }, _updateContentNotChangedOnAxis: function (k) { var i = this._lastDataByCoordSys; var e = !!i && i.length === k.length; e && tR(i, function (v1, Z) { var v = v1.dataByAxis || {}; var m = k[Z] || {}; var v2 = m.dataByAxis || []; e &= v.length === v2.length; e && tR(v, function (Im, v3) { var Ik = v2[v3] || {}; var Ij = Im.seriesDataIndices || []; var Il = Ik.seriesDataIndices || []; e &= Im.value === Ik.value && Im.axisType === Ik.axisType && Im.axisId === Ik.axisId && Ij.length === Il.length; e && tR(Ij, function (Io, In) { var Ip = Il[In]; e &= Io.seriesIndex === Ip.seriesIndex && Io.dataIndex === Ip.dataIndex }) }) }); this._lastDataByCoordSys = k; return !!e }, _hide: function (e) { this._lastDataByCoordSys = null; e({ type: "hideTip", from: this.uid }) }, dispose: function (e, i) { if (sW.node) { return } this._tooltipContent.hide(); ae("itemTooltip", i) }
  }); function Dd(k) { var e = k.pop(); while (k.length) { var i = k.pop(); if (i) { if (fv.isInstance(i)) { i = i.get("tooltip", true) } if (typeof i === "string") { i = { formatter: i } } e = new fv(i, e, e.ecModel) } } return e } function Bx(i, e) { return i.dispatchAction || km(e.dispatchAction, e) } function dr(v2, v1, Z, m, k, i, v) { var Ij = Z.getOuterSize(); var e = Ij.width; var v3 = Ij.height; if (i != null) { if (v2 + e + i > m) { v2 -= e + i } else { v2 += i } } if (v != null) { if (v1 + v3 + v > k) { v1 -= v3 + v } else { v1 += v } } return [v2, v1] } function nt(i, v2, v1, Z, k) { var m = v1.getOuterSize(); var v = m.width; var e = m.height; i = Math.min(i + v, Z) - v; v2 = Math.min(v2 + e, k) - e; i = Math.max(i, 0); v2 = Math.max(v2, 0); return [i, v2] } function B(m, v2, e) { var v = e[0]; var k = e[1]; var v3 = 5; var Ij = 0; var v1 = 0; var i = v2.width; var Z = v2.height; switch (m) { case "inside": Ij = v2.x + i / 2 - v / 2; v1 = v2.y + Z / 2 - k / 2; break; case "top": Ij = v2.x + i / 2 - v / 2; v1 = v2.y - k - v3; break; case "bottom": Ij = v2.x + i / 2 - v / 2; v1 = v2.y + Z + v3; break; case "left": Ij = v2.x - v - v3; v1 = v2.y + Z / 2 - k / 2; break; case "right": Ij = v2.x + i + v3; v1 = v2.y + Z / 2 - k / 2 }return [Ij, v1] } function C3(e) { return e === "center" || e === "middle" } b1({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, function () { }); b1({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, function () { }); function pf(e) {
    return e.get("stack") || "__ec_stack_" + e.seriesIndex
  } function xD(e) { return e.dim } function y3(k, i, v) { var m = v.getWidth(); var e = v.getHeight(); var v1 = {}; var Z = BU(q4(i.getSeriesByType(k), function (v2) { return !i.isSeriesFiltered(v2) && v2.coordinateSystem && v2.coordinateSystem.type === "polar" })); i.eachSeriesByType(k, function (Iv) { if (Iv.coordinateSystem.type !== "polar") { return } var IK = Iv.getData(); var IL = Iv.coordinateSystem; var Iq = IL.getBaseAxis(); var Io = pf(Iv); var Ir = Z[xD(Iq)][Io]; var Ip = Ir.offset; var In = Ir.width; var ID = IL.getOtherAxis(Iq); var IH = Iv.get("center") || ["50%", "50%"]; var Ij = zN(IH[0], m); var v3 = zN(IH[1], e); var v2 = Iv.get("barMinHeight") || 0; var Iy = Iv.get("barMinAngle") || 0; v1[Io] = v1[Io] || []; var Ik = IK.mapDimension(ID.dim); var Iu = IK.mapDimension(Iq.dim); var IF = lU(IK, Ik); var Im = ID.getExtent()[0]; for (var It = 0, IC = IK.count(); It < IC; It++) { var Ix = IK.get(Ik, It); var IG = IK.get(Iu, It); if (isNaN(Ix)) { continue } var IJ = Ix >= 0 ? "p" : "n"; var II = Im; if (IF) { if (!v1[Io][IG]) { v1[Io][IG] = { p: Im, n: Im } } II = v1[Io][IG][IJ] } var IB; var Is; var Iz; var Iw; if (ID.dim === "radius") { var IA = ID.dataToRadius(Ix) - Im; var IE = Iq.dataToAngle(IG); if (Math.abs(IA) < v2) { IA = (IA < 0 ? -1 : 1) * v2 } IB = II; Is = II + IA; Iz = IE - Ip; Iw = Iz - In; IF && (v1[Io][IG][IJ] = Is) } else { var IM = ID.dataToAngle(Ix, true) - Im; var Il = Iq.dataToRadius(IG); if (Math.abs(IM) < Iy) { IM = (IM < 0 ? -1 : 1) * Iy } IB = Il + Ip; Is = IB + In; Iz = II; Iw = II + IM; IF && (v1[Io][IG][IJ] = Iw) } IK.setItemLayout(It, { cx: Ij, cy: v3, r0: IB, r: Is, startAngle: -Iz * Math.PI / 180, endAngle: -Iw * Math.PI / 180 }) } }, this) } function BU(i, m) { var k = {}; o9(i, function (Ik, Ip) { var In = Ik.getData(); var Z = Ik.coordinateSystem; var v2 = Z.getBaseAxis(); var Ij = v2.getExtent(); var Im = v2.type === "category" ? v2.getBandWidth() : (Math.abs(Ij[1] - Ij[0]) / In.count()); var Ir = k[xD(v2)] || { bandWidth: Im, remainedWidth: Im, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }; var v1 = Ir.stacks; k[xD(v2)] = Ir; var Il = pf(Ik); if (!v1[Il]) { Ir.autoWidthCount++ } v1[Il] = v1[Il] || { width: 0, maxWidth: 0 }; var Iq = zN(Ik.get("barWidth"), Im); var v = zN(Ik.get("barMaxWidth"), Im); var Io = Ik.get("barGap"); var v3 = Ik.get("barCategoryGap"); if (Iq && !v1[Il].width) { Iq = Math.min(Ir.remainedWidth, Iq); v1[Il].width = Iq; Ir.remainedWidth -= Iq } v && (v1[Il].maxWidth = v); (Io != null) && (Ir.gap = Io); (v3 != null) && (Ir.categoryGap = v3) }); var e = {}; o9(k, function (Ip, v1) { e[v1] = {}; var v = Ip.stacks; var v3 = Ip.bandWidth; var Z = zN(Ip.categoryGap, v3); var Im = zN(Ip.gap, 1); var v2 = Ip.remainedWidth; var In = Ip.autoWidthCount; var Il = (v2 - Z) / (In + (In - 1) * Im); Il = Math.max(Il, 0); o9(v, function (Ir, Iq) { var Is = Ir.maxWidth; if (Is && Is < Il) { Is = Math.min(Is, v2); if (Ir.width) { Is = Math.min(Is, Ir.width) } v2 -= Is; Ir.width = Is; In-- } }); Il = (v2 - Z) / (In + (In - 1) * Im); Il = Math.max(Il, 0); var Ik = 0; var Io; o9(v, function (Ir, Iq) { if (!Ir.width) { Ir.width = Il } Io = Ir; Ik += Ir.width * (1 + Im) }); if (Io) { Ik -= Io.width * Im } var Ij = -Ik / 2; o9(v, function (Ir, Iq) { e[v1][Iq] = e[v1][Iq] || { offset: Ij, width: Ir.width }; Ij += Ir.width * (1 + Im) }) }); return e } function hq(i, e) { BS.call(this, "radius", i, e); this.type = "category" } hq.prototype = { constructor: hq, pointToData: function (e, i) { return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1] }, dataToRadius: BS.prototype.dataToCoord, radiusToData: BS.prototype.coordToData }; mr(hq, BS); function bb(i, e) { e = e || [0, 360]; BS.call(this, "angle", i, e); this.type = "category" } bb.prototype = { constructor: bb, pointToData: function (e, i) { return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1] }, dataToAngle: BS.prototype.dataToCoord, angleToData: BS.prototype.coordToData }; mr(bb, BS); var sm = function (e) { this.name = e || ""; this.cx = 0; this.cy = 0; this._radiusAxis = new hq(); this._angleAxis = new bb(); this._radiusAxis.polar = this._angleAxis.polar = this }; sm.prototype = {
    type: "polar", axisPointerEnabled: true, constructor: sm, dimensions: ["radius", "angle"], model: null, containPoint: function (e) { var i = this.pointToCoord(e); return this._radiusAxis.contain(i[0]) && this._angleAxis.contain(i[1]) }, containData: function (e) { return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]) }, getAxis: function (e) { return this["_" + e + "Axis"] }, getAxes: function () { return [this._radiusAxis, this._angleAxis] }, getAxesByScale: function (e) { var m = []; var i = this._angleAxis; var k = this._radiusAxis; i.scale.type === e && m.push(i); k.scale.type === e && m.push(k); return m }, getAngleAxis: function () { return this._angleAxis }, getRadiusAxis: function () { return this._radiusAxis }, getOtherAxis: function (i) { var e = this._angleAxis; return i === e ? this._radiusAxis : e }, getBaseAxis: function () { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis() }, getTooltipAxes: function (i) { var e = (i != null && i !== "auto") ? this.getAxis(i) : this.getBaseAxis(); return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] } }, dataToPoint: function (e, i) { return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], i), this._angleAxis.dataToAngle(e[1], i)]) }, pointToData: function (e, i) { var k = this.pointToCoord(e); return [this._radiusAxis.radiusToData(k[0], i), this._angleAxis.angleToData(k[1], i)] }, pointToCoord: function (Z) {
      var Ij = Z[0] - this.cx; var v2 = Z[1] - this.cy; var v3 = this.getAngleAxis(); var v1 = v3.getExtent(); var k = Math.min(v1[0], v1[1]); var e = Math.max(v1[0], v1[1]); v3.inverse ? (k = e - 360) : (e = k + 360); var m = Math.sqrt(Ij * Ij + v2 * v2); Ij /= m;
      v2 /= m; var v = Math.atan2(-v2, Ij) / Math.PI * 180; var i = v < k ? 1 : -1; while (v < k || v > e) { v += i * 360 } return [m, v]
    }, coordToPoint: function (v) { var i = v[0]; var k = v[1] / 180 * Math.PI; var e = Math.cos(k) * i + this.cx; var m = -Math.sin(k) * i + this.cy; return [e, m] }
  }; var ap = aH.extend({ type: "polarAxis", axis: null, getCoordSysModel: function () { return this.ecModel.queryComponents({ mainType: "polar", index: this.option.polarIndex, id: this.option.polarId })[0] } }); v4(ap.prototype, nB); var dp = { angle: { startAngle: 90, clockwise: true, splitNumber: 12, axisLabel: { rotate: false } }, radius: { splitNumber: 5 } }; function sa(i, e) { return e.type || (e.data ? "category" : "value") } mR("angle", ap, sa, dp.angle); mR("radius", ap, sa, dp.radius); p2({ type: "polar", dependencies: ["polarAxis", "angleAxis"], coordinateSystem: null, findAxisModel: function (i) { var k; var e = this.ecModel; e.eachComponent(i, function (m) { if (m.getCoordSysModel() === this) { k = m } }, this); return k }, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%" } }); function wu(i, v, v1) { var e = v.get("center"); var k = v1.getWidth(); var v2 = v1.getHeight(); i.cx = zN(e[0], k); i.cy = zN(e[1], v2); var m = i.getRadiusAxis(); var v3 = Math.min(k, v2) / 2; var Z = zN(v.get("radius"), v3); m.inverse ? m.setExtent(Z, 0) : m.setExtent(0, Z) } function Ce(e, m) { var v1 = this; var i = v1.getAngleAxis(); var v = v1.getRadiusAxis(); i.scale.setExtent(Infinity, -Infinity); v.scale.setExtent(Infinity, -Infinity); e.eachSeries(function (v2) { if (v2.coordinateSystem === v1) { var v3 = v2.getData(); o9(v3.mapDimension("radius", true), function (Ij) { v.scale.unionExtentFromData(v3, jB(v3, Ij)) }); o9(v3.mapDimension("angle", true), function (Ij) { i.scale.unionExtentFromData(v3, jB(v3, Ij)) }) } }); nL(i.scale, i.model); nL(v.scale, v.model); if (i.type === "category" && !i.onBand) { var k = i.getExtent(); var Z = 360 / i.scale.count(); i.inverse ? (k[1] += Z) : (k[1] -= Z); i.setExtent(k[0], k[1]) } } function mO(k, i) { k.type = i.get("type"); k.scale = nq(i); k.onBand = i.get("boundaryGap") && k.type === "category"; k.inverse = i.get("inverse"); if (i.mainType === "angleAxis") { k.inverse ^= i.get("clockwise"); var e = i.get("startAngle"); k.setExtent(e, e + (k.inverse ? -360 : 360)) } i.axis = k; k.model = i } var w4 = { dimensions: sm.prototype.dimensions, create: function (e, i) { var k = []; e.eachComponent("polar", function (v1, m) { var Ij = new sm(m); Ij.update = Ce; var v3 = Ij.getRadiusAxis(); var Z = Ij.getAngleAxis(); var v2 = v1.findAxisModel("radiusAxis"); var v = v1.findAxisModel("angleAxis"); mO(v3, v2); mO(Z, v); wu(Ij, v1, i); k.push(Ij); v1.coordinateSystem = Ij; Ij.model = v1 }); e.eachSeries(function (m) { if (m.get("coordinateSystem") === "polar") { var v = e.queryComponents({ mainType: "polar", index: m.get("polarIndex"), id: m.get("polarId") })[0]; if (ok) { if (!v) { throw new Error('Polar "' + gu(m.get("polarIndex"), m.get("polarId"), 0) + '" not found') } } m.coordinateSystem = v.coordinateSystem } }); return k } }; fz.register("polar", w4); var CV = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"]; function cL(k, i, m) { i[1] > i[0] && (i = i.slice().reverse()); var v = k.coordToPoint([i[0], m]); var e = k.coordToPoint([i[1], m]); return { x1: v[0], y1: v[1], x2: e[0], y2: e[1] } } function yj(i) { var e = i.getRadiusAxis(); return e.inverse ? 0 : 1 } function e4(i) { var k = i[0]; var e = i[i.length - 1]; if (k && e && Math.abs(Math.abs(k.coord - e.coord) - 360) < 0.0001) { i.pop() } } f2.extend({
    type: "angleAxis", axisPointerClass: "PolarAxisPointer", render: function (m, e) { this.group.removeAll(); if (!m.get("show")) { return } var k = m.axis; var Z = k.polar; var v = Z.getRadiusAxis().getExtent(); var i = k.getTicksCoords(); var v1 = Ef(k.getViewLabels(), function (v2) { var v2 = C5(v2); v2.coord = k.dataToCoord(v2.tickValue); return v2 }); e4(v1); e4(i); o9(CV, function (v2) { if (m.get(v2 + ".show") && (!k.scale.isBlank() || v2 === "axisLine")) { this["_" + v2](m, Z, i, v, v1) } }, this) }, _axisLine: function (i, Z, e, v) { var m = i.getModel("axisLine.lineStyle"); var k = new GI({ shape: { cx: Z.cx, cy: Z.cy, r: v[yj(Z)] }, style: m.getLineStyle(), z2: 1, silent: true }); k.style.fill = null; this.group.add(k) }, _axisTick: function (m, Z, k, v) { var v1 = m.getModel("axisTick"); var v2 = (v1.get("inside") ? -1 : 1) * v1.get("length"); var e = v[yj(Z)]; var i = Ef(k, function (v3) { return new zB({ shape: cL(Z, [e, e + v2], v3.coord) }) }); this.group.add(q8(i, { style: De(v1.getModel("lineStyle").getLineStyle(), { stroke: m.get("axisLine.lineStyle.color") }) })) }, _axisLabel: function (i, v1, e, Z, v2) { var k = i.getCategories(true); var v = i.getModel("axisLabel"); var m = v.get("margin"); o9(v2, function (Il, Io) { var Is = v; var Im = Il.tickValue; var v3 = Z[yj(v1)]; var Ij = v1.coordToPoint([v3 + m, Il.coord]); var In = v1.cx; var Ik = v1.cy; var Ip = Math.abs(Ij[0] - In) / v3 < 0.3 ? "center" : (Ij[0] > In ? "left" : "right"); var Ir = Math.abs(Ij[1] - Ik) / v3 < 0.3 ? "middle" : (Ij[1] > Ik ? "top" : "bottom"); if (k && k[Im] && k[Im].textStyle) { Is = new fv(k[Im].textStyle, v, v.ecModel) } var Iq = new iR({ silent: true }); this.group.add(Iq); pe(Iq.style, Is, { x: Ij[0], y: Ij[1], textFill: Is.getTextColor() || i.get("axisLine.lineStyle.color"), text: Il.formattedLabel, textAlign: Ip, textVerticalAlign: Ir }) }, this) }, _splitLine: function (k, e, v2, Z) {
      var m = k.getModel("splitLine"); var v3 = m.getModel("lineStyle"); var Ik = v3.get("color"); var Il = 0; Ik = Ik instanceof Array ? Ik : [Ik]; var v1 = []; for (var v = 0; v < v2.length; v++) {
        var Ij = (Il++) % Ik.length; v1[Ij] = v1[Ij] || []; v1[Ij].push(new zB({ shape: cL(e, Z, v2[v].coord) }))
      } for (var v = 0; v < v1.length; v++) { this.group.add(q8(v1[v], { style: De({ stroke: Ik[v % Ik.length] }, v3.getLineStyle()), silent: true, z: k.get("z") })) }
    }, _splitArea: function (v, m, Ik, v3) { if (!Ik.length) { return } var Im = v.getModel("splitArea"); var Io = Im.getModel("areaStyle"); var Ip = Io.get("color"); var Iq = 0; Ip = Ip instanceof Array ? Ip : [Ip]; var Ij = []; var Il = Math.PI / 180; var e = -Ik[0].coord * Il; var v1 = Math.min(v3[0], v3[1]); var Z = Math.max(v3[0], v3[1]); var k = v.get("clockwise"); for (var v2 = 1; v2 < Ik.length; v2++) { var In = (Iq++) % Ip.length; Ij[In] = Ij[In] || []; Ij[In].push(new tx({ shape: { cx: m.cx, cy: m.cy, r0: v1, r: Z, startAngle: e, endAngle: -Ik[v2].coord * Il, clockwise: k }, silent: true })); e = -Ik[v2].coord * Il } for (var v2 = 0; v2 < Ij.length; v2++) { this.group.add(q8(Ij[v2], { style: De({ fill: Ip[v2 % Ip.length] }, Io.getAreaStyle()), silent: true })) } }
  }); var EP = ["axisLine", "axisTickLabel", "axisName"]; var iz = ["splitLine", "splitArea"]; f2.extend({ type: "radiusAxis", axisPointerClass: "PolarAxisPointer", render: function (v2, v) { this.group.removeAll(); if (!v2.get("show")) { return } var i = v2.axis; var e = i.polar; var Ij = e.getAngleAxis(); var v3 = i.getTicksCoords(); var v1 = Ij.getExtent()[0]; var k = i.getExtent(); var m = lg(e, v2, v1); var Z = new da(v2, m); o9(EP, Z.add, Z); this.group.add(Z.getGroup()); o9(iz, function (Ik) { if (v2.get(Ik + ".show") && !i.scale.isBlank()) { this["_" + Ik](v2, e, v1, k, v3) } }, this) }, _splitLine: function (v2, e, v1, v, Ij) { var k = v2.getModel("splitLine"); var v3 = k.getModel("lineStyle"); var Im = v3.get("color"); var Il = 0; Im = Im instanceof Array ? Im : [Im]; var Z = []; for (var m = 0; m < Ij.length; m++) { var Ik = (Il++) % Im.length; Z[Ik] = Z[Ik] || []; Z[Ik].push(new GI({ shape: { cx: e.cx, cy: e.cy, r: Ij[m].coord }, silent: true })) } for (var m = 0; m < Z.length; m++) { this.group.add(q8(Z[m], { style: De({ stroke: Im[m % Im.length], fill: null }, v3.getLineStyle()), silent: true })) } }, _splitArea: function (v1, e, Z, m, v3) { if (!v3.length) { return } var v2 = v1.getModel("splitArea"); var Ik = v2.getModel("areaStyle"); var Im = Ik.get("color"); var In = 0; Im = Im instanceof Array ? Im : [Im]; var v = []; var Il = v3[0].coord; for (var k = 1; k < v3.length; k++) { var Ij = (In++) % Im.length; v[Ij] = v[Ij] || []; v[Ij].push(new tx({ shape: { cx: e.cx, cy: e.cy, r0: Il, r: v3[k].coord, startAngle: 0, endAngle: Math.PI * 2 }, silent: true })); Il = v3[k].coord } for (var k = 0; k < v.length; k++) { this.group.add(q8(v[k], { style: De({ fill: Im[k % Im.length] }, Ik.getAreaStyle()), silent: true })) } } }); function lg(i, e, k) { return { position: [i.cx, i.cy], rotation: k / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel("axisLabel").get("rotate"), z2: 1 } } var dZ = Gp.extend({ makeElOption: function (e, Ik, Im, v2, v1) { var m = Im.axis; if (m.dim === "angle") { this.animationThreshold = Math.PI / 18 } var i = m.polar; var v = i.getOtherAxis(m); var Z = v.getExtent(); var Io; Io = m["dataTo" + tg(m.dim)](Ik); var Ij = v2.get("type"); if (Ij && Ij !== "none") { var Il = y4(v2); var In = rU[Ij](m, i, Io, Z, Il); In.style = Il; e.graphicKey = In.type; e.pointer = In } var v3 = v2.get("label.margin"); var k = m0(Ik, Im, v2, i, v3); Fr(e, Im, v2, v1, k) } }); function m0(Im, Ij, v, Ir, k) { var Z = Ij.axis; var In = Z.dataToCoord(Im); var e = Ir.getAngleAxis().getExtent()[0]; e = e / 180 * Math.PI; var v1 = Ir.getRadiusAxis().getExtent(); var Iq; var Io; var i; if (Z.dim === "radius") { var Ik = CB(); ki(Ik, Ik, e); vm(Ik, Ik, [Ir.cx, Ir.cy]); Iq = v7([In, -k], Ik); var Ip = Ij.getModel("axisLabel").get("rotate") || 0; var v3 = da.innerTextLayout(e, Ip * Math.PI / 180, -1); Io = v3.textAlign; i = v3.textVerticalAlign } else { var Il = v1[1]; Iq = Ir.coordToPoint([Il + k, In]); var v2 = Ir.cx; var m = Ir.cy; Io = Math.abs(Iq[0] - v2) / Il < 0.3 ? "center" : (Iq[0] > v2 ? "left" : "right"); i = Math.abs(Iq[1] - m) / Il < 0.3 ? "middle" : (Iq[1] > m ? "top" : "bottom") } return { position: Iq, align: Io, verticalAlign: i } } var rU = { line: function (k, m, e, v, i) { return k.dim === "angle" ? { type: "Line", shape: GE(m.coordToPoint([v[0], e]), m.coordToPoint([v[1], e])) } : { type: "Circle", shape: { cx: m.cx, cy: m.cy, r: e } } }, shadow: function (m, v, i, v1, k) { var e = Math.max(1, m.getBandWidth()); var Z = Math.PI / 180; return m.dim === "angle" ? { type: "Sector", shape: kn(v.cx, v.cy, v1[0], v1[1], (-i - e / 2) * Z, (-i + e / 2) * Z) } : { type: "Sector", shape: kn(v.cx, v.cy, i - e / 2, i + e / 2, 0, Math.PI * 2) } } }; f2.registerAxisPointerClass("PolarAxisPointer", dZ); pr(sv(y3, "bar")); qy({ type: "polar" }); var x0 = aH.extend({
    type: "geo", coordinateSystem: null, layoutMode: "box", init: function (e) { aH.prototype.init.apply(this, arguments); DA(e, "label", ["show"]) }, optionUpdated: function () { var i = this.option; var e = this; i.regions = h0.getFilledRegions(i.regions, i.map, i.nameMap); this._optionModelMap = xc(i.regions || [], function (m, k) { if (k.name) { m.set(k.name, new fv(k, e)) } return m }, CJ()); this.updateSelectedMap(i.regions) }, defaultOption: { zlevel: 0, z: 0, show: true, left: "center", top: "center", aspectScale: null, silent: false, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", color: "#eee" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, getRegionModel: function (e) { return this._optionModelMap.get(e) || new fv(null, this, this.ecModel) }, getFormattedLabel: function (i, e) {
      var m = this.getRegionModel(i); var k = m.get("label." + e + ".formatter"); var v = { name: i }; if (typeof k === "function") {
        v.status = e;
        return k(v)
      } else { if (typeof k === "string") { return k.replace("{a}", i != null ? i : "") } }
    }, setZoom: function (e) { this.option.zoom = e }, setCenter: function (e) { this.option.center = e }
  }); Gq(x0, EU); qy({ type: "geo", init: function (e, k) { var i = new Cj(k, true); this._mapDraw = i; this.group.add(i.group) }, render: function (k, e, m, v) { if (v && v.type === "geoToggleSelect" && v.from === this.uid) { return } var i = this._mapDraw; if (k.get("show")) { i.draw(k, e, m, this, v) } else { this._mapDraw.group.removeAll() } this.group.silent = k.get("silent") }, dispose: function () { this._mapDraw && this._mapDraw.remove() } }); function Cu(i, e) { e.update = "updateView"; b1(e, function (v, k) { var m = {}; k.eachComponent({ mainType: "geo", query: v }, function (Z) { Z[i](v.name); var v1 = Z.coordinateSystem; o9(v1.regions, function (v2) { m[v2.name] = Z.isSelected(v2.name) || false }) }); return { selected: m, name: v.name } }) } Cu("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }); Cu("select", { type: "geoSelect", event: "geoselected" }); Cu("unSelect", { type: "geoUnSelect", event: "geounselected" }); var vc = ["rect", "polygon", "keep", "clear"]; var HZ = function (v, e) { var m = v && v.brush; if (!GG(m)) { m = m ? [m] : [] } if (!m.length) { return } var i = []; o9(m, function (Ij) { var v3 = Ij.hasOwnProperty("toolbox") ? Ij.toolbox : []; if (v3 instanceof Array) { i = i.concat(v3) } }); var Z = v && v.toolbox; if (GG(Z)) { Z = Z[0] } if (!Z) { Z = { feature: {} }; v.toolbox = [Z] } var v1 = (Z.feature || (Z.feature = {})); var v2 = v1.brush || (v1.brush = {}); var k = v2.type || (v2.type = []); k.push.apply(k, i); lf(k); if (e && !k.length) { k.push.apply(k, vc) } }; function lf(e) { var i = {}; o9(e, function (k) { i[k] = 1 }); e.length = 0; o9(i, function (k, m) { e.push(m) }) } var tP = o9; function rf(i) { if (i) { for (var e in i) { if (i.hasOwnProperty(e)) { return true } } } } function Ab(k, e, m) { var i = {}; tP(e, function (Z) { var v1 = i[Z] = v(); tP(k[Z], function (Ij, v3) { if (!mH.isValidType(v3)) { return } var v2 = { type: v3, visual: Ij }; m && m(v2, Z); v1[v3] = new mH(v2); if (v3 === "opacity") { v2 = C5(v2); v2.type = "colorAlpha"; v1.__hidden.__alphaForOpacity = new mH(v2) } }) }); return i; function v() { var Z = function () { }; Z.prototype.__hidden = Z.prototype; var v1 = new Z(); return v1 } } function nc(i, m, k) { var e; o9(k, function (v) { if (m.hasOwnProperty(v) && rf(m[v])) { e = true } }); e && o9(k, function (v) { if (m.hasOwnProperty(v) && rf(m[v])) { i[v] = C5(m[v]) } else { delete i[v] } }) } function dx(m, Z, k, v2, Ik, i) { var v = {}; o9(m, function (Im) { var Il = mH.prepareVisualTypes(Z[Im]); v[Im] = Il }); var v3; function v1(Il) { return k.getItemVisual(v3, Il) } function Ij(Il, Im) { k.setItemVisual(v3, Il, Im) } if (i == null) { k.each(e) } else { k.each([i], e) } function e(Il, Ir) { v3 = i == null ? Il : Ir; var Io = k.getRawDataItem(v3); if (Io && Io.visualMap === false) { return } var In = v2.call(Ik, Il); var Iq = Z[In]; var Im = v[In]; for (var Ip = 0, Is = Im.length; Ip < Is; Ip++) { var It = Im[Ip]; Iq[It] && Iq[It].applyVisual(Il, v1, Ij) } } } function lm(e, i, Z, v) { var m = {}; o9(e, function (v2) { var v1 = mH.prepareVisualTypes(i[v2]); m[v2] = v1 }); function k(v3, Il) { if (v != null) { v = Il.getDimension(v) } function Io(It) { return Il.getItemVisual(Iq, It) } function Ir(It, Iu) { Il.setItemVisual(Iq, It, Iu) } var Iq; while ((Iq = v3.next()) != null) { var Ij = Il.getRawDataItem(Iq); if (Ij && Ij.visualMap === false) { return } var Is = v != null ? Il.get(v, Iq, true) : Iq; var v2 = Z(Is); var Im = i[v2]; var v1 = m[v2]; for (var Ik = 0, In = v1.length; Ik < In; Ik++) { var Ip = v1[Ik]; Im[Ip] && Im[Ip].applyVisual(Is, Io, Ir) } } } return { progress: k } } var aw = { lineX: tG(0), lineY: tG(1), rect: { point: function (i, e, k) { return i && k.boundingRect.contain(i[0], i[1]) }, rect: function (i, e, k) { return i && k.boundingRect.intersect(i) } }, polygon: { point: function (i, e, k) { return i && k.boundingRect.contain(i[0], i[1]) && EN(k.range, i[0], i[1]) }, rect: function (v2, v1, i) { var Z = i.range; if (!v2 || Z.length <= 1) { return false } var v = v2.x; var m = v2.y; var k = v2.width; var v3 = v2.height; var e = Z[0]; if (EN(Z, v, m) || EN(Z, v + k, m) || EN(Z, v, m + v3) || EN(Z, v + k, m + v3) || CH.create(v2).contain(e[0], e[1]) || s2(v, m, v + k, m, Z) || s2(v, m, v, m + v3, Z) || s2(v + k, m, v + k, m + v3, Z) || s2(v, m + v3, v + k, m + v3, Z)) { return true } } } }; function tG(k) { var i = ["x", "y"]; var e = ["width", "height"]; return { point: function (Z, v, v1) { if (Z) { var m = v1.range; var v2 = Z[k]; return eD(v2, m) } }, rect: function (Z, v, v1) { if (Z) { var m = v1.range; var v2 = [Z[i[k]], Z[i[k]] + Z[e[k]]]; v2[1] < v2[0] && v2.reverse(); return eD(v2[0], m) || eD(v2[1], m) || eD(m[0], v2) || eD(m[1], v2) } } } } function eD(i, e) { return e[0] <= i && i <= e[1] } function s2(v, m, v3, v2, k) { for (var e = 0, v1 = k[k.length - 1]; e < k.length; e++) { var Z = k[e]; if (du(v, m, v3, v2, Z[0], Z[1], v1[0], v1[1])) { return true } v1 = Z } } function du(v3, v2, v, m, e, Ik, v1, Z) { var Ij = vd(v - v3, e - v1, m - v2, Ik - Z); if (bW(Ij)) { return false } var k = vd(e - v3, e - v1, Ik - v2, Ik - Z) / Ij; if (k < 0 || k > 1) { return false } var i = vd(v - v3, e - v3, m - v2, Ik - v2) / Ij; if (i < 0 || i > 1) { return false } return true } function bW(e) { return e <= (0.000001) && e >= -(0.000001) } function vd(m, k, i, e) { return m * e - k * i } var tw = o9; var ir = eP; var uf = sv; var nQ = ["dataToPoint", "pointToData"]; var C7 = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"]; function Dm(v, e, m) { var i = this._targetInfoList = []; var Z = {}; var k = zs(e, v); tw(HA, function (v1, v2) { if (!m || !m.include || ir(m.include, v2) >= 0) { v1(k, i, Z) } }) } var cd = Dm.prototype; cd.setOutputRanges = function (i, e) {
    this.matchOutputRanges(i, e, function (v, Z, m) {
      (v.coordRanges || (v.coordRanges = [])).push(Z); if (!v.coordRange) {
        v.coordRange = Z;
        var k = vP[v.brushType](0, m, Z); v.__rangeOffset = { offset: tE[v.brushType](k.values, v.range, [1, 1]), xyMinMax: k.xyMinMax }
      }
    })
  }; cd.matchOutputRanges = function (k, i, e) { tw(k, function (m) { var v = this.findTargetInfo(m, i); if (v && v !== true) { o9(v.coordSyses, function (v1) { var Z = vP[m.brushType](1, v1, m.range); e(m, Z.values, v1, i) }) } }, this) }; cd.setInputRanges = function (i, e) { tw(i, function (m) { var Z = this.findTargetInfo(m, e); if (ok) { bM(!Z || Z === true || m.coordRange, "coordRange must be specified when coord index specified."); bM(!Z || Z !== true || m.range, "range must be specified in global brush.") } m.range = m.range || []; if (Z && Z !== true) { m.panelId = Z.panelId; var k = vP[m.brushType](0, Z.coordSys, m.coordRange); var v = m.__rangeOffset; m.range = v ? tE[m.brushType](k.values, v.offset, Ej(k.xyMinMax, v.xyMinMax)) : k.values } }, this) }; cd.makePanelOpts = function (i, e) { return Ef(this._targetInfoList, function (m) { var k = m.getPanelRect(); return { panelId: m.panelId, defaultBrushType: e && e(m), clipPath: Fg(k), isTargetByCursor: qL(k, i, m.coordSysModel), getLinearBrushOtherExtent: vz(k) } }) }; cd.controlSeries = function (k, i, e) { var m = this.findTargetInfo(k, e); return m === true || (m && ir(m.coordSyses, i.coordinateSystem) >= 0) }; cd.findTargetInfo = function (v1, e) { var k = this._targetInfoList; var m = zs(e, v1); for (var Z = 0; Z < k.length; Z++) { var v2 = k[Z]; var v = v1.panelId; if (v) { if (v2.panelId === v) { return v2 } } else { for (var Z = 0; Z < ys.length; Z++) { if (ys[Z](m, v2)) { return v2 } } } } return true }; function lj(e) { e[0] > e[1] && e.reverse(); return e } function zs(e, i) { return nF(e, i, { includeMainTypes: C7 }) } var HA = { grid: function (i, e) { var k = i.xAxisModels; var v2 = i.yAxisModels; var Z = i.gridModels; var v1 = CJ(); var v = {}; var m = {}; if (!k && !v2 && !Z) { return } tw(k, function (v3) { var Ij = v3.axis.grid.model; v1.set(Ij.id, Ij); v[Ij.id] = true }); tw(v2, function (v3) { var Ij = v3.axis.grid.model; v1.set(Ij.id, Ij); m[Ij.id] = true }); tw(Z, function (v3) { v1.set(v3.id, v3); v[v3.id] = true; m[v3.id] = true }); v1.each(function (Ik) { var v3 = Ik.coordinateSystem; var Ij = []; tw(v3.getCartesians(), function (Im, Il) { if (ir(k, Im.getAxis("x").model) >= 0 || ir(v2, Im.getAxis("y").model) >= 0) { Ij.push(Im) } }); e.push({ panelId: "grid--" + Ik.id, gridModel: Ik, coordSysModel: Ik, coordSys: Ij[0], coordSyses: Ij, getPanelRect: on.grid, xAxisDeclared: v[Ik.id], yAxisDeclared: m[Ik.id] }) }) }, geo: function (i, e) { tw(i.geoModels, function (k) { var m = k.coordinateSystem; e.push({ panelId: "geo--" + k.id, geoModel: k, coordSysModel: k, coordSys: m, coordSyses: [m], getPanelRect: on.geo }) }) } }; var ys = [function (i, v) { var e = i.xAxisModel; var k = i.yAxisModel; var m = i.gridModel; !m && e && (m = e.axis.grid.model); !m && k && (m = k.axis.grid.model); return m && m === v.gridModel }, function (i, k) { var e = i.geoModel; return e && e === k.geoModel }]; var on = { grid: function () { return this.coordSys.grid.getRect().clone() }, geo: function () { var e = this.coordSys; var i = e.getBoundingRect().clone(); i.applyTransform(aI(e)); return i } }; var vP = { lineX: uf(kv, 0), lineY: uf(kv, 1), rect: function (Z, i, v) { var m = i[nQ[Z]]([v[0][0], v[1][0]]); var k = i[nQ[Z]]([v[0][1], v[1][1]]); var e = [lj([m[0], k[0]]), lj([m[1], k[1]])]; return { values: e, xyMinMax: e } }, polygon: function (v, k, m) { var e = [[Infinity, -Infinity], [Infinity, -Infinity]]; var i = Ef(m, function (Z) { var v1 = k[nQ[v]](Z); e[0][0] = Math.min(e[0][0], v1[0]); e[1][0] = Math.min(e[1][0], v1[1]); e[0][1] = Math.max(e[0][1], v1[0]); e[1][1] = Math.max(e[1][1], v1[1]); return v1 }); return { values: i, xyMinMax: e } } }; function kv(k, v1, m, Z) { if (ok) { bM(m.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.") } var v = m.getAxis(["x", "y"][k]); var i = lj(Ef([0, 1], function (v2) { return v1 ? v.coordToData(v.toLocalCoord(Z[v2])) : v.toGlobalCoord(v.dataToCoord(Z[v2])) })); var e = []; e[k] = i; e[1 - k] = [NaN, NaN]; return { values: i, xyMinMax: e } } var tE = { lineX: uf(ns, 0), lineY: uf(ns, 1), rect: function (e, i, k) { return [[e[0][0] - k[0] * i[0][0], e[0][1] - k[0] * i[0][1]], [e[1][0] - k[1] * i[1][0], e[1][1] - k[1] * i[1][1]]] }, polygon: function (e, i, k) { return Ef(e, function (v, m) { return [v[0] - k[0] * i[m][0], v[1] - k[1] * i[m][1]] }) } }; function ns(i, e, k, m) { return [e[0] - m[i] * k[0], e[1] - m[i] * k[1]] } function Ej(v, e) { var k = G9(v); var i = G9(e); var m = [k[0] / i[0], k[1] / i[1]]; isNaN(m[0]) && (m[0] = 1); isNaN(m[1]) && (m[1] = 1); return m } function G9(e) { return e ? [e[0][1] - e[0][0], e[1][1] - e[1][0]] : [NaN, NaN] } var GO = ["inBrush", "outOfBrush"]; var pn = "__ecBrushSelect"; var wd = "__ecInBrushSelectEvent"; var Bv = B6.VISUAL.BRUSH; pr(Bv, function (e, i, k) { e.eachComponent({ mainType: "brush" }, function (m) { k && k.type === "takeGlobalCursor" && m.setBrushOption(k.key === "brush" ? k.brushOption : { brushType: false }); var v = m.brushTargetManager = new Dm(m.option, e); v.setInputRanges(m.areas, e) }) }); G(Bv, function (i, k, v) {
    var m = []; var Z; var e; i.eachComponent({ mainType: "brush" }, function (Iu, v3) {
      var Im = { brushId: Iu.id, brushIndex: v3, brushName: Iu.name, areas: C5(Iu.areas), selected: [] }; m.push(Im); var Ik = Iu.option; var Iq = Ik.brushLink; var Io = []; var v2 = []; var It = []; var Ir = 0; if (!v3) { Z = Ik.throttleType; e = Ik.throttleDelay } var v1 = Ef(Iu.areas, function (Iv) { return jL(De({ boundingRect: p3[Iv.brushType](Iv) }, Iv)) }); var In = Ab(Iu.option, GO, function (Iv) { Iv.mappingMethod = "fixed" }); GG(Iq) && o9(Iq, function (Iv) { Io[Iv] = 1 }); function Il(Iv) { return Iq === "all" || Io[Iv] } function Ij(Iv) { return !!Iv.length } i.eachSeries(function (Ix, Iw) {
        var Iv = It[Iw] = [];
        Ix.subType === "parallel" ? Ip(Ix, Iw, Iv) : Is(Ix, Iw, Iv)
      }); function Ip(Iw, Iv) { var Ix = Iw.coordinateSystem; Ir |= Ix.hasAxisBrushed(); Il(Iv) && Ix.eachActiveState(Iw.getData(), function (Iz, Iy) { Iz === "active" && (v2[Iy] = 1) }) } function Is(Iy, Ix, Iw) { var Iv = DT(Iy); if (!Iv || Hb(Iu, Ix)) { return } o9(v1, function (IA) { Iv[IA.brushType] && Iu.brushTargetManager.controlSeries(IA, Iy, i) && Iw.push(IA); Ir |= Ij(Iw) }); if (Il(Ix) && Ij(Iw)) { var Iz = Iy.getData(); Iz.each(function (IA) { if (BZ(Iv, Iw, Iz, IA)) { v2[IA] = 1 } }) } } i.eachSeries(function (Iz, Iy) { var Ix = { seriesId: Iz.id, seriesIndex: Iy, seriesName: Iz.name, dataIndex: [] }; Im.selected.push(Ix); var Iw = DT(Iz); var Iv = It[Iy]; var IA = Iz.getData(); var IB = Il(Iy) ? function (IC) { return v2[IC] ? (Ix.dataIndex.push(IA.getRawIndex(IC)), "inBrush") : "outOfBrush" } : function (IC) { return BZ(Iw, Iv, IA, IC) ? (Ix.dataIndex.push(IA.getRawIndex(IC)), "inBrush") : "outOfBrush" }; (Il(Iy) ? Ir : Ij(Iv)) && dx(GO, In, IA, IB) })
    }); pV(k, Z, e, m, v)
  }); function pV(k, v1, e, Z, v) { if (!v) { return } var m = k.getZr(); if (m[wd]) { return } if (!m[pn]) { m[pn] = AT } var i = mK(m, pn, e, v1); i(k, Z) } function AT(e, k) { if (!e.isDisposed()) { var i = e.getZr(); i[wd] = true; e.dispatchAction({ type: "brushSelect", batch: k }); i[wd] = false } } function BZ(m, k, v2, Z) { for (var v = 0, e = k.length; v < e; v++) { var v1 = k[v]; if (m[v1.brushType](Z, v2, v1.selectors, v1)) { return true } } } function DT(k) { var m = k.brushSelector; if (wb(m)) { var e = []; o9(aw, function (Z, v) { e[v] = function (v2, Ik, v1, Ij) { var v3 = Ik.getItemLayout(v2); return Z[m](v3, v1, Ij) } }); return e } else { if (E5(m)) { var i = {}; o9(aw, function (Z, v) { i[v] = m }); return i } } return m } function Hb(i, e) { var k = i.option.seriesIndex; return k != null && k !== "all" && (GG(k) ? eP(k, e) < 0 : e !== k) } function jL(i) { var e = i.selectors = {}; o9(aw[i.brushType], function (m, k) { e[k] = function (v) { return m(v, e, i) } }); return i } var p3 = { lineX: V, lineY: V, rect: function (e) { return bI(e.range) }, polygon: function (v1) { var m; var k = v1.range; for (var Z = 0, e = k.length; Z < e; Z++) { m = m || [[Infinity, -Infinity], [Infinity, -Infinity]]; var v = k[Z]; v[0] < m[0][0] && (m[0][0] = v[0]); v[0] > m[0][1] && (m[0][1] = v[0]); v[1] < m[1][0] && (m[1][0] = v[1]); v[1] > m[1][1] && (m[1][1] = v[1]) } return m && bI(m) } }; function bI(e) { return new CH(e[0][0], e[1][0], e[0][1] - e[0][0], e[1][1] - e[1][0]) } var fn = ["#ddd"]; var DE = p2({ type: "brush", dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], defaultOption: { toolbox: null, brushLink: null, seriesIndex: "all", geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: "rect", brushMode: "single", transformable: true, brushStyle: { borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: true, z: 10000 }, areas: [], brushType: null, brushOption: {}, coordInfoList: [], optionUpdated: function (i, m) { var e = this.option; !m && nc(e, i, ["inBrush", "outOfBrush"]); var k = e.inBrush = e.inBrush || {}; e.outOfBrush = e.outOfBrush || { color: fn }; if (!k.hasOwnProperty("liftZ")) { k.liftZ = 5 } }, setAreas: function (e) { if (ok) { bM(GG(e)); o9(e, function (i) { bM(i.brushType, "Illegal areas") }) } if (!e) { return } this.areas = Ef(e, function (i) { return tV(this.option, i) }, this) }, setBrushOption: function (e) { this.brushOption = tV(this.option, e); this.brushType = this.brushOption.brushType } }); function tV(e, i) { return v4({ brushType: e.brushType, brushMode: e.brushMode, transformable: e.transformable, brushStyle: new fv(e.brushStyle).getItemStyle(), removeOnClick: e.removeOnClick, z: e.z }, i, true) } qy({ type: "brush", init: function (e, i) { this.ecModel = e; this.api = i; this.model; (this._brushController = new kx(i.getZr())).on("brush", km(this._onBrush, this)).mount() }, render: function (e) { this.model = e; return cN.apply(this, arguments) }, updateTransform: cN, updateView: cN, dispose: function () { this._brushController.dispose() }, _onBrush: function (e, i) { var k = this.model.id; this.model.brushTargetManager.setOutputRanges(e, this.ecModel); (!i.isEnd || i.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: k, areas: C5(e), $from: k }) } }); function cN(i, e, k, m) { (!m || m.$from !== i.id) && this._brushController.setPanels(i.brushTargetManager.makePanelOpts(k)).enableBrush(i.brushOption).updateCovers(i.areas.slice()) } b1({ type: "brush", event: "brush" }, function (i, e) { e.eachComponent({ mainType: "brush", query: i }, function (k) { k.setAreas(i.areas) }) }); b1({ type: "brushSelect", event: "brushSelected", update: "none" }, function () { }); var eX = {}; function aF(e, i) { eX[e] = i } function a1(e) { return eX[e] } var qc = Cn.toolbox.brush; function tb(i, e, k) { this.model = i; this.ecModel = e; this.api = k; this._brushType; this._brushMode } tb.defaultOption = { show: true, type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"], icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: C5(qc.title) };
  var cc = tb.prototype; cc.render = cc.updateView = function (Z, i, m) { var v; var e; var k; i.eachComponent({ mainType: "brush" }, function (v1) { v = v1.brushType; e = v1.brushOption.brushMode || "single"; k |= v1.areas.length }); this._brushType = v; this._brushMode = e; o9(Z.get("type", true), function (v1) { Z.setIconStatus(v1, (v1 === "keep" ? e === "multiple" : v1 === "clear" ? k : v1 === v) ? "emphasis" : "normal") }) }; cc.getIcons = function () { var e = this.model; var k = e.get("icon", true); var i = {}; o9(e.get("type", true), function (m) { if (k[m]) { i[m] = k[m] } }); return i }; cc.onclick = function (i, m, k) { var v = this._brushType; var e = this._brushMode; if (k === "clear") { m.dispatchAction({ type: "axisAreaSelect", intervals: [] }); m.dispatchAction({ type: "brush", command: "clear", areas: [] }) } else { m.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: k === "keep" ? v : (v === k ? false : k), brushMode: k === "keep" ? (e === "multiple" ? "single" : "multiple") : e } }) } }; aF("brush", tb); y2(HZ); var r0 = 86400000; function ea(i, e, k) { this._model = i } ea.prototype = {
    constructor: ea, type: "calendar", dimensions: ["time", "value"], getDimensionsInfo: function () { return [{ name: "time", type: "time" }, "value"] }, getRangeInfo: function () { return this._rangeInfo }, getModel: function () { return this._model }, getRect: function () { return this._rect }, getCellWidth: function () { return this._sw }, getCellHeight: function () { return this._sh }, getOrient: function () { return this._orient }, getFirstDayOfWeek: function () { return this._firstDayOfWeek }, getDateInfo: function (k) { k = vS(k); var Z = k.getFullYear(); var e = k.getMonth() + 1; e = e < 10 ? "0" + e : e; var v = k.getDate(); v = v < 10 ? "0" + v : v; var i = k.getDay(); i = Math.abs((i + 7 - this.getFirstDayOfWeek()) % 7); return { y: Z, m: e, d: v, day: i, time: k.getTime(), formatedDate: Z + "-" + e + "-" + v, date: k } }, getNextNDay: function (e, i) { i = i || 0; if (i === 0) { return this.getDateInfo(e) } e = new Date(this.getDateInfo(e).time); e.setDate(e.getDate() + i); return this.getDateInfo(e) }, update: function (v1, v2) { this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"); this._orient = this._model.get("orient"); this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0; this._rangeInfo = this._getRangeInfo(this._initRangeOption()); var e = this._rangeInfo.weeks || 1; var Ij = ["width", "height"]; var i = this._model.get("cellSize").slice(); var m = this._model.getBoxLayoutParams(); var Z = this._orient === "horizontal" ? [e, 7] : [7, e]; o9([0, 1], function (Ik) { if (k(i, Ik)) { m[Ij[Ik]] = i[Ik] * Z[Ik] } }); var v = { width: v2.getWidth(), height: v2.getHeight() }; var v3 = this._rect = kV(m, v); o9([0, 1], function (Ik) { if (!k(i, Ik)) { i[Ik] = v3[Ij[Ik]] / Z[Ik] } }); function k(Il, Ik) { return Il[Ik] != null && Il[Ik] !== "auto" } this._sw = i[0]; this._sh = i[1] }, dataToPoint: function (v, v1) { GG(v) && (v = v[0]); v1 == null && (v1 = true); var m = this.getDateInfo(v); var e = this._rangeInfo; var i = m.formatedDate; if (v1 && !(m.time >= e.start.time && m.time < e.end.time + r0)) { return [NaN, NaN] } var k = m.day; var Z = this._getRangeInfo([e.start.time, i]).nthWeek; if (this._orient === "vertical") { return [this._rect.x + k * this._sw + this._sw / 2, this._rect.y + Z * this._sh + this._sh / 2] } return [this._rect.x + Z * this._sw + this._sw / 2, this._rect.y + k * this._sh + this._sh / 2] }, pointToData: function (e) { var i = this.pointToDate(e); return i && i.time }, dataToRect: function (i, k) { var e = this.dataToPoint(i, k); return { contentShape: { x: e[0] - (this._sw - this._lineWidth) / 2, y: e[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: e, tl: [e[0] - this._sw / 2, e[1] - this._sh / 2], tr: [e[0] + this._sw / 2, e[1] - this._sh / 2], br: [e[0] + this._sw / 2, e[1] + this._sh / 2], bl: [e[0] - this._sw / 2, e[1] + this._sh / 2] } }, pointToDate: function (e) { var m = Math.floor((e[0] - this._rect.x) / this._sw) + 1; var k = Math.floor((e[1] - this._rect.y) / this._sh) + 1; var i = this._rangeInfo.range; if (this._orient === "vertical") { return this._getDateByWeeksAndDay(k, m - 1, i) } return this._getDateByWeeksAndDay(m, k - 1, i) }, convertToPixel: sv(gK, "dataToPoint"), convertFromPixel: sv(gK, "pointToData"), _initRangeOption: function () { var k = this._model.get("range"); var m = k; if (GG(m) && m.length === 1) { m = m[0] } if (/^\d{4}$/.test(m)) { k = [m + "-01-01", m + "-12-31"] } if (/^\d{4}[\/|-]\d{1,2}$/.test(m)) { var Z = this.getDateInfo(m); var i = Z.date; i.setMonth(i.getMonth() + 1); var e = this.getNextNDay(i, -1); k = [Z.formatedDate, e.formatedDate] } if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(m)) { k = [m, m] } var v = this._getRangeInfo(k); if (v.start.time > v.end.time) { k.reverse() } return k }, _getRangeInfo: function (Z) { Z = [this.getDateInfo(Z[0]), this.getDateInfo(Z[1])]; var m; if (Z[0].time > Z[1].time) { m = true; Z.reverse() } var v3 = Math.floor(Z[1].time / r0) - Math.floor(Z[0].time / r0) + 1; var k = new Date(Z[0].time); var v = k.getDate(); var v1 = Z[1].date.getDate(); k.setDate(v + v3 - 1); if (k.getDate() !== v1) { var i = k.getTime() - Z[1].time > 0 ? 1 : -1; while (k.getDate() !== v1 && (k.getTime() - Z[1].time) * i > 0) { v3 -= i; k.setDate(v + v3 - 1) } } var e = Math.floor((v3 + Z[0].day + 6) / 7); var v2 = m ? -e + 1 : e - 1; m && Z.reverse(); return { range: [Z[0].formatedDate, Z[1].formatedDate], start: Z[0], end: Z[1], allDay: v3, weeks: e, nthWeek: v2, fweek: Z[0].day, lweek: Z[1].day } }, _getDateByWeeksAndDay: function (v, k, i) {
      var e = this._getRangeInfo(i); if (v > e.weeks || (v === 0 && k < e.fweek) || (v === e.weeks && k > e.lweek)) { return false } var Z = (v - 1) * 7 - e.fweek + k;
      var m = new Date(e.start.time); m.setDate(e.start.d + Z); return this.getDateInfo(m)
    }
  }; ea.dimensions = ea.prototype.dimensions; ea.getDimensionsInfo = ea.prototype.getDimensionsInfo; ea.create = function (e, i) { var k = []; e.eachComponent("calendar", function (m) { var v = new ea(m, e, i); k.push(v); m.coordinateSystem = v }); e.eachSeries(function (m) { if (m.get("coordinateSystem") === "calendar") { m.coordinateSystem = k[m.get("calendarIndex") || 0] } }); return k }; function gK(k, e, v1, Z) { var m = v1.calendarModel; var i = v1.seriesModel; var v = m ? m.coordinateSystem : i ? i.coordinateSystem : null; return v === this ? v[k](Z) : null } fz.register("calendar", ea); var n7 = aH.extend({ type: "calendar", coordinateSystem: null, defaultOption: { zlevel: 0, z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: true, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { color: "#fff", borderWidth: 1, borderColor: "#ccc" }, dayLabel: { show: true, firstDay: 0, position: "start", margin: "50%", nameMap: "en", color: "#000" }, monthLabel: { show: true, position: "start", margin: 5, align: "center", nameMap: "en", formatter: null, color: "#000" }, yearLabel: { show: true, position: null, margin: 30, formatter: null, color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } }, init: function (k, i, e, m) { var v = g2(k); n7.superApply(this, "init", arguments); fO(k, v) }, mergeOption: function (e, i) { n7.superApply(this, "mergeOption", arguments); fO(this.option, e) } }); function fO(k, i) { var m = k.cellSize; if (!GG(m)) { m = k.cellSize = [m, m] } else { if (m.length === 1) { m[1] = m[0] } } var e = Ef([0, 1], function (v) { if (mW(i, v)) { m[v] = "auto" } return m[v] != null && m[v] !== "auto" }); he(k, i, { type: "box", ignoreSize: e }) } var pu = { EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], CN: ["", "", "", "", "", "", "", "", "", "", "", ""] }; var Ay = { EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["", "", "", "", "", "", ""] }; qy({
    type: "calendar", _tlpoints: null, _blpoints: null, _firstDayOfMonth: null, _firstDayPoints: null, render: function (m, e, Z) { var v1 = this.group; v1.removeAll(); var v = m.coordinateSystem; var i = v.getRangeInfo(); var k = v.getOrient(); this._renderDayRect(m, i, v1); this._renderLines(m, i, k, v1); this._renderYearText(m, i, k, v1); this._renderMonthText(m, k, v1); this._renderWeekText(m, i, k, v1) }, _renderDayRect: function (k, e, Ij) { var m = k.coordinateSystem; var Ik = k.getModel("itemStyle").getItemStyle(); var v3 = m.getCellWidth(); var Z = m.getCellHeight(); for (var v = e.start.time; v <= e.end.time; v = m.getNextNDay(v, 1).time) { var v2 = m.dataToRect([v], false).tl; var v1 = new EH({ shape: { x: v2[0], y: v2[1], width: v3, height: Z }, cursor: "default", style: Ik }); Ij.add(v1) } }, _renderLines: function (Z, k, v2, Im) { var In = this; var v1 = Z.coordinateSystem; var Ik = Z.getModel("splitLine.lineStyle").getLineStyle(); var Il = Z.get("splitLine.show"); var Ij = Ik.lineWidth; this._tlpoints = []; this._blpoints = []; this._firstDayOfMonth = []; this._firstDayPoints = []; var e = k.start; for (var v3 = 0; e.time <= k.end.time; v3++) { m(e.formatedDate); if (v3 === 0) { e = v1.getDateInfo(k.start.y + "-" + k.start.m) } var v = e.date; v.setMonth(v.getMonth() + 1); e = v1.getDateInfo(v) } m(v1.getNextNDay(k.end.time, 1).formatedDate); function m(i) { In._firstDayOfMonth.push(v1.getDateInfo(i)); In._firstDayPoints.push(v1.dataToRect([i], false).tl); var Io = In._getLinePointsOfOneWeek(Z, i, v2); In._tlpoints.push(Io[0]); In._blpoints.push(Io[Io.length - 1]); Il && In._drawSplitline(Io, Ik, Im) } Il && this._drawSplitline(In._getEdgesPoints(In._tlpoints, Ij, v2), Ik, Im); Il && this._drawSplitline(In._getEdgesPoints(In._blpoints, Ij, v2), Ik, Im) }, _getEdgesPoints: function (v, i, m) { var k = [v[0].slice(), v[v.length - 1].slice()]; var e = m === "horizontal" ? 0 : 1; k[0][e] = k[0][e] - i / 2; k[1][e] = k[1][e] + i / 2; return k }, _drawSplitline: function (e, k, i) { var m = new z7({ z2: 20, shape: { points: e }, style: k }); i.add(m) }, _getLinePointsOfOneWeek: function (v, m, k) { var v1 = v.coordinateSystem; m = v1.getDateInfo(m); var v2 = []; for (var Z = 0; Z < 7; Z++) { var v3 = v1.getNextNDay(m.time, Z); var e = v1.dataToRect([v3.time], false); v2[2 * v3.day] = e.tl; v2[2 * v3.day + 1] = e[k === "horizontal" ? "bl" : "tr"] } return v2 }, _formatterLabel: function (e, i) { if (typeof e === "string" && e) { return Fy(e, i) } if (typeof e === "function") { return e(i) } return i.nameMap }, _yearTextPositionControl: function (v, i, m, e, v1) { i = i.slice(); var Z = ["center", "bottom"]; if (e === "bottom") { i[1] += v1; Z = ["center", "top"] } else { if (e === "left") { i[0] -= v1 } else { if (e === "right") { i[0] += v1; Z = ["center", "top"] } else { i[1] -= v1 } } } var k = 0; if (e === "left" || e === "right") { k = Math.PI / 2 } return { rotation: k, position: i, style: { textAlign: Z[0], textVerticalAlign: Z[1] } } }, _renderYearText: function (v, i, v2, In) {
      var m = v.getModel("yearLabel"); if (!m.get("show")) { return } var v1 = m.get("margin"); var Ik = m.get("position"); if (!Ik) { Ik = v2 !== "horizontal" ? "top" : "left" } var Io = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]; var Iq = (Io[0][0] + Io[1][0]) / 2; var Ij = (Io[0][1] + Io[1][1]) / 2; var Im = v2 === "horizontal" ? 0 : 1; var Ip = { top: [Iq, Io[Im][1]], bottom: [Iq, Io[1 - Im][1]], left: [Io[1 - Im][0], Ij], right: [Io[Im][0], Ij] }; var e = i.start.y; if (+i.end.y > +i.start.y) { e = e + "-" + i.end.y } var Il = m.get("formatter"); var Z = { start: i.start.y, end: i.end.y, nameMap: e }; var v3 = this._formatterLabel(Il, Z); var k = new iR({ z2: 30 }); pe(k.style, m, { text: v3 }), k.attr(this._yearTextPositionControl(k, Ip[Ik], v2, Ik, v1));
      In.add(k)
    }, _monthTextPositionControl: function (v3, Z, i, k, e) { var v = "left"; var m = "top"; var v2 = v3[0]; var v1 = v3[1]; if (i === "horizontal") { v1 = v1 + e; if (Z) { v = "center" } if (k === "start") { m = "bottom" } } else { v2 = v2 + e; if (Z) { m = "middle" } if (k === "start") { v = "right" } } return { x: v2, y: v1, textAlign: v, textVerticalAlign: m } }, _renderMonthText: function (v2, v3, Z) { var m = v2.getModel("monthLabel"); if (!m.get("show")) { return } var Iq = m.get("nameMap"); var Il = m.get("margin"); var v = m.get("position"); var In = m.get("align"); var e = [this._tlpoints, this._blpoints]; if (wb(Iq)) { Iq = pu[Iq.toUpperCase()] || [] } var Ik = v === "start" ? 0 : 1; var k = v3 === "horizontal" ? 0 : 1; Il = v === "start" ? -Il : Il; var v1 = (In === "center"); for (var Ip = 0; Ip < e[Ik].length - 1; Ip++) { var It = e[Ik][Ip].slice(); var Ij = this._firstDayOfMonth[Ip]; if (v1) { var Ir = this._firstDayPoints[Ip]; It[k] = (Ir[k] + e[0][Ip + 1][k]) / 2 } var Io = m.get("formatter"); var Iv = Iq[+Ij.m - 1]; var Is = { yyyy: Ij.y, yy: (Ij.y + "").slice(2), MM: Ij.m, M: +Ij.m, nameMap: Iv }; var Im = this._formatterLabel(Io, Is); var Iu = new iR({ z2: 30 }); b0(pe(Iu.style, m, { text: Im }), this._monthTextPositionControl(It, v1, v3, v, Il)); Z.add(Iu) } }, _weekTextPositionControl: function (Ij, m, v, k, i) { var v1 = "center"; var Z = "middle"; var v3 = Ij[0]; var v2 = Ij[1]; var e = v === "start"; if (m === "horizontal") { v3 = v3 + k + (e ? 1 : -1) * i[0] / 2; v1 = e ? "right" : "left" } else { v2 = v2 + k + (e ? 1 : -1) * i[1] / 2; Z = e ? "bottom" : "top" } return { x: v3, y: v2, textAlign: v1, textVerticalAlign: Z } }, _renderWeekText: function (v2, v, Ik, Ir) { var Z = v2.getModel("dayLabel"); if (!Z.get("show")) { return } var Ij = v2.coordinateSystem; var Ip = Z.get("position"); var In = Z.get("nameMap"); var v3 = Z.get("margin"); var e = Ij.getFirstDayOfWeek(); if (wb(In)) { In = Ay[In.toUpperCase()] || [] } var m = Ij.getNextNDay(v.end.time, (7 - v.lweek)).time; var k = [Ij.getCellWidth(), Ij.getCellHeight()]; v3 = zN(v3, k[Ik === "horizontal" ? 0 : 1]); if (Ip === "start") { m = Ij.getNextNDay(v.start.time, -(7 + v.fweek)).time; v3 = -v3 } for (var Il = 0; Il < 7; Il++) { var Im = Ij.getNextNDay(m, Il); var Iq = Ij.dataToRect([Im.time], false).center; var Io = Il; Io = Math.abs((Il + e) % 7); var v1 = new iR({ z2: 30 }); b0(pe(v1.style, Z, { text: In[Io] }), this._weekTextPositionControl(Iq, Ik, Ip, v3, k)); Ir.add(v1) } }
  }); p2({ type: "title", layoutMode: { type: "box", ignoreSize: true }, defaultOption: { zlevel: 0, z: 6, show: true, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }); qy({ type: "title", render: function (Z, Iu, Im) { this.group.removeAll(); if (!Z.get("show")) { return } var Ij = this.group; var v3 = Z.getModel("textStyle"); var It = Z.getModel("subtextStyle"); var v1 = Z.get("textAlign"); var Ir = Z.get("textBaseline"); var Iq = new iR({ style: pe({}, v3, { text: Z.get("text"), textFill: v3.getTextColor() }, { disableBox: true }), z2: 10 }); var e = Iq.getBoundingRect(); var v = Z.get("subtext"); var m = new iR({ style: pe({}, It, { text: v, textFill: It.getTextColor(), y: e.height + Z.get("itemGap"), textVerticalAlign: "top" }, { disableBox: true }), z2: 10 }); var v2 = Z.get("link"); var Io = Z.get("sublink"); Iq.silent = !v2; m.silent = !Io; if (v2) { Iq.on("click", function () { window.open(v2, "_" + Z.get("target")) }) } if (Io) { m.on("click", function () { window.open(Io, "_" + Z.get("subtarget")) }) } Ij.add(Iq); v && Ij.add(m); var In = Ij.getBoundingRect(); var k = Z.getBoxLayoutParams(); k.width = In.width; k.height = In.height; var Is = kV(k, { width: Im.getWidth(), height: Im.getHeight() }, Z.get("padding")); if (!v1) { v1 = Z.get("left") || Z.get("right"); if (v1 === "middle") { v1 = "center" } if (v1 === "right") { Is.x += Is.width } else { if (v1 === "center") { Is.x += Is.width / 2 } } } if (!Ir) { Ir = Z.get("top") || Z.get("bottom"); if (Ir === "center") { Ir = "middle" } if (Ir === "bottom") { Is.y += Is.height } else { if (Ir === "middle") { Is.y += Is.height / 2 } } Ir = Ir || "top" } Ij.attr("position", [Is.x, Is.y]); var Ik = { textAlign: v1, textVerticalAlign: Ir }; Iq.setStyle(Ik); m.setStyle(Ik); In = Ij.getBoundingRect(); var Il = Is.margin; var Ip = Z.getItemStyle(["color", "opacity"]); Ip.fill = Z.get("backgroundColor"); var i = new EH({ shape: { x: In.x - Il[3], y: In.y - Il[0], width: In.width + Il[1] + Il[3], height: In.height + Il[0] + Il[2], r: Z.get("borderRadius") }, style: Ip, silent: true }); iA(i); Ij.add(i) } }); aH.registerSubTypeDefaulter("dataZoom", function () { return "slider" }); var N = ["x", "y", "z", "radius", "angle", "single"]; var u = ["cartesian2d", "polar", "singleAxis"]; function CG(e) { return eP(u, e) >= 0 } function cF(m, i) { m = m.slice(); var k = Ef(m, tg); i = (i || []).slice(); var e = Ef(i, tg); return function (Z, v) { o9(m, function (v3, v2) { var Ij = { name: v3, capital: k[v2] }; for (var v1 = 0; v1 < i.length; v1++) { Ij[i[v1]] = v3 + e[v1] } Z.call(v, Ij) }) } } var iO = cF(N, ["axisIndex", "axis", "index", "id"]); function pW(m, e, i) {
    return function (v3) { var v1 = { nodes: [], records: {} }; e(function (Ik) { v1.records[Ik.name] = {} }); if (!v3) { return v1 } v(v3, v1); var Ij; do { Ij = false; m(v2) } while (Ij); function v2(Ik) { if (!Z(Ik, v1) && k(Ik, v1)) { v(Ik, v1); Ij = true } } return v1 }; function Z(v2, v1) { return eP(v1.nodes, v2) >= 0 } function k(v3, v1) { var v2 = false; e(function (Ij) { o9(i(v3, Ij) || [], function (Ik) { v1.records[Ij.name][Ik] && (v2 = true) }) }); return v2 } function v(v2, v1) {
      v1.nodes.push(v2); e(function (v3) { o9(i(v2, v3) || [], function (Ij) { v1.records[v3.name][Ij] = true }) })
    }
  } var tu = o9; var EZ = o7; var ga = function (k, i, m, e) { this._dimName = k; this._axisIndex = i; this._valueWindow; this._percentWindow; this._dataExtent; this._minMaxSpan; this.ecModel = e; this._dataZoomModel = m }; ga.prototype = { constructor: ga, hostedBy: function (e) { return this._dataZoomModel === e }, getDataValueWindow: function () { return this._valueWindow.slice() }, getDataPercentWindow: function () { return this._percentWindow.slice() }, getTargetSeriesModels: function () { var i = []; var e = this.ecModel; e.eachSeries(function (k) { if (CG(k.get("coordinateSystem"))) { var v = this._dimName; var m = e.queryComponents({ mainType: v + "Axis", index: k.get(v + "AxisIndex"), id: k.get(v + "AxisId") })[0]; if (this._axisIndex === (m && m.componentIndex)) { i.push(k) } } }, this); return i }, getAxisModel: function () { return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex) }, getOtherAxisModel: function () { var k = this._dimName; var e = this.ecModel; var i = this.getAxisModel(); var v1 = k === "x" || k === "y"; var v; var m; if (v1) { m = "gridIndex"; v = k === "x" ? "y" : "x" } else { m = "polarIndex"; v = k === "angle" ? "radius" : "angle" } var Z; e.eachComponent(v + "Axis", function (v2) { if ((v2.get(m) || 0) === (i.get(m) || 0)) { Z = v2 } }); return Z }, getMinMaxSpan: function () { return C5(this._minMaxSpan) }, calculateDataWindow: function (v) { var v1 = this._dataExtent; var m = this.getAxisModel(); var v2 = m.axis.scale; var e = this._dataZoomModel.getRangePropMode(); var i = [0, 100]; var k = [v.start, v.end]; var Z = []; tu(["startValue", "endValue"], function (v3) { Z.push(v[v3] != null ? v2.parse(v[v3]) : null) }); tu([0, 1], function (v3) { var Ik = Z[v3]; var Ij = k[v3]; if (e[v3] === "percent") { if (Ij == null) { Ij = i[v3] } Ik = v2.parse(EQ(Ij, i, v1, true)) } else { Ij = EQ(Ik, v1, i, true) } Z[v3] = Ik; k[v3] = Ij }); return { valueWindow: EZ(Z), percentWindow: EZ(k) } }, reset: function (k) { if (k !== this._dataZoomModel) { return } var e = this.getTargetSeriesModels(); this._dataExtent = tL(this, this._dimName, e); var i = this.calculateDataWindow(k.option); this._valueWindow = i.valueWindow; this._percentWindow = i.percentWindow; we(this); DX(this) }, restore: function (e) { if (e !== this._dataZoomModel) { return } this._valueWindow = this._percentWindow = null; DX(this, true) }, filterData: function (v1, k) { if (v1 !== this._dataZoomModel) { return } var i = this._dimName; var e = this.getTargetSeriesModels(); var Z = v1.get("filterMode"); var m = this._valueWindow; if (Z === "none") { return } tu(e, function (v2) { var v3 = v2.getData(); var Ij = v3.mapDimension(i, true); if (Z === "weakFilter") { v3.filterSelf(function (Io) { var Is; var Il; var Ir; for (var Im = 0; Im < Ij.length; Im++) { var Ip = v3.get(Ij[Im], Io); var Iq = !isNaN(Ip); var In = Ip < m[0]; var Ik = Ip > m[1]; if (Iq && !In && !Ik) { return true } Iq && (Ir = true); In && (Is = true); Ik && (Il = true) } return Ir && Is && Il }) } else { tu(Ij, function (Il) { if (Z === "empty") { v2.setData(v3.map(Il, function (Im) { return !v(Im) ? NaN : Im })) } else { var Ik = {}; Ik[Il] = m; v3.selectRange(Ik) } }) } tu(Ij, function (Ik) { v3.setApproximateExtent(m, Ik) }) }); function v(v2) { return v2 >= m[0] && v2 <= m[1] } } }; function tL(k, i, e) { var m = [Infinity, -Infinity]; tu(e, function (v) { var Z = v.getData(); if (Z) { tu(Z.mapDimension(i, true), function (v2) { var v1 = Z.getApproximateExtent(v2); v1[0] < m[0] && (m[0] = v1[0]); v1[1] > m[1] && (m[1] = v1[1]) }) } }); if (m[1] < m[0]) { m = [NaN, NaN] } pl(k, m); return m } function pl(v, v1) { var m = v.getAxisModel(); var k = m.getMin(true); var Z = m.get("type") === "category"; var i = Z && m.getCategories().length; if (k != null && k !== "dataMin" && typeof k !== "function") { v1[0] = k } else { if (Z) { v1[0] = i > 0 ? 0 : NaN } } var e = m.getMax(true); if (e != null && e !== "dataMax" && typeof e !== "function") { v1[1] = e } else { if (Z) { v1[1] = i > 0 ? i - 1 : NaN } } if (!m.get("scale", true)) { v1[0] > 0 && (v1[0] = 0); v1[1] < 0 && (v1[1] = 0) } return v1 } function DX(m, v1) { var k = m.getAxisModel(); var i = m._percentWindow; var v = m._valueWindow; if (!i) { return } var e = ya(v, [0, 500]); e = Math.min(e, 20); var Z = v1 || (i[0] === 0 && i[1] === 100); k.setRange(Z ? null : +v[0].toFixed(e), Z ? null : +v[1].toFixed(e)) } function we(e) { var i = e._minMaxSpan = {}; var k = e._dataZoomModel; tu(["min", "max"], function (m) { i[m + "Span"] = k.get(m + "Span"); var Z = k.get(m + "ValueSpan"); if (Z != null) { i[m + "ValueSpan"] = Z; Z = e.getAxisModel().axis.scale.parse(Z); if (Z != null) { var v = e._dataExtent; i[m + "Span"] = EQ(v[0] + Z, v, [0, 100], true) } } }) } var tv = o9; var qM = iO; var yB = p2({
    type: "dataZoom", dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: "filter", throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null, rangeMode: null }, init: function (k, i, e) { this._dataIntervalByAxis = {}; this._dataInfo = {}; this._axisProxies = {}; this.textStyleModel; this._autoThrottle = true; this._rangePropMode = ["percent", "percent"]; var m = FB(k); this.mergeDefaultAndTheme(k, e); this.doInit(m) }, mergeOption: function (i) { var e = FB(i); v4(this.option, i, true); this.doInit(e) }, doInit: function (i) { var e = this.option; if (!sW.canvasSupported) { e.realtime = false } this._setDefaultThrottle(i); aT(this, i); tv([["start", "startValue"], ["end", "endValue"]], function (m, k) { if (this._rangePropMode[k] === "value") { e[m[0]] = null } }, this); this.textStyleModel = this.getModel("textStyle"); this._resetTarget(); this._giveAxisProxies() }, _giveAxisProxies: function () {
      var e = this._axisProxies;
      this.eachTargetAxis(function (k, v, v1, i) { var m = this.dependentModels[k.axis][v]; var Z = m.__dzAxisProxy || (m.__dzAxisProxy = new ga(k.name, v, this, i)); e[k.name + "_" + v] = Z }, this)
    }, _resetTarget: function () { var e = this.option; var i = this._judgeAutoMode(); qM(function (k) { var m = k.axisIndex; e[m] = mp(e[m]) }, this); if (i === "axisIndex") { this._autoSetAxisIndex() } else { if (i === "orient") { this._autoSetOrient() } } }, _judgeAutoMode: function () { var i = this.option; var k = false; qM(function (m) { if (i[m.axisIndex] != null) { k = true } }, this); var e = i.orient; if (e == null && k) { return "orient" } else { if (!k) { if (e == null) { i.orient = "horizontal" } return "axisIndex" } } }, _autoSetAxisIndex: function () { var v = true; var e = this.get("orient", true); var i = this.option; var k = this.dependentModels; if (v) { var m = e === "vertical" ? "y" : "x"; if (k[m + "Axis"].length) { i[m + "AxisIndex"] = [0]; v = false } else { tv(k.singleAxis, function (Z) { if (v && Z.get("orient", true) === e) { i.singleAxisIndex = [Z.componentIndex]; v = false } }) } } if (v) { qM(function (v1) { if (!v) { return } var Ij = []; var v3 = this.dependentModels[v1.axis]; if (v3.length && !Ij.length) { for (var v2 = 0, Z = v3.length; v2 < Z; v2++) { if (v3[v2].get("type") === "category") { Ij.push(v2) } } } i[v1.axisIndex] = Ij; if (Ij.length) { v = false } }, this) } if (v) { this.ecModel.eachSeries(function (Z) { if (this._isSeriesHasAllAxesTypeOf(Z, "value")) { qM(function (v1) { var Ik = i[v1.axisIndex]; var v3 = Z.get(v1.axisIndex); var Ij = Z.get(v1.axisId); var v2 = Z.ecModel.queryComponents({ mainType: v1.axis, index: v3, id: Ij })[0]; if (ok) { if (!v2) { throw new Error(v1.axis + ' "' + gu(v3, Ij, 0) + '" not found') } } v3 = v2.componentIndex; if (eP(Ik, v3) < 0) { Ik.push(v3) } }) } }, this) } }, _autoSetOrient: function () { var e; this.eachTargetAxis(function (i) { !e && (e = i.name) }, this); this.option.orient = e === "y" ? "vertical" : "horizontal" }, _isSeriesHasAllAxesTypeOf: function (i, e) { var k = true; qM(function (m) { var Z = i.get(m.axisIndex); var v = this.dependentModels[m.axis][Z]; if (!v || v.get("type") !== e) { k = false } }, this); return k }, _setDefaultThrottle: function (i) { if (i.hasOwnProperty("throttle")) { this._autoThrottle = false } if (this._autoThrottle) { var e = this.ecModel.option; this.option.throttle = (e.animation && e.animationDurationUpdate > 0) ? 100 : 20 } }, getFirstTargetAxisModel: function () { var e; qM(function (i) { if (e == null) { var k = this.get(i.axisIndex); if (k.length) { e = this.dependentModels[i.axis][k[0]] } } }, this); return e }, eachTargetAxis: function (k, i) { var e = this.ecModel; qM(function (m) { tv(this.get(m.axisIndex), function (v) { k.call(i, m, v, this, e) }, this) }, this) }, getAxisProxy: function (i, e) { return this._axisProxies[i + "_" + e] }, getAxisModel: function (k, e) { var i = this.getAxisProxy(k, e); return i && i.getAxisModel() }, setRawRange: function (e, k) { var i = this.option; tv([["start", "startValue"], ["end", "endValue"]], function (m) { if (e[m[0]] != null || e[m[1]] != null) { i[m[0]] = e[m[0]]; i[m[1]] = e[m[1]] } }, this); !k && aT(this, e) }, getPercentRange: function () { var e = this.findRepresentativeAxisProxy(); if (e) { return e.getDataPercentWindow() } }, getValueRange: function (i, e) { if (i == null && e == null) { var k = this.findRepresentativeAxisProxy(); if (k) { return k.getDataValueWindow() } } else { return this.getAxisProxy(i, e).getDataValueWindow() } }, findRepresentativeAxisProxy: function (i) { if (i) { return i.__dzAxisProxy } var k = this._axisProxies; for (var e in k) { if (k.hasOwnProperty(e) && k[e].hostedBy(this)) { return k[e] } } for (var e in k) { if (k.hasOwnProperty(e) && !k[e].hostedBy(this)) { return k[e] } } }, getRangePropMode: function () { return this._rangePropMode.slice() }
  }); function FB(i) { var e = {}; tv(["start", "end", "startValue", "endValue", "throttle"], function (k) { i.hasOwnProperty(k) && (e[k] = i[k]) }); return e } function aT(m, k) { var i = m._rangePropMode; var e = m.get("rangeMode"); tv([["start", "startValue"], ["end", "endValue"]], function (v1, Z) { var v2 = k[v1[0]] != null; var v = k[v1[1]] != null; if (v2 && !v) { i[Z] = "percent" } else { if (!v2 && v) { i[Z] = "value" } else { if (e) { i[Z] = e[Z] } else { if (v2) { i[Z] = "percent" } } } } }) } var D6 = sT.extend({ type: "dataZoom", render: function (m, e, i, k) { this.dataZoomModel = m; this.ecModel = e; this.api = i }, getTargetCoordInfo: function () { var m = this.dataZoomModel; var e = this.ecModel; var i = {}; m.eachTargetAxis(function (v, v1) { var Z = e.getComponent(v.axis, v1); if (Z) { var v2 = Z.getCoordSysModel(); v2 && k(v2, Z, i[v2.mainType] || (i[v2.mainType] = []), v2.componentIndex) } }, this); function k(Ij, v1, v, v3) { var v2; for (var Z = 0; Z < v.length; Z++) { if (v[Z].model === Ij) { v2 = v[Z]; break } } if (!v2) { v.push(v2 = { model: Ij, axisModels: [], coordIndex: v3 }) } v2.axisModels.push(v1) } return i } }); var DC = yB.extend({ type: "dataZoom.slider", layoutMode: "box", defaultOption: { show: true, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#2f4554", width: 0.5, opacity: 0.3 }, areaStyle: { color: "rgba(47,69,84,0.3)", opacity: 0.3 } }, borderColor: "#ddd", fillerColor: "rgba(167,183,204,0.4)", handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z", handleSize: "100%", handleStyle: { color: "#a7b7cc" }, labelPrecision: null, labelFormatter: null, showDetail: true, showDataShadow: "auto", realtime: true, zoomLock: false, textStyle: { color: "#333" } } }); var AX = EH; var l0 = EQ; var EX = o7; var pw = km; var ts = o9;
  var xf = 7; var bC = 1; var oi = 30; var p6 = "horizontal"; var c2 = "vertical"; var jI = 5; var m5 = ["line", "bar", "candlestick", "scatter"]; var eI = D6.extend({
    type: "dataZoom.slider", init: function (e, i) { this._displayables = {}; this._orient; this._range; this._handleEnds; this._size; this._handleWidth; this._handleHeight; this._location; this._dragging; this._dataShadowInfo; this.api = i }, render: function (m, e, i, k) { eI.superApply(this, "render", arguments); mK(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"); this._orient = m.get("orient"); if (this.dataZoomModel.get("show") === false) { this.group.removeAll(); return } if (!k || k.type !== "dataZoom" || k.from !== this.uid) { this._buildView() } this._updateView() }, remove: function () { eI.superApply(this, "remove", arguments); cG(this, "_dispatchZoomAction") }, dispose: function () { eI.superApply(this, "dispose", arguments); cG(this, "_dispatchZoomAction") }, _buildView: function () { var e = this.group; e.removeAll(); this._resetLocation(); this._resetInterval(); var i = this._displayables.barGroup = new B8(); this._renderBackground(); this._renderHandle(); this._renderDataShadow(); e.add(i); this._positionGroup() }, _resetLocation: function () { var v1 = this.dataZoomModel; var v = this.api; var m = this._findCoordRect(); var e = { width: v.getWidth(), height: v.getHeight() }; var i = this._orient === p6 ? { right: e.width - m.x - m.width, top: (e.height - oi - xf), width: m.width, height: oi } : { right: xf, top: m.y, width: oi, height: m.height }; var k = g2(v1.option); o9(["right", "top", "width", "height"], function (v2) { if (k[v2] === "ph") { k[v2] = i[v2] } }); var Z = kV(k, e, v1.padding); this._location = { x: Z.x, y: Z.y }; this._size = [Z.width, Z.height]; this._orient === c2 && this._size.reverse() }, _positionGroup: function () { var m = this.group; var i = this._location; var v = this._orient; var v2 = this.dataZoomModel.getFirstTargetAxisModel(); var e = v2 && v2.get("inverse"); var v1 = this._displayables.barGroup; var k = (this._dataShadowInfo || {}).otherAxisInverse; v1.attr((v === p6 && !e) ? { scale: k ? [1, 1] : [1, -1] } : (v === p6 && e) ? { scale: k ? [-1, 1] : [-1, -1] } : (v === c2 && !e) ? { scale: k ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: k ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 }); var Z = m.getBoundingRect([v1]); m.attr("position", [i.x - Z.x, i.y - Z.y]) }, _getViewExtent: function () { return [0, this._size[0]] }, _renderBackground: function () { var k = this.dataZoomModel; var e = this._size; var i = this._displayables.barGroup; i.add(new AX({ silent: true, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: k.get("backgroundColor") }, z2: -40 })); i.add(new AX({ shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: "transparent" }, z2: 0, onclick: km(this._onClickPanelClick, this) })) }, _renderDataShadow: function () { var m = this._dataShadowInfo = this._prepareDataShadowInfo(); if (!m) { return } var Ip = this._size; var v = m.series; var v1 = v.getRawData(); var Im = v.getShadowDim ? v.getShadowDim() : m.otherDim; if (Im == null) { return } var v3 = v1.getDataExtent(Im); var Io = (v3[1] - v3[0]) * 0.3; v3 = [v3[0] - Io, v3[1] + Io]; var In = [0, Ip[1]]; var Il = [0, Ip[0]]; var Ij = [[Ip[0], 0], [0, 0]]; var Ik = []; var k = Il[1] / (v1.count() - 1); var e = 0; var i = Math.round(v1.count() / Ip[0]); var v2; v1.each([Im], function (Is, Iq) { if (i > 0 && (Iq % i)) { e += k; return } var It = Is == null || isNaN(Is) || Is === ""; var Ir = It ? 0 : l0(Is, v3, In, true); if (It && !v2 && Iq) { Ij.push([Ij[Ij.length - 1][0], 0]); Ik.push([Ik[Ik.length - 1][0], 0]) } else { if (!It && v2) { Ij.push([e, 0]); Ik.push([e, 0]) } } Ij.push([e, Ir]); Ik.push([e, Ir]); e += k; v2 = It }); var Z = this.dataZoomModel; this._displayables.barGroup.add(new ia({ shape: { points: Ij }, style: De({ fill: Z.get("dataBackgroundColor") }, Z.getModel("dataBackground.areaStyle").getAreaStyle()), silent: true, z2: -20 })); this._displayables.barGroup.add(new z7({ shape: { points: Ik }, style: Z.getModel("dataBackground.lineStyle").getLineStyle(), silent: true, z2: -19 })) }, _prepareDataShadowInfo: function () { var m = this.dataZoomModel; var k = m.get("showDataShadow"); if (k === false) { return } var i; var e = this.ecModel; m.eachTargetAxis(function (v, Z) { var v1 = m.getAxisProxy(v.name, Z).getTargetSeriesModels(); o9(v1, function (Ij) { if (i) { return } if (k !== true && eP(m5, Ij.get("type")) < 0) { return } var Ik = e.getComponent(v.axis, Z).axis; var v2 = qk(v.name); var v3; var Il = Ij.coordinateSystem; if (v2 != null && Il.getOtherAxis) { v3 = Il.getOtherAxis(Ik).inverse } v2 = Ij.getData().mapDimension(v2); i = { thisAxis: Ik, series: Ij, thisDim: v.name, otherDim: v2, otherAxisInverse: v3 } }, this) }, this); return i }, _renderHandle: function () {
      var Z = this._displayables; var k = Z.handles = []; var e = Z.handleLabels = []; var m = this._displayables.barGroup; var i = this._size; var v = this.dataZoomModel; m.add(Z.filler = new AX({ draggable: true, cursor: l2(this._orient), drift: pw(this._onDragMove, this, "all"), onmousemove: function (v1) { GP(v1.event) }, ondragstart: pw(this._showDataInfo, this, true), ondragend: pw(this._onDragEnd, this), onmouseover: pw(this._showDataInfo, this, true), onmouseout: pw(this._showDataInfo, this, false), style: { fill: v.get("fillerColor"), textPosition: "inside" } })); m.add(new AX(iA({ silent: true, shape: { x: 0, y: 0, width: i[0], height: i[1] }, style: { stroke: v.get("dataBackgroundColor") || v.get("borderColor"), lineWidth: bC, fill: "rgba(0,0,0,0)" } }))); ts([0, 1], function (Ik) {
        var v3 = Gb(v.get("handleIcon"), {
          cursor: l2(this._orient), draggable: true, drift: pw(this._onDragMove, this, Ik), onmousemove: function (Il) {
            GP(Il.event)
          }, ondragend: pw(this._onDragEnd, this), onmouseover: pw(this._showDataInfo, this, true), onmouseout: pw(this._showDataInfo, this, false)
        }, { x: -1, y: 0, width: 2, height: 2 }); var v2 = v3.getBoundingRect(); this._handleHeight = zN(v.get("handleSize"), this._size[1]); this._handleWidth = v2.width / v2.height * this._handleHeight; v3.setStyle(v.getModel("handleStyle").getItemStyle()); var Ij = v.get("handleColor"); if (Ij != null) { v3.style.fill = Ij } m.add(k[Ik] = v3); var v1 = v.textStyleModel; this.group.add(e[Ik] = new iR({ silent: true, invisible: true, style: { x: 0, y: 0, text: "", textVerticalAlign: "middle", textAlign: "center", textFill: v1.getTextColor(), textFont: v1.getFont() }, z2: 10 }))
      }, this)
    }, _resetInterval: function () { var e = this._range = this.dataZoomModel.getPercentRange(); var i = this._getViewExtent(); this._handleEnds = [l0(e[0], [0, 100], i, true), l0(e[1], [0, 100], i, true)] }, _updateInterval: function (e, v2) { var i = this.dataZoomModel; var v = this._handleEnds; var v3 = this._getViewExtent(); var v1 = i.findRepresentativeAxisProxy().getMinMaxSpan(); var Z = [0, 100]; nv(v2, v, v3, i.get("zoomLock") ? "all" : e, v1.minSpan != null ? l0(v1.minSpan, Z, v3, true) : null, v1.maxSpan != null ? l0(v1.maxSpan, Z, v3, true) : null); var k = this._range; var m = this._range = EX([l0(v[0], v3, Z, true), l0(v[1], v3, Z, true)]); return !k || k[0] !== m[0] || k[1] !== m[1] }, _updateView: function (k) { var v = this._displayables; var m = this._handleEnds; var e = EX(m.slice()); var i = this._size; ts([0, 1], function (v2) { var v1 = v.handles[v2]; var Z = this._handleHeight; v1.attr({ scale: [Z / 2, Z / 2], position: [m[v2], i[1] / 2 - Z / 2] }) }, this); v.filler.setShape({ x: e[0], y: 0, width: e[1] - e[0], height: i[1] }); this._updateDataInfo(k) }, _updateDataInfo: function (Il) { var v1 = this.dataZoomModel; var i = this._displayables; var v = i.handleLabels; var Z = this._orient; var Ij = ["", ""]; if (v1.get("showDetail")) { var e = v1.findRepresentativeAxisProxy(); if (e) { var m = e.getAxisModel().axis; var v2 = this._range; var v3 = Il ? e.calculateDataWindow({ start: v2[0], end: v2[1] }).valueWindow : e.getDataValueWindow(); Ij = [this._formatLabel(v3[0], m), this._formatLabel(v3[1], m)] } } var Ik = EX(this._handleEnds.slice()); k.call(this, 0); k.call(this, 1); function k(Iq) { var Io = aI(i.handles[Iq].parent, this.group); var In = n0(Iq === 0 ? "right" : "left", Io); var Ip = this._handleWidth / 2 + jI; var Im = v7([Ik[Iq] + (Iq === 0 ? -Ip : Ip), this._size[1] / 2], Io); v[Iq].setStyle({ x: Im[0], y: Im[1], textVerticalAlign: Z === p6 ? "middle" : In, textAlign: Z === p6 ? In : "center", text: Ij[Iq] }) } }, _formatLabel: function (v, m) { var Z = this.dataZoomModel; var k = Z.get("labelFormatter"); var i = Z.get("labelPrecision"); if (i == null || i === "auto") { i = m.getPixelPrecision() } var e = (v == null || isNaN(v)) ? "" : (m.type === "category" || m.type === "time") ? m.scale.getLabel(Math.round(v)) : v.toFixed(Math.min(i, 20)); return E5(k) ? k(v, e) : wb(k) ? k.replace("{value}", e) : e }, _showDataInfo: function (e) { e = this._dragging || e; var i = this._displayables.handleLabels; i[0].attr("invisible", !e); i[1].attr("invisible", !e) }, _onDragMove: function (v1, k, i) { this._dragging = true; var v = this._displayables.barGroup.getLocalTransform(); var m = v7([k, i], v, true); var Z = this._updateInterval(v1, m[0]); var e = this.dataZoomModel.get("realtime"); this._updateView(!e); Z && e && this._dispatchZoomAction() }, _onDragEnd: function () { this._dragging = false; this._showDataInfo(false); var e = this.dataZoomModel.get("realtime"); !e && this._dispatchZoomAction() }, _onClickPanelClick: function (v) { var k = this._size; var m = this._displayables.barGroup.transformCoordToLocal(v.offsetX, v.offsetY); if (m[0] < 0 || m[0] > k[0] || m[1] < 0 || m[1] > k[1]) { return } var v1 = this._handleEnds; var i = (v1[0] + v1[1]) / 2; var Z = this._updateInterval("all", m[0] - i); this._updateView(); Z && this._dispatchZoomAction() }, _dispatchZoomAction: function () { var e = this._range; this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: e[0], end: e[1] }) }, _findCoordRect: function () { var k; ts(this.getTargetCoordInfo(), function (v) { if (!k && v.length) { var m = v[0].model.coordinateSystem; k = m.getRect && m.getRect() } }); if (!k) { var i = this.api.getWidth(); var e = this.api.getHeight(); k = { x: i * 0.2, y: e * 0.2, width: i * 0.6, height: e * 0.6 } } return k }
  }); function qk(i) { var e = { x: "y", y: "x", radius: "angle", angle: "radius" }; return e[i] } function l2(e) { return e === "vertical" ? "ns-resize" : "ew-resize" } yB.extend({ type: "dataZoom.inside", defaultOption: { disabled: false, zoomLock: false, zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true } }); var br = "\0_ec_dataZoom_roams"; function aD(v, v1) { var k = oJ(v); var i = v1.dataZoomId; var m = v1.coordId; o9(k, function (v2, Ij) { var v3 = v2.dataZoomInfos; if (v3[i] && eP(v1.allCoordIds, m) < 0) { delete v3[i]; v2.count-- } }); K(k); var e = k[m]; if (!e) { e = k[m] = { coordId: m, dataZoomInfos: {}, count: 0 }; e.controller = nN(v, e); e.dispatchAction = sv(dB, v) } !(e.dataZoomInfos[i]) && e.count++; e.dataZoomInfos[i] = v1; var Z = H3(e.dataZoomInfos); e.controller.enable(Z.controlType, Z.opt); e.controller.setPointerChecker(v1.containsPoint); mK(e, "dispatchAction", v1.dataZoomModel.get("throttle", true), "fixRate") } function fk(k, e) { var i = oJ(k); o9(i, function (m) { m.controller.dispose(); var v = m.dataZoomInfos; if (v[e]) { delete v[e]; m.count-- } }); K(i) } function j3(e) { return e.type + "\0_" + e.id } function oJ(e) {
    var i = e.getZr();
    return i[br] || (i[br] = {})
  } function nN(k, i) { var e = new ad(k.getZr()); o9(["pan", "zoom", "scrollMove"], function (m) { e.on(m, function (Z) { var v = []; o9(i.dataZoomInfos, function (v2) { if (!Z.isAvailableBehavior(v2.dataZoomModel.option)) { return } var v3 = (v2.getRange || {})[m]; var v1 = v3 && v3(i.controller, Z); !v2.dataZoomModel.get("disabled", true) && v1 && v.push({ dataZoomId: v2.dataZoomId, start: v1[0], end: v1[1] }) }); v.length && i.dispatchAction(v) }) }); return e } function K(e) { o9(e, function (i, k) { if (!i.count) { i.controller.dispose(); delete e[k] } }) } function dB(i, e) { i.dispatchAction({ type: "dataZoom", batch: e }) } function H3(i) { var v; var k = "type_"; var e = { "type_true": 2, "type_move": 1, "type_false": 0, "type_undefined": -1 }; var m = true; o9(i, function (v2) { var v1 = v2.dataZoomModel; var Z = v1.get("disabled", true) ? false : v1.get("zoomLock", true) ? "move" : true; if (e[k + Z] > e[k + v]) { v = Z } m &= v1.get("preventDefaultMouseMove", true) }); return { controlType: v, opt: { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: true, preventDefaultMouseMove: !!m } } } var pt = km; var qZ = D6.extend({ type: "dataZoom.inside", init: function (e, i) { this._range }, render: function (m, e, i, k) { qZ.superApply(this, "render", arguments); this._range = m.getPercentRange(); o9(this.getTargetCoordInfo(), function (v, Z) { var v1 = Ef(v, function (v2) { return j3(v2.model) }); o9(v, function (v2) { var Ij = v2.model; var v3 = {}; o9(["pan", "zoom", "scrollMove"], function (Ik) { v3[Ik] = pt(cu[Ik], this, v2, Z) }, this); aD(i, { coordId: j3(Ij), allCoordIds: v1, containsPoint: function (Il, Ik, Im) { return Ij.coordinateSystem.containPoint([Ik, Im]) }, dataZoomId: m.id, dataZoomModel: m, getRange: v3 }) }, this) }, this) }, dispose: function () { fk(this.api, this.dataZoomModel.id); qZ.superApply(this, "dispose", arguments); this._range = null } }); var cu = { zoom: function (i, m, v2, v3) { var Z = this._range; var v1 = Z.slice(); var Il = i.axisModels[0]; if (!Il) { return } var Ik = vD[m](null, [v3.originX, v3.originY], Il, v2, i); var k = (Ik.signal > 0 ? (Ik.pixelStart + Ik.pixelLength - Ik.pixel) : (Ik.pixel - Ik.pixelStart)) / Ik.pixelLength * (v1[1] - v1[0]) + v1[0]; var v = Math.max(1 / v3.scale, 0); v1[0] = (v1[0] - k) * v + k; v1[1] = (v1[1] - k) * v + k; var Ij = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); nv(0, v1, [0, 100], 0, Ij.minSpan, Ij.maxSpan); this._range = v1; if (Z[0] !== v1[0] || Z[1] !== v1[1]) { return v1 } }, pan: cz(function (k, m, v, v1, i, Z) { var v2 = vD[v1]([Z.oldX, Z.oldY], [Z.newX, Z.newY], m, i, v); return v2.signal * (k[1] - k[0]) * v2.pixel / v2.pixelLength }), scrollMove: cz(function (k, m, v, v1, i, Z) { return (k[1] - k[0]) * Z.scrollDelta }) }; function cz(e) { return function (v, v2, i, v1) { var v3 = this._range; var k = v3.slice(); var m = v.axisModels[0]; if (!m) { return } var Z = e(k, m, v, v2, i, v1); nv(Z, k, [0, 100], "all"); this._range = k; if (v3[0] !== k[0] || v3[1] !== k[1]) { return k } } } var vD = { grid: function (v2, i, m, e, Z) { var v = m.axis; var k = {}; var v1 = Z.model.coordinateSystem.getRect(); v2 = v2 || [0, 0]; if (v.dim === "x") { k.pixel = i[0] - v2[0]; k.pixelLength = v1.width; k.pixelStart = v1.x; k.signal = v.inverse ? 1 : -1 } else { k.pixel = i[1] - v2[1]; k.pixelLength = v1.height; k.pixelStart = v1.y; k.signal = v.inverse ? -1 : 1 } return k }, polar: function (e, m, Ij, v1, i) { var v = Ij.axis; var v2 = {}; var k = i.model.coordinateSystem; var Z = k.getRadiusAxis().getExtent(); var v3 = k.getAngleAxis().getExtent(); e = e ? k.pointToCoord(e) : [0, 0]; m = k.pointToCoord(m); if (Ij.mainType === "radiusAxis") { v2.pixel = m[0] - e[0]; v2.pixelLength = Z[1] - Z[0]; v2.pixelStart = Z[0]; v2.signal = v.inverse ? 1 : -1 } else { v2.pixel = m[1] - e[1]; v2.pixelLength = v3[1] - v3[0]; v2.pixelStart = v3[0]; v2.signal = v.inverse ? -1 : 1 } return v2 }, singleAxis: function (v2, i, m, e, Z) { var v = m.axis; var v1 = Z.model.coordinateSystem.getRect(); var k = {}; v2 = v2 || [0, 0]; if (v.orient === "horizontal") { k.pixel = i[0] - v2[0]; k.pixelLength = v1.width; k.pixelStart = v1.x; k.signal = v.inverse ? 1 : -1 } else { k.pixel = i[1] - v2[1]; k.pixelLength = v1.height; k.pixelStart = v1.y; k.signal = v.inverse ? -1 : 1 } return k } }; eb({ getTargetSeries: function (e) { var i = CJ(); e.eachComponent("dataZoom", function (k) { k.eachTargetAxis(function (m, v, v1) { var Z = v1.getAxisProxy(m.name, v); o9(Z.getTargetSeriesModels(), function (v2) { i.set(v2.uid, v2) }) }) }); return i }, modifyOutputEnd: true, overallReset: function (e, i) { e.eachComponent("dataZoom", function (k) { k.eachTargetAxis(function (m, v, Z) { Z.getAxisProxy(m.name, v).reset(Z, i) }); k.eachTargetAxis(function (m, v, Z) { Z.getAxisProxy(m.name, v).filterData(Z, i) }) }); e.eachComponent("dataZoom", function (Z) { var m = Z.findRepresentativeAxisProxy(); var k = m.getDataPercentWindow(); var v = m.getDataValueWindow(); Z.setRawRange({ start: k[0], end: k[1], startValue: v[0], endValue: v[1] }, true) }) } }); b1("dataZoom", function (i, e) { var k = pW(km(e.eachComponent, e, "dataZoom"), iO, function (Z, v) { return Z.get(v.axisIndex) }); var m = []; e.eachComponent({ mainType: "dataZoom", query: i }, function (Z, v) { m.push.apply(m, k(Z).nodes) }); o9(m, function (Z, v) { Z.setRawRange({ start: i.start, end: i.end, startValue: i.startValue, endValue: i.endValue }) }) }); var tr = o9; var HY = function (i) {
    var e = i && i.visualMap; if (!GG(e)) { e = e ? [e] : [] } tr(e, function (k) {
      if (!k) { return } if (oM(k, "splitList") && !oM(k, "pieces")) { k.pieces = k.splitList; delete k.splitList } var m = k.pieces; if (m && GG(m)) {
        tr(m, function (v) {
          if (tJ(v)) {
            if (oM(v, "start") && !oM(v, "min")) { v.min = v.start } if (oM(v, "end") && !oM(v, "max")) {
              v.max = v.end
            }
          }
        })
      }
    })
  }; function oM(i, e) { return i && i.hasOwnProperty && i.hasOwnProperty(e) } aH.registerSubTypeDefaulter("visualMap", function (e) { return (!e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable)) ? "continuous" : "piecewise" }); var oG = B6.VISUAL.COMPONENT; G(oG, { createOnAllSeries: true, reset: function (i, e) { var k = []; e.eachComponent("visualMap", function (m) { var v = i.pipelineContext; if (!m.isTargetSeries(i) || (v && v.large)) { return } k.push(lm(m.stateList, m.targetVisuals, km(m.getValueState, m), m.getDataDimension(i.getData()))) }); return k } }); G(oG, { createOnAllSeries: true, reset: function (i, e) { var m = i.getData(); var k = []; e.eachComponent("visualMap", function (v1) { if (v1.isTargetSeries(i)) { var v = v1.getVisualMeta(km(dl, null, i, v1)) || { stops: [], outerColors: [] }; var v2 = v1.getDataDimension(m); var Z = m.getDimensionInfo(v2); if (Z != null) { v.dimension = Z.index; k.push(v) } } }); i.getData().setVisual("visualMeta", k) } }); function dl(Z, In, Im, v) { var v2 = In.targetVisuals[v]; var k = mH.prepareVisualTypes(v2); var m = { color: Z.getData().getVisual("color") }; for (var v1 = 0, v3 = k.length; v1 < v3; v1++) { var Ik = k[v1]; var e = v2[Ik === "opacity" ? "__alphaForOpacity" : Ik]; e && e.applyVisual(Im, Ij, Il) } return m.color; function Ij(i) { return m[i] } function Il(i, Io) { m[i] = Io } } var HH = { get: function (m, i, e) { var k = C5((qf[m] || {})[i]); return e ? (GG(k) ? k[k.length - 1] : k) : k } }; var qf = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [0.3, 1], inactive: [0, 0] }, colorLightness: { active: [0.9, 0.5], inactive: [0, 0] }, colorAlpha: { active: [0.3, 1], inactive: [0, 0] }, opacity: { active: [0.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } }; var mL = mH.mapVisual; var ox = mH.eachVisual; var Id = GG; var tq = o9; var EW = o7; var lZ = EQ; var vH = V; var nO = p2({
    type: "visualMap", dependencies: ["series"], stateList: ["inRange", "outOfRange"], replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"], dataBound: [-Infinity, Infinity], layoutMode: { type: "box", ignoreSize: true }, defaultOption: { show: true, zlevel: 0, z: 4, seriesIndex: "all", min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: false, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: "#333" } }, init: function (k, i, e) { this._dataExtent; this.targetVisuals = {}; this.controllerVisuals = {}; this.textStyleModel; this.itemSize; this.mergeDefaultAndTheme(k, e) }, optionUpdated: function (i, k) { var e = this.option; if (!sW.canvasSupported) { e.realtime = false } !k && nc(e, i, this.replacableOptionKeys); this.textStyleModel = this.getModel("textStyle"); this.resetItemSize(); this.completeVisualOption() }, resetVisual: function (i) { var e = this.stateList; i = km(i, this); this.controllerVisuals = Ab(this.option.controller, e, i); this.targetVisuals = Ab(this.option.target, e, i) }, getTargetSeriesIndices: function () { var e = this.option.seriesIndex; var i = []; if (e == null || e === "all") { this.ecModel.eachSeries(function (k, m) { i.push(m) }) } else { i = mp(e) } return i }, eachTargetSeries: function (i, e) { o9(this.getTargetSeriesIndices(), function (k) { i.call(e, this.ecModel.getSeriesByIndex(k)) }, this) }, isTargetSeries: function (e) { var i = false; this.eachTargetSeries(function (k) { k === e && (i = true) }); return i }, formatValueText: function (v2, Z, v1) { var k = this.option; var m = k.precision; var v = this.dataBound; var v3 = k.formatter; var Ij; var i; v1 = v1 || ["<", ">"]; if (GG(v2)) { v2 = v2.slice(); Ij = true } i = Z ? v2 : (Ij ? [e(v2[0]), e(v2[1])] : e(v2)); if (wb(v3)) { return v3.replace("{value}", Ij ? i[0] : i).replace("{value2}", Ij ? i[1] : i) } else { if (E5(v3)) { return Ij ? v3(v2[0], v2[1]) : v3(v2) } } if (Ij) { if (v2[0] === v[0]) { return v1[0] + " " + i[1] } else { if (v2[1] === v[1]) { return v1[1] + " " + i[0] } else { return i[0] + " - " + i[1] } } } else { return i } function e(Ik) { return Ik === v[0] ? "min" : Ik === v[1] ? "max" : (+Ik).toFixed(Math.min(m, 20)) } }, resetExtent: function () { var e = this.option; var i = EW([e.min, e.max]); this._dataExtent = i }, getDataDimension: function (v) { var v2 = this.option.dimension; var v1 = v.dimensions; if (v2 == null && !v1.length) { return } if (v2 != null) { return v.getDimension(v2) } var k = v.dimensions; for (var m = k.length - 1; m >= 0; m--) { var Z = k[m]; var e = v.getDimensionInfo(Z); if (!e.isCalculationCoord) { return Z } } }, getExtent: function () { return this._dataExtent.slice() }, completeVisualOption: function () {
      var m = this.ecModel; var v2 = this.option; var e = { inRange: v2.inRange, outOfRange: v2.outOfRange }; var v = v2.target || (v2.target = {}); var k = v2.controller || (v2.controller = {}); v4(v, e); v4(k, e); var Z = this.isCategory(); v1.call(this, v); v1.call(this, k); v3.call(this, v, "inRange", "outOfRange"); i.call(this, k); function v1(Ij) { if (Id(v2.color) && !Ij.inRange) { Ij.inRange = { color: v2.color.slice().reverse() } } Ij.inRange = Ij.inRange || { color: m.get("gradientColor") }; tq(this.stateList, function (Il) { var Im = Ij[Il]; if (wb(Im)) { var Ik = HH.get(Im, "active", Z); if (Ik) { Ij[Il] = {}; Ij[Il][Im] = Ik } else { delete Ij[Il] } } }, this) } function v3(Im, In, Ik) {
        var Il = Im[In];
        var Ij = Im[Ik]; if (Il && !Ij) { Ij = Im[Ik] = {}; tq(Il, function (Iq, Ip) { if (!mH.isValidType(Ip)) { return } var Io = HH.get(Ip, "inactive", Z); if (Io != null) { Ij[Ip] = Io; if (Ip === "color" && !Ij.hasOwnProperty("opacity") && !Ij.hasOwnProperty("colorAlpha")) { Ij.opacity = [0, 0] } } }) }
      } function i(Ij) { var Im = (Ij.inRange || {}).symbol || (Ij.outOfRange || {}).symbol; var Il = (Ij.inRange || {}).symbolSize || (Ij.outOfRange || {}).symbolSize; var Ik = this.get("inactiveColor"); tq(this.stateList, function (Iq) { var Ir = this.itemSize; var Ip = Ij[Iq]; if (!Ip) { Ip = Ij[Iq] = { color: Z ? Ik : [Ik] } } if (Ip.symbol == null) { Ip.symbol = Im && C5(Im) || (Z ? "roundRect" : ["roundRect"]) } if (Ip.symbolSize == null) { Ip.symbolSize = Il && C5(Il) || (Z ? Ir[0] : [Ir[0], Ir[0]]) } Ip.symbol = mL(Ip.symbol, function (Is) { return (Is === "none" || Is === "square") ? "roundRect" : Is }); var Io = Ip.symbolSize; if (Io != null) { var In = -Infinity; ox(Io, function (Is) { Is > In && (In = Is) }); Ip.symbolSize = mL(Io, function (Is) { return lZ(Is, [0, In], [0, Ir[0]], true) }) } }, this) }
    }, resetItemSize: function () { this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))] }, isCategory: function () { return !!this.option.categories }, setSelected: vH, getValueState: vH, getVisualMeta: vH
  }); var ny = [20, 140]; var f1 = nO.extend({ type: "visualMap.continuous", defaultOption: { align: "auto", calculable: false, range: null, realtime: true, itemHeight: null, itemWidth: null, hoverLink: true, hoverLinkDataSize: null, hoverLinkOnHandle: null }, optionUpdated: function (e, i) { f1.superApply(this, "optionUpdated", arguments); this.resetExtent(); this.resetVisual(function (k) { k.mappingMethod = "linear"; k.dataExtent = this.getExtent() }); this._resetRange() }, resetItemSize: function () { f1.superApply(this, "resetItemSize", arguments); var e = this.itemSize; this._orient === "horizontal" && e.reverse(); (e[0] == null || isNaN(e[0])) && (e[0] = ny[0]); (e[1] == null || isNaN(e[1])) && (e[1] = ny[1]) }, _resetRange: function () { var i = this.getExtent(); var e = this.option.range; if (!e || e.auto) { i.auto = 1; this.option.range = i } else { if (GG(e)) { if (e[0] > e[1]) { e.reverse() } e[0] = Math.max(e[0], i[0]); e[1] = Math.min(e[1], i[1]) } } }, completeVisualOption: function () { nO.prototype.completeVisualOption.apply(this, arguments); o9(this.stateList, function (i) { var e = this.option.controller[i].symbolSize; if (e && e[0] !== e[1]) { e[0] = 0 } }, this) }, setSelected: function (e) { this.option.range = e.slice(); this._resetRange() }, getSelected: function () { var i = this.getExtent(); var e = o7((this.get("range") || []).slice()); e[0] > i[1] && (e[0] = i[1]); e[1] > i[1] && (e[1] = i[1]); e[0] < i[0] && (e[0] = i[0]); e[1] < i[0] && (e[1] = i[0]); return e }, getValueState: function (k) { var e = this.option.range; var i = this.getExtent(); return ((e[0] <= i[0] || e[0] <= k) && (e[1] >= i[1] || k <= e[1])) ? "inRange" : "outOfRange" }, findTargetDataIndices: function (i) { var e = []; this.eachTargetSeries(function (k) { var v = []; var m = k.getData(); m.each(this.getDataDimension(m), function (v1, Z) { i[0] <= v1 && v1 <= i[1] && v.push(Z) }, this); e.push({ seriesId: k.id, dataIndex: v }) }, this); return e }, getVisualMeta: function (v2) { var m = zT(this, "outOfRange", this.getExtent()); var Ik = zT(this, "inRange", this.option.range.slice()); var v3 = []; function k(Im, Il) { v3.push({ value: Im, color: v2(Im, Il) }) } var Z = 0; var Ij = 0; var i = Ik.length; var v1 = m.length; for (; Ij < v1 && (!Ik.length || m[Ij] <= Ik[0]); Ij++) { if (m[Ij] < Ik[Z]) { k(m[Ij], "outOfRange") } } for (var v = 1; Z < i; Z++ , v = 0) { v && v3.length && k(Ik[Z], "outOfRange"); k(Ik[Z], "inRange") } for (var v = 1; Ij < v1; Ij++) { if (!Ik.length || Ik[Ik.length - 1] < m[Ij]) { if (v) { v3.length && k(v3[v3.length - 1].value, "outOfRange"); v = 0 } k(m[Ij], "outOfRange") } } var e = v3.length; return { stops: v3, outerColors: [e ? v3[0].color : "transparent", e ? v3[e - 1].color : "transparent"] } } }); function zT(k, e, v3) { if (v3[0] === v3[1]) { return v3.slice() } var v1 = 200; var Z = (v3[1] - v3[0]) / v1; var v2 = v3[0]; var v = []; for (var m = 0; m <= v1 && v2 < v3[1]; m++) { v.push(v2); v2 += Z } v.push(v3[1]); return v } var xH = qy({ type: "visualMap", autoPositionValues: { left: 1, right: 1, top: 1, bottom: 1 }, init: function (e, i) { this.ecModel = e; this.api = i; this.visualMapModel }, render: function (i, e, k, m) { this.visualMapModel = i; if (i.get("show") === false) { this.group.removeAll(); return } this.doRender.apply(this, arguments) }, renderBackground: function (m) { var e = this.visualMapModel; var k = Bj(e.get("padding") || 0); var i = m.getBoundingRect(); m.add(new EH({ z2: -1, silent: true, shape: { x: i.x - k[3], y: i.y - k[0], width: i.width + k[3] + k[1], height: i.height + k[0] + k[2] }, style: { fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth") } })) }, getControllerVisual: function (v1, m, e) { e = e || {}; var k = e.forceState; var Ik = this.visualMapModel; var v3 = {}; if (m === "symbol") { v3.symbol = Ik.get("itemSymbol") } if (m === "color") { var v = Ik.get("contentColor"); v3.color = v } function Ij(Il) { return v3[Il] } function Z(Il, Im) { v3[Il] = Im } var v2 = Ik.controllerVisuals[k || Ik.getValueState(v1)]; var i = mH.prepareVisualTypes(v2); o9(i, function (Im) { var Il = v2[Im]; if (e.convertOpacityToAlpha && Im === "opacity") { Im = "colorAlpha"; Il = v2.__alphaForOpacity } if (mH.dependsOn(Im, m)) { Il && Il.applyVisual(v1, Ij, Z) } }); return v3[m] }, positionGroup: function (k) { var e = this.visualMapModel; var i = this.api; Ax(k, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }) }, doRender: V }); function F0(Il, v3, In) {
    var v2 = Il.option;
    var e = v2.align; if (e != null && e !== "auto") { return e } var Ik = { width: v3.getWidth(), height: v3.getHeight() }; var m = v2.orient === "horizontal" ? 1 : 0; var Im = [["left", "right", "width"], ["top", "bottom", "height"]]; var k = Im[m]; var v = [0, null, 10]; var v1 = {}; for (var Z = 0; Z < 3; Z++) { v1[Im[1 - m][Z]] = v[Z]; v1[k[Z]] = Z === 2 ? In[0] : v2[k[Z]] } var Io = [["x", "width", 3], ["y", "height", 0]][m]; var Ij = kV(v1, Ik, v2.padding); return k[(Ij.margin[Io[2]] || 0) + Ij[Io[0]] + Ij[Io[1]] * 0.5 < Ik[Io[1]] * 0.5 ? 0 : 1]
  } function bc(e) { o9(e || [], function (i) { if (e.dataIndex != null) { e.dataIndexInside = e.dataIndex; e.dataIndex = null } }); return e } var lY = EQ; var tp = o9; var jp = Math.min; var AF = Math.max; var bY = 12; var fN = 6; var gB = xH.extend({
    type: "visualMap.continuous", init: function () { gB.superApply(this, "init", arguments); this._shapes = {}; this._dataInterval = []; this._handleEnds = []; this._orient; this._useHandle; this._hoverLinkDataIndices = []; this._dragging; this._hovering }, doRender: function (i, e, k, m) { if (!m || m.type !== "selectDataRange" || m.from !== this.uid) { this._buildView() } }, _buildView: function () { this.group.removeAll(); var k = this.visualMapModel; var i = this.group; this._orient = k.get("orient"); this._useHandle = k.get("calculable"); this._resetInterval(); this._renderBar(i); var e = k.get("text"); this._renderEndsText(i, e, 0); this._renderEndsText(i, e, 1); this._updateView(true); this.renderBackground(i); this._updateView(); this._enableHoverLinkToSeries(); this._enableHoverLinkFromSeries(); this.positionGroup(i) }, _renderEndsText: function (v3, i, Il) { if (!i) { return } var Ij = i[1 - Il]; Ij = Ij != null ? Ij + "" : ""; var v2 = this.visualMapModel; var e = v2.get("textGap"); var Ik = v2.itemSize; var v1 = this._shapes.barGroup; var m = this._applyTransform([Ik[0] / 2, Il === 0 ? -e : Ik[1] + e], v1); var v = this._applyTransform(Il === 0 ? "bottom" : "top", v1); var k = this._orient; var Z = this.visualMapModel.textStyleModel; this.group.add(new iR({ style: { x: m[0], y: m[1], textVerticalAlign: k === "horizontal" ? "middle" : v, textAlign: k === "horizontal" ? v : "center", text: Ij, textFont: Z.getFont(), textFill: Z.getTextColor() } })) }, _renderBar: function (Z) { var v3 = this.visualMapModel; var k = this._shapes; var Ij = v3.itemSize; var m = this._orient; var v = this._useHandle; var i = F0(v3, this.api, Ij); var v1 = k.barGroup = this._createBarGroup(i); v1.add(k.outOfRange = vi()); v1.add(k.inRange = vi(null, v ? ul(this._orient) : null, km(this._dragHandle, this, "all", false), km(this._dragHandle, this, "all", true))); var v2 = v3.textStyleModel.getTextRect(""); var e = AF(v2.width, v2.height); if (v) { k.handleThumbs = []; k.handleLabels = []; k.handleLabelPoints = []; this._createHandle(v1, 0, Ij, e, m, i); this._createHandle(v1, 1, Ij, e, m, i) } this._createIndicator(v1, Ij, e, m); Z.add(v1) }, _createHandle: function (Ik, k, Il, e, Z) { var v3 = km(this._dragHandle, this, k, false); var m = km(this._dragHandle, this, k, true); var v2 = vi(zR(k, e), ul(this._orient), v3, m); v2.position[0] = Il[0]; Ik.add(v2); var Ij = this.visualMapModel.textStyleModel; var v = new iR({ draggable: true, drift: v3, onmousemove: function (Im) { GP(Im.event) }, ondragend: m, style: { x: 0, y: 0, text: "", textFont: Ij.getFont(), textFill: Ij.getTextColor() } }); this.group.add(v); var v1 = [Z === "horizontal" ? e / 2 : e * 1.5, Z === "horizontal" ? (k === 0 ? -(e * 1.5) : (e * 1.5)) : (k === 0 ? -e / 2 : e / 2)]; var i = this._shapes; i.handleThumbs[k] = v2; i.handleLabelPoints[k] = v1; i.handleLabels[k] = v }, _createIndicator: function (v, v3, e, m) { var v1 = vi([[0, 0]], "move"); v1.position[0] = v3[0]; v1.attr({ invisible: true, silent: true }); v.add(v1); var Z = this.visualMapModel.textStyleModel; var i = new iR({ silent: true, invisible: true, style: { x: 0, y: 0, text: "", textFont: Z.getFont(), textFill: Z.getTextColor() } }); this.group.add(i); var v2 = [m === "horizontal" ? e / 2 : fN + 3, 0]; var k = this._shapes; k.indicator = v1; k.indicatorLabel = i; k.indicatorLabelPoint = v2 }, _dragHandle: function (v, m, i, e) { if (!this._useHandle) { return } this._dragging = !m; if (!m) { var k = this._applyTransform([i, e], this._shapes.barGroup, true); this._updateInterval(v, k[1]); this._updateView() } if (m === !this.visualMapModel.get("realtime")) { this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }) } if (m) { !this._hovering && this._clearHoverLinkToSeries() } else { if (vO(this.visualMapModel)) { this._doHoverLinkToSeries(this._handleEnds[v], false) } } }, _resetInterval: function () { var i = this.visualMapModel; var k = this._dataInterval = i.getSelected(); var m = i.getExtent(); var e = [0, i.itemSize[1]]; this._handleEnds = [lY(k[0], m, e, true), lY(k[1], m, e, true)] }, _updateInterval: function (Z, v) { v = v || 0; var i = this.visualMapModel; var m = this._handleEnds; var e = [0, i.itemSize[1]]; nv(v, m, e, Z, 0); var k = i.getExtent(); this._dataInterval = [lY(m[0], e, k, true), lY(m[1], e, k, true)] }, _updateView: function (v2) { var m = this.visualMapModel; var Z = m.getExtent(); var k = this._shapes; var i = [0, m.itemSize[1]]; var v = v2 ? i : this._handleEnds; var v1 = this._createBarVisual(this._dataInterval, Z, v, "inRange"); var e = this._createBarVisual(Z, Z, i, "outOfRange"); k.inRange.setStyle({ fill: v1.barColor, opacity: v1.opacity }).setShape("points", v1.barPoints); k.outOfRange.setStyle({ fill: e.barColor, opacity: e.opacity }).setShape("points", e.barPoints); this._updateHandle(v, v1) }, _createBarVisual: function (Z, v1, v2, k) {
      var v = { forceState: k, convertOpacityToAlpha: true };
      var i = this._makeColorGradient(Z, v); var m = [this.getControllerVisual(Z[0], "symbolSize", v), this.getControllerVisual(Z[1], "symbolSize", v)]; var e = this._createBarPoints(v2, m); return { barColor: new uD(0, 0, 0, 1, i), barPoints: e, handlesColor: [i[0].color, i[i.length - 1].color] }
    }, _makeColorGradient: function (v2, v1) { var e = 100; var m = []; var Z = (v2[1] - v2[0]) / e; m.push({ color: this.getControllerVisual(v2[0], "color", v1), offset: 0 }); for (var v = 1; v < e; v++) { var k = v2[0] + Z * v; if (k > v2[1]) { break } m.push({ color: this.getControllerVisual(k, "color", v1), offset: v / e }) } m.push({ color: this.getControllerVisual(v2[1], "color", v1), offset: 1 }); return m }, _createBarPoints: function (k, e) { var i = this.visualMapModel.itemSize; return [[i[0] - e[0], k[0]], [i[0], k[0]], [i[0], k[1]], [i[0] - e[1], k[1]]] }, _createBarGroup: function (i) { var k = this._orient; var e = this.visualMapModel.get("inverse"); return new B8((k === "horizontal" && !e) ? { scale: i === "bottom" ? [1, 1] : [-1, 1], rotation: Math.PI / 2 } : (k === "horizontal" && e) ? { scale: i === "bottom" ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : (k === "vertical" && !e) ? { scale: i === "left" ? [1, -1] : [-1, -1] } : { scale: i === "left" ? [1, 1] : [-1, 1] }) }, _updateHandle: function (Z, v) { if (!this._useHandle) { return } var e = this._shapes; var k = this.visualMapModel; var m = e.handleThumbs; var i = e.handleLabels; tp([0, 1], function (v3) { var v2 = m[v3]; v2.setStyle("fill", v.handlesColor[v3]); v2.position[1] = Z[v3]; var v1 = v7(e.handleLabelPoints[v3], aI(v2, this.group)); i[v3].setStyle({ x: v1[0], y: v1[1], text: k.formatValueText(this._dataInterval[v3]), textVerticalAlign: "middle", textAlign: this._applyTransform(this._orient === "horizontal" ? (v3 === 0 ? "bottom" : "top") : "left", e.barGroup) }) }, this) }, _showIndicator: function (Il, v1, Z, v3) { var Io = this.visualMapModel; var Iq = Io.getExtent(); var Ip = Io.itemSize; var Ij = [0, Ip[1]]; var Im = lY(Il, Iq, Ij, true); var k = this._shapes; var In = k.indicator; if (!In) { return } In.position[1] = Im; In.attr("invisible", false); In.setShape("points", sh(!!Z, v3, Im, Ip[1])); var e = { convertOpacityToAlpha: true }; var v = this.getControllerVisual(Il, "color", e); In.setStyle("fill", v); var m = v7(k.indicatorLabelPoint, aI(In, this.group)); var i = k.indicatorLabel; i.attr("invisible", false); var Ik = this._applyTransform("left", k.barGroup); var v2 = this._orient; i.setStyle({ text: (Z ? Z : "") + Io.formatValueText(v1), textVerticalAlign: v2 === "horizontal" ? Ik : "middle", textAlign: v2 === "horizontal" ? "center" : Ik, x: m[0], y: m[1] }) }, _enableHoverLinkToSeries: function () { var e = this; this._shapes.barGroup.on("mousemove", function (k) { e._hovering = true; if (!e._dragging) { var i = e.visualMapModel.itemSize; var m = e._applyTransform([k.offsetX, k.offsetY], e._shapes.barGroup, true, true); m[1] = jp(AF(0, m[1]), i[1]); e._doHoverLinkToSeries(m[1], 0 <= m[0] && m[0] <= i[0]) } }).on("mouseout", function () { e._hovering = false; !e._dragging && e._clearHoverLinkToSeries() }) }, _enableHoverLinkFromSeries: function () { var e = this.api.getZr(); if (this.visualMapModel.option.hoverLink) { e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this); e.on("mouseout", this._hideIndicator, this) } else { this._clearHoverLinkFromSeries() } }, _doHoverLinkToSeries: function (e, k) { var Ij = this.visualMapModel; var Il = Ij.itemSize; if (!Ij.option.hoverLink) { return } var m = [0, Il[1]]; var Im = Ij.getExtent(); e = jp(AF(m[0], e), m[1]); var i = Aw(Ij, Im, m); var v2 = [e - i, e + i]; var v1 = lY(e, m, Im, true); var Z = [lY(v2[0], m, Im, true), lY(v2[1], m, Im, true)]; v2[0] < m[0] && (Z[0] = -Infinity); v2[1] > m[1] && (Z[1] = Infinity); if (k) { if (Z[0] === -Infinity) { this._showIndicator(v1, Z[1], "< ", i) } else { if (Z[1] === Infinity) { this._showIndicator(v1, Z[0], "> ", i) } else { this._showIndicator(v1, v1, " ", i) } } } var v = this._hoverLinkDataIndices; var v3 = []; if (k || vO(Ij)) { v3 = this._hoverLinkDataIndices = Ij.findTargetDataIndices(Z) } var Ik = co(v, v3); this._dispatchHighDown("downplay", bc(Ik[0])); this._dispatchHighDown("highlight", bc(Ik[1])) }, _hoverLinkFromSeriesMouseOver: function (v1) { var m = v1.target; var i = this.visualMapModel; if (!m || m.dataIndex == null) { return } var k = this.ecModel.getSeriesByIndex(m.seriesIndex); if (!i.isTargetSeries(k)) { return } var Z = k.getData(m.dataType); var v = Z.get(i.getDataDimension(Z), m.dataIndex, true); if (!isNaN(v)) { this._showIndicator(v, v) } }, _hideIndicator: function () { var e = this._shapes; e.indicator && e.indicator.attr("invisible", true); e.indicatorLabel && e.indicatorLabel.attr("invisible", true) }, _clearHoverLinkToSeries: function () { this._hideIndicator(); var e = this._hoverLinkDataIndices; this._dispatchHighDown("downplay", bc(e)); e.length = 0 }, _clearHoverLinkFromSeries: function () { this._hideIndicator(); var e = this.api.getZr(); e.off("mouseover", this._hoverLinkFromSeriesMouseOver); e.off("mouseout", this._hideIndicator) }, _applyTransform: function (v, k, e, m) { var i = aI(k, m ? null : this.group); return yf[GG(v) ? "applyTransform" : "transformDirection"](v, i, e) }, _dispatchHighDown: function (i, e) { e && e.length && this.api.dispatchAction({ type: i, batch: e }) }, dispose: function () { this._clearHoverLinkFromSeries(); this._clearHoverLinkToSeries() }, remove: function () { this._clearHoverLinkFromSeries(); this._clearHoverLinkToSeries() }
  }); function vi(k, m, i, e) { return new ia({ shape: { points: k }, draggable: !!i, cursor: m, drift: i, onmousemove: function (v) { GP(v.event) }, ondragend: e }) } function zR(i, e) {
    return i === 0 ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
  } function sh(i, k, m, e) { return i ? [[0, -jp(k, AF(m, 0))], [fN, 0], [0, jp(k, AF(e - m, 0))]] : [[0, 0], [5, -5], [5, 5]] } function Aw(i, v, e) { var m = bY / 2; var k = i.get("hoverLinkDataSize"); if (k) { m = lY(k, v, e, true) / 2 } return m } function vO(i) { var e = i.get("hoverLinkOnHandle"); return !!(e == null ? i.get("realtime") : e) } function ul(e) { return e === "vertical" ? "ns-resize" : "ew-resize" } var Cd = { type: "selectDataRange", event: "dataRangeSelected", update: "update" }; b1(Cd, function (i, e) { e.eachComponent({ mainType: "visualMap", query: i }, function (k) { k.setSelected(i.selected) }) }); y2(HY); var sX = nO.extend({ type: "visualMap.piecewise", defaultOption: { selected: null, minOpen: false, maxOpen: false, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieceList: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: true, showLabel: null }, optionUpdated: function (i, m) { sX.superApply(this, "optionUpdated", arguments); this._pieceList = []; this.resetExtent(); var k = this._mode = this._determineMode(); ch[this._mode].call(this); this._resetSelected(i, m); var e = this.option.categories; this.resetVisual(function (Z, v) { if (k === "categories") { Z.mappingMethod = "category"; Z.categories = C5(e) } else { Z.dataExtent = this.getExtent(); Z.mappingMethod = "piecewise"; Z.pieceList = Ef(this._pieceList, function (v1) { var v1 = C5(v1); if (v !== "inRange") { v1.visual = null } return v1 }) } }) }, completeVisualOption: function () { var m = this.option; var k = {}; var v = mH.listVisualTypes(); var e = this.isCategory(); o9(m.pieces, function (Z) { o9(v, function (v1) { if (Z.hasOwnProperty(v1)) { k[v1] = 1 } }) }); o9(k, function (Z, v2) { var v1 = 0; o9(this.stateList, function (v3) { v1 |= i(m, v3, v2) || i(m.target, v3, v2) }, this); !v1 && o9(this.stateList, function (v3) { (m[v3] || (m[v3] = {}))[v2] = HH.get(v2, v3 === "inRange" ? "active" : "inactive", e) }) }, this); function i(v2, Z, v1) { return v2 && v2[Z] && (tJ(v2[Z]) ? v2[Z].hasOwnProperty(v1) : v2[Z] === v1) } nO.prototype.completeVisualOption.apply(this, arguments) }, _resetSelected: function (v, Z) { var i = this.option; var e = this._pieceList; var k = (Z ? i : v).selected || {}; i.selected = k; o9(e, function (v3, v1) { var v2 = this.getSelectedMapKey(v3); if (!k.hasOwnProperty(v2)) { k[v2] = true } }, this); if (i.selectedMode === "single") { var m = false; o9(e, function (v3, v1) { var v2 = this.getSelectedMapKey(v3); if (k[v2]) { m ? (k[v2] = false) : (m = true) } }, this) } }, getSelectedMapKey: function (e) { return this._mode === "categories" ? e.value + "" : e.index + "" }, getPieceList: function () { return this._pieceList }, _determineMode: function () { var e = this.option; return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber" }, setSelected: function (e) { this.option.selected = C5(e) }, getValueState: function (i) { var e = mH.findPieceIndex(i, this._pieceList); return e != null ? (this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange") : "outOfRange" }, findTargetDataIndices: function (i) { var e = []; this.eachTargetSeries(function (k) { var v = []; var m = k.getData(); m.each(this.getDataDimension(m), function (v2, v1) { var Z = mH.findPieceIndex(v2, this._pieceList); Z === i && v.push(v1) }, this); e.push({ seriesId: k.id, dataIndex: v }) }, this); return e }, getRepresentValue: function (i) { var e; if (this.isCategory()) { e = i.value } else { if (i.value != null) { e = i.value } else { var k = i.interval || []; e = (k[0] === -Infinity && k[1] === Infinity) ? 0 : (k[0] + k[1]) / 2 } } return e }, getVisualMeta: function (v) { if (this.isCategory()) { return } var m = []; var v1 = []; var i = this; function v2(Ik, Ij) { var Il = i.getRepresentValue({ interval: Ik }); if (!Ij) { Ij = i.getValueState(Il) } var v3 = v(Il, Ij); if (Ik[0] === -Infinity) { v1[0] = v3 } else { if (Ik[1] === Infinity) { v1[1] = v3 } else { m.push({ value: Ik[0], color: v3 }, { value: Ik[1], color: v3 }) } } } var e = this._pieceList.slice(); if (!e.length) { e.push({ interval: [-Infinity, Infinity] }) } else { var k = e[0].interval[0]; k !== -Infinity && e.unshift({ interval: [-Infinity, k] }); k = e[e.length - 1].interval[1]; k !== Infinity && e.push({ interval: [k, Infinity] }) } var Z = -Infinity; o9(e, function (Ij) { var v3 = Ij.interval; if (v3) { v3[0] > Z && v2([Z, v3[0]], "outOfRange"); v2(v3.slice()); Z = v3[1] } }, this); return { stops: m, outerColors: v1 } } }); var ch = {
    splitNumber: function () { var v1 = this.option; var e = this._pieceList; var k = Math.min(v1.precision, 20); var v2 = this.getExtent(); var i = v1.splitNumber; i = Math.max(parseInt(i, 10), 1); v1.splitNumber = i; var Ij = (v2[1] - v2[0]) / i; while (+Ij.toFixed(k) !== Ij && k < 5) { k++ } v1.precision = k; Ij = +Ij.toFixed(k); var v = 0; if (v1.minOpen) { e.push({ index: v++, interval: [-Infinity, v2[0]], close: [0, 0] }) } for (var v3 = v2[0], m = v + i; v < m; v3 += Ij) { var Z = v === i - 1 ? v2[1] : (v3 + Ij); e.push({ index: v++, interval: [v3, Z], close: [1, 1] }) } if (v1.maxOpen) { e.push({ index: v++, interval: [v2[1], Infinity], close: [0, 0] }) } W(e); o9(e, function (Ik) { Ik.text = this.formatValueText(Ik.interval) }, this) }, categories: function () { var e = this.option; o9(e.categories, function (i) { this._pieceList.push({ text: this.formatValueText(i, true), value: i }) }, this); Fe(e, this._pieceList) }, pieces: function () {
      var i = this.option; var e = this._pieceList; o9(i.pieces, function (Z, v2) {
        if (!tJ(Z)) { Z = { value: Z } } var In = { text: "", index: v2 }; if (Z.label != null) { In.text = Z.label } if (Z.hasOwnProperty("value")) { var Ik = In.value = Z.value; In.interval = [Ik, Ik]; In.close = [1, 1] } else {
          var m = In.interval = []; var Im = In.close = [0, 0];
          var k = [1, 0, 1]; var v3 = [-Infinity, Infinity]; var v = []; for (var Il = 0; Il < 2; Il++) { var Ij = [["gte", "gt", "min"], ["lte", "lt", "max"]][Il]; for (var v1 = 0; v1 < 3 && m[Il] == null; v1++) { m[Il] = Z[Ij[v1]]; Im[Il] = k[v1]; v[Il] = v1 === 2 } m[Il] == null && (m[Il] = v3[Il]) } v[0] && m[1] === Infinity && (Im[0] = 0); v[1] && m[0] === -Infinity && (Im[1] = 0); if (ok) { if (m[0] > m[1]) { console.warn("Piece " + v2 + "is illegal: " + m + " lower bound should not greater then uppper bound.") } } if (m[0] === m[1] && Im[0] && Im[1]) { In.value = m[0] }
        } In.visual = mH.retrieveVisuals(Z); e.push(In)
      }, this); Fe(i, e); W(e); o9(e, function (m) { var v = m.close; var k = [["<", ""][v[1]], [">", ""][v[0]]]; m.text = m.text || this.formatValueText(m.value != null ? m.value : m.interval, false, k) }, this)
    }
  }; function Fe(k, i) { var e = k.inverse; if (k.orient === "vertical" ? !e : e) { i.reverse() } } var ho = xH.extend({ type: "visualMap.piecewise", doRender: function () { var v = this.group; v.removeAll(); var Ij = this.visualMapModel; var e = Ij.get("textGap"); var v3 = Ij.textStyleModel; var m = v3.getFont(); var Il = v3.getTextColor(); var i = this._getItemAlign(); var Ik = Ij.itemSize; var k = this._getViewData(); var v1 = k.endsText; var v2 = gu(Ij.get("showLabel", true), !v1); v1 && this._renderEndsText(v, v1[0], Ik, v2, i); o9(k.viewPieceList, Z, this); v1 && this._renderEndsText(v, v1[1], Ik, v2, i); fl(Ij.get("orient"), v, Ij.get("itemGap")); this.renderBackground(v); this.positionGroup(v); function Z(Io) { var In = Io.piece; var Iq = new B8(); Iq.onclick = km(this._onItemClick, this, In); this._enableHoverLink(Iq, Io.indexInModelPieceList); var Im = Ij.getRepresentValue(In); this._createItemSymbol(Iq, Im, [0, 0, Ik[0], Ik[1]]); if (v2) { var Ip = this.visualMapModel.getValueState(Im); Iq.add(new iR({ style: { x: i === "right" ? -e : Ik[0] + e, y: Ik[1] / 2, text: In.text, textVerticalAlign: "middle", textAlign: i, textFont: m, textFill: Il, opacity: Ip === "outOfRange" ? 0.5 : 1 } })) } v.add(Iq) } }, _enableHoverLink: function (k, i) { k.on("mouseover", km(e, this, "highlight")).on("mouseout", km(e, this, "downplay")); function e(v) { var m = this.visualMapModel; m.option.hoverLink && this.api.dispatchAction({ type: v, batch: bc(m.findTargetDataIndices(i)) }) } }, _getItemAlign: function () { var e = this.visualMapModel; var i = e.option; if (i.orient === "vertical") { return F0(e, this.api, e.itemSize) } else { var k = i.align; if (!k || k === "auto") { k = "left" } return k } }, _renderEndsText: function (v, Z, m, i, e) { if (!Z) { return } var v1 = new B8(); var k = this.visualMapModel.textStyleModel; v1.add(new iR({ style: { x: i ? (e === "right" ? m[0] : 0) : m[0] / 2, y: m[1] / 2, textVerticalAlign: "middle", textAlign: i ? e : "center", text: Z, textFont: k.getFont(), textFill: k.getTextColor() } })); v.add(v1) }, _getViewData: function () { var m = this.visualMapModel; var v = Ef(m.getPieceList(), function (v1, Z) { return { piece: v1, indexInModelPieceList: Z } }); var i = m.get("text"); var k = m.get("orient"); var e = m.get("inverse"); if (k === "horizontal" ? e : !e) { v.reverse() } else { if (i) { i = i.slice().reverse() } } return { viewPieceList: v, endsText: i } }, _createItemSymbol: function (i, e, k) { i.add(t9(this.getControllerVisual(e, "symbol"), k[0], k[1], k[2], k[3], this.getControllerVisual(e, "color"))) }, _onItemClick: function (m) { var e = this.visualMapModel; var k = e.option; var i = C5(k.selected); var v = e.getSelectedMapKey(m); if (k.selectedMode === "single") { i[v] = true; o9(i, function (v1, Z) { i[Z] = Z === v }) } else { i[v] = !i[v] } this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: i }) } }); y2(HY); var cn = j7; var cq = mv; function vM(e) { DA(e, "label", ["show"]) } var sz = p2({ type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function (k, i, e, m) { if (ok) { if (this.type === "marker") { throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.") } } this.mergeDefaultAndTheme(k, e); this.mergeOption(k, e, m.createdBySelf, true) }, isAnimationEnabled: function () { if (sW.node) { return false } var e = this.__hostSeries; return this.getShallow("animation") && e && e.isAnimationEnabled() }, mergeOption: function (v, k, i, Z) { var m = this.constructor; var e = this.mainType + "Model"; if (!i) { k.eachSeries(function (v2) { var v3 = v2.get(this.mainType, true); var v1 = v2[e]; if (!v3 || !v3.data) { v2[e] = null; return } if (!v1) { if (Z) { vM(v3) } o9(v3.data, function (Ij) { if (Ij instanceof Array) { vM(Ij[0]); vM(Ij[1]) } else { vM(Ij) } }); v1 = new m(v3, this, k); b0(v1, { mainType: this.mainType, seriesIndex: v2.seriesIndex, name: v2.name, createdBySelf: true }); v1.__hostSeries = v2 } else { v1.mergeOption(v3, k, true) } v2[e] = v1 }, this) } }, formatTooltip: function (k) { var Z = this.getData(); var v = this.getRawValue(k); var m = GG(v) ? Ef(v, cn).join(", ") : cn(v); var e = Z.getName(k); var i = cq(this.name); if (v != null || e) { i += "<br />" } if (e) { i += cq(e); if (v != null) { i += " : " } } if (v != null) { i += cq(m) } return i }, getData: function () { return this._data }, setData: function (e) { this._data = e } }); Gq(sz, u8); sz.extend({ type: "markPoint", defaultOption: { zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: true, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: true } } } }); var iq = eP; function lS(e) { return !(isNaN(parseFloat(e.x)) && isNaN(parseFloat(e.y))) } function jf(e) { return !isNaN(parseFloat(e.x)) && !isNaN(parseFloat(e.y)) } function sU(e, k, v2, i, v, Ik) {
    var Il = []; var Z = lU(k, i); var v1 = Z ? k.getCalculationInfo("stackResultDimension") : i;
    var Ij = xb(k, v1, e); var v3 = k.indicesOfNearest(v1, Ij)[0]; Il[v] = k.get(v2, v3); Il[Ik] = k.get(i, v3); var m = oK(k.get(i, v3)); m = Math.min(m, 20); if (m >= 0) { Il[Ik] = +Il[Ik].toFixed(m) } return Il
  } var ue = sv; var dy = { min: ue(sU, "min"), max: ue(sU, "max"), average: ue(sU, "average") }; function Fc(e, Ik) { var Z = e.getData(); var k = e.coordinateSystem; if (Ik && !jf(Ik) && !GG(Ik.coord) && k) { var v3 = k.dimensions; var m = H7(Ik, Z, k, e); Ik = C5(Ik); if (Ik.type && dy[Ik.type] && m.baseAxis && m.valueAxis) { var v1 = iq(v3, m.baseAxis.dim); var Ij = iq(v3, m.valueAxis.dim); Ik.coord = dy[Ik.type](Z, m.baseDataDim, m.valueDataDim, v1, Ij); Ik.value = Ik.coord[Ij] } else { var v2 = [Ik.xAxis != null ? Ik.xAxis : Ik.radiusAxis, Ik.yAxis != null ? Ik.yAxis : Ik.angleAxis]; for (var v = 0; v < 2; v++) { if (dy[v2[v]]) { v2[v] = xb(Z, Z.mapDimension(v3[v]), v2[v]) } } Ik.coord = v2 } } return Ik } function H7(m, v, k, e) { var i = {}; if (m.valueIndex != null || m.valueDim != null) { i.valueDataDim = m.valueIndex != null ? v.getDimension(m.valueIndex) : m.valueDim; i.valueAxis = k.getAxis(uW(e, i.valueDataDim)); i.baseAxis = k.getOtherAxis(i.valueAxis); i.baseDataDim = v.mapDimension(i.baseAxis.dim) } else { i.baseAxis = e.getBaseAxis(); i.valueAxis = k.getOtherAxis(i.baseAxis); i.baseDataDim = v.mapDimension(i.baseAxis.dim); i.valueDataDim = v.mapDimension(i.valueAxis.dim) } return i } function uW(m, k) { var v1 = m.getData(); var Z = v1.dimensions; k = v1.getDimension(k); for (var v = 0; v < Z.length; v++) { var e = v1.getDimensionInfo(Z[v]); if (e.name === k) { return e.coordDim } } } function c1(e, i) { return (e && e.containData && i.coord && !lS(i)) ? e.containData(i.coord) : true } function gJ(i, m, e, k) { if (k < 2) { return i.coord && i.coord[k] } return i.value } function xb(m, v, i) { if (i === "average") { var e = 0; var k = 0; m.each(v, function (v1, Z) { if (!isNaN(v1)) { e += v1; k++ } }); return e / k } else { if (i === "median") { return m.getMedian(v) } else { return m.getDataExtent(v, true)[i === "max" ? 1 : 0] } } } var tj = qy({ type: "marker", init: function () { this.markerGroupMap = CJ() }, render: function (i, e, k) { var v = this.markerGroupMap; v.each(function (Z) { Z.__keep = false }); var m = this.type + "Model"; e.eachSeries(function (v1) { var Z = v1[m]; Z && this.renderSeries(v1, Z, e, k) }, this); v.each(function (Z) { !Z.__keep && this.group.remove(Z.group) }, this) }, renderSeries: function () { } }); function g9(m, e, k) { var i = e.coordinateSystem; m.each(function (v1) { var v2 = m.getItemModel(v1); var Z; var Ik = zN(v2.get("x"), k.getWidth()); var v3 = zN(v2.get("y"), k.getHeight()); if (!isNaN(Ik) && !isNaN(v3)) { Z = [Ik, v3] } else { if (e.getMarkerPosition) { Z = e.getMarkerPosition(m.getValues(m.dimensions, v1)) } else { if (i) { var v = m.get(i.dimensions[0], v1); var Ij = m.get(i.dimensions[1], v1); Z = i.dataToPoint([v, Ij]) } } } if (!isNaN(Ik)) { Z[0] = Ik } if (!isNaN(v3)) { Z[1] = v3 } m.setItemLayout(v1, Z) }) } tj.extend({ type: "markPoint", updateTransform: function (k, e, i) { e.eachSeries(function (m) { var v = m.markPointModel; if (v) { g9(v.getData(), m, i); this.markerGroupMap.get(m.id).updateLayout(v) } }, this) }, renderSeries: function (k, v2, Z, v1) { var m = k.coordinateSystem; var v3 = k.id; var i = k.getData(); var Ij = this.markerGroupMap; var e = Ij.get(v3) || Ij.set(v3, new E9()); var v = aC(m, k, v2); v2.setData(v); g9(v2.getData(), k, v1); v.each(function (Ik) { var Il = v.getItemModel(Ik); var Im = Il.getShallow("symbolSize"); if (typeof Im === "function") { Im = Im(v2.getRawValue(Ik), v2.getDataParams(Ik)) } v.setItemVisual(Ik, { symbolSize: Im, color: Il.get("itemStyle.color") || i.getVisual("color"), symbol: Il.getShallow("symbol") }) }); e.updateData(v); this.group.add(e.group); v.eachItemGraphicEl(function (Ik) { Ik.traverse(function (Il) { Il.dataModel = v2 }) }); e.__keep = true; e.group.silent = v2.get("silent") || k.get("silent") } }); function aC(i, e, Z) { var k; if (i) { k = Ef(i && i.dimensions, function (v1) { var v2 = e.getData().getDimensionInfo(e.getData().mapDimension(v1)) || {}; return De({ name: v1 }, v2) }) } else { k = [{ name: "value", type: "float" }] } var m = new xt(k, Z); var v = Ef(Z.get("data"), sv(Fc, e)); if (i) { v = q4(v, sv(c1, i)) } m.initData(v, null, i ? gJ : function (v1) { return v1.value }); return m } y2(function (e) { e.markPoint = e.markPoint || {} }); sz.extend({ type: "markLine", defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { show: true, position: "end" }, lineStyle: { type: "dashed" }, emphasis: { label: { show: true }, lineStyle: { width: 3 } }, animationEasing: "linear" } }); var yu = function (k, v, v2, In) { var Z = k.getData(); var e = In.type; if (!GG(In) && (e === "min" || e === "max" || e === "average" || e === "median" || (In.xAxis != null || In.yAxis != null))) { var Im; var v3; var Il; if (In.yAxis != null || In.xAxis != null) { v3 = In.yAxis != null ? "y" : "x"; Im = v.getAxis(v3); Il = gu(In.yAxis, In.xAxis) } else { var m = H7(In, Z, v, k); v3 = m.valueDataDim; Im = m.valueAxis; Il = xb(Z, v3, e) } var Ij = v3 === "x" ? 0 : 1; var Ik = 1 - Ij; var i = C5(In); var Io = {}; i.type = null; i.coord = []; Io.coord = []; i.coord[Ik] = -Infinity; Io.coord[Ik] = Infinity; var v1 = v2.get("precision"); if (v1 >= 0 && typeof Il === "number") { Il = +Il.toFixed(Math.min(v1, 20)) } i.coord[Ij] = Io.coord[Ij] = Il; In = [i, Io, { type: e, valueIndex: In.valueIndex, value: Il }] } In = [Fc(k, In[0]), Fc(k, In[1]), b0({}, In[2])]; In[2].type = In[2].type || ""; v4(In[2], In[0]); v4(In[2], In[1]); return In }; function GQ(e) { return !isNaN(e) && !isFinite(e) } function zU(v, e, k, i) {
    var Z = 1 - v; var m = i.dimensions[v]; return GQ(e[Z]) && GQ(k[Z]) && e[v] === k[v] && i.getAxis(m).containData(e[v])
  } function HX(k, m) { if (k.type === "cartesian2d") { var e = m[0].coord; var i = m[1].coord; if (e && i && (zU(1, e, i, k) || zU(0, e, i, k))) { return true } } return c1(k, m[0]) && c1(k, m[1]) } function ih(v2, Im, v1, v, v3) { var Z = v.coordinateSystem; var Io = v2.getItemModel(Im); var In; var e = zN(Io.get("x"), v3.getWidth()); var m = zN(Io.get("y"), v3.getHeight()); if (!isNaN(e) && !isNaN(m)) { In = [e, m] } else { if (v.getMarkerPosition) { In = v.getMarkerPosition(v2.getValues(v2.dimensions, Im)) } else { var Il = Z.dimensions; var Ik = v2.get(Il[0], Im); var Ij = v2.get(Il[1], Im); In = Z.dataToPoint([Ik, Ij]) } if (Z.type === "cartesian2d") { var k = Z.getAxis("x"); var i = Z.getAxis("y"); var Il = Z.dimensions; if (GQ(v2.get(Il[0], Im))) { In[0] = k.toGlobalCoord(k.getExtent()[v1 ? 0 : 1]) } else { if (GQ(v2.get(Il[1], Im))) { In[1] = i.toGlobalCoord(i.getExtent()[v1 ? 0 : 1]) } } } if (!isNaN(e)) { In[0] = e } if (!isNaN(m)) { In[1] = m } } v2.setItemLayout(Im, In) } tj.extend({ type: "markLine", updateTransform: function (i, e, k) { e.eachSeries(function (v) { var m = v.markLineModel; if (m) { var v1 = m.getData(); var v2 = m.__from; var Z = m.__to; v2.each(function (v3) { ih(v2, v3, true, v, k); ih(Z, v3, false, v, k) }); v1.each(function (v3) { v1.setItemLayout(v3, [v2.getItemLayout(v3), Z.getItemLayout(v3)]) }); this.markerGroupMap.get(v.id).updateLayout() } }, this) }, renderSeries: function (m, Z, v1, v2) { var v = m.coordinateSystem; var Il = m.id; var e = m.getData(); var Io = this.markerGroupMap; var v3 = Io.get(Il) || Io.set(Il, new hw()); this.group.add(v3.group); var Ik = aB(v, m, Z); var In = Ik.from; var Ij = Ik.to; var k = Ik.line; Z.__from = In; Z.__to = Ij; Z.setData(k); var Ip = Z.get("symbol"); var i = Z.get("symbolSize"); if (!GG(Ip)) { Ip = [Ip, Ip] } if (typeof i === "number") { i = [i, i] } Ik.from.each(function (Iq) { Im(In, Iq, true); Im(Ij, Iq, false) }); k.each(function (Iq) { var Ir = k.getItemModel(Iq).get("lineStyle.color"); k.setItemVisual(Iq, { color: Ir || In.getItemVisual(Iq, "color") }); k.setItemLayout(Iq, [In.getItemLayout(Iq), Ij.getItemLayout(Iq)]); k.setItemVisual(Iq, { "fromSymbolSize": In.getItemVisual(Iq, "symbolSize"), "fromSymbol": In.getItemVisual(Iq, "symbol"), "toSymbolSize": Ij.getItemVisual(Iq, "symbolSize"), "toSymbol": Ij.getItemVisual(Iq, "symbol") }) }); v3.updateData(k); Ik.line.eachItemGraphicEl(function (Ir, Iq) { Ir.traverse(function (Is) { Is.dataModel = Z }) }); function Im(It, Ir, Iq) { var Is = It.getItemModel(Ir); ih(It, Ir, Iq, m, v2); It.setItemVisual(Ir, { symbolSize: Is.get("symbolSize") || i[Iq ? 0 : 1], symbol: Is.get("symbol", true) || Ip[Iq ? 0 : 1], color: Is.get("itemStyle.color") || e.getVisual("color") }) } v3.__keep = true; v3.group.silent = Z.get("silent") || m.get("silent") } }); function aB(m, i, Z) { var v1; if (m) { v1 = Ef(m && m.dimensions, function (Ij) { var Ik = i.getData().getDimensionInfo(i.getData().mapDimension(Ij)) || {}; return De({ name: Ij }, Ik) }) } else { v1 = [{ name: "value", type: "float" }] } var v3 = new xt(v1, Z); var v2 = new xt(v1, Z); var e = new xt([], Z); var k = Ef(Z.get("data"), sv(yu, i, m, Z)); if (m) { k = q4(k, sv(HX, m)) } var v = m ? gJ : function (Ij) { return Ij.value }; v3.initData(Ef(k, function (Ij) { return Ij[0] }), null, v); v2.initData(Ef(k, function (Ij) { return Ij[1] }), null, v); e.initData(Ef(k, function (Ij) { return Ij[2] })); e.hasItemOption = true; return { from: v3, to: v2, line: e } } y2(function (e) { e.markLine = e.markLine || {} }); sz.extend({ type: "markArea", defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: false, label: { show: true, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: true, position: "top" } } } }); var gI = function (m, v, i, v2) { var Z = Fc(m, v2[0]); var e = Fc(m, v2[1]); var Ij = gu; var v1 = Z.coord; var k = e.coord; v1[0] = Ij(v1[0], -Infinity); v1[1] = Ij(v1[1], -Infinity); k[0] = Ij(k[0], Infinity); k[1] = Ij(k[1], Infinity); var v3 = aa([{}, Z, e]); v3.coord = [Z.coord, e.coord]; v3.x0 = Z.x; v3.y0 = Z.y; v3.x1 = e.x; v3.y1 = e.y; return v3 }; function dC(e) { return !isNaN(e) && !isFinite(e) } function jH(m, e, k, i) { var v = 1 - m; return dC(e[v]) && dC(k[v]) } function Cr(k, m) { var e = m.coord[0]; var i = m.coord[1]; if (k.type === "cartesian2d") { if (e && i && (jH(1, e, i, k) || jH(0, e, i, k))) { return true } } return c1(k, { coord: e, x: m.x0, y: m.y0 }) || c1(k, { coord: i, x: m.x1, y: m.y1 }) } function xY(v1, Il, Ik, v, v2) { var Z = v.coordinateSystem; var In = v1.getItemModel(Il); var Im; var e = zN(In.get(Ik[0]), v2.getWidth()); var m = zN(In.get(Ik[1]), v2.getHeight()); if (!isNaN(e) && !isNaN(m)) { Im = [e, m] } else { if (v.getMarkerPosition) { Im = v.getMarkerPosition(v1.getValues(Ik, Il)) } else { var Ij = v1.get(Ik[0], Il); var v3 = v1.get(Ik[1], Il); var Io = [Ij, v3]; Z.clampData && Z.clampData(Io, Io); Im = Z.dataToPoint(Io, true) } if (Z.type === "cartesian2d") { var k = Z.getAxis("x"); var i = Z.getAxis("y"); var Ij = v1.get(Ik[0], Il); var v3 = v1.get(Ik[1], Il); if (dC(Ij)) { Im[0] = k.toGlobalCoord(k.getExtent()[Ik[0] === "x0" ? 0 : 1]) } else { if (dC(v3)) { Im[1] = i.toGlobalCoord(i.getExtent()[Ik[1] === "y0" ? 0 : 1]) } } } if (!isNaN(e)) { Im[0] = e } if (!isNaN(m)) { Im[1] = m } } return Im } var gf = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]]; tj.extend({
    type: "markArea", updateTransform: function (k, e, i) { e.eachSeries(function (v) { var m = v.markAreaModel; if (m) { var Z = m.getData(); Z.each(function (v1) { var v3 = Ef(gf, function (Ij) { return xY(Z, v1, Ij, v, i) }); Z.setItemLayout(v1, v3); var v2 = Z.getItemGraphicEl(v1); v2.setShape("points", v3) }) } }, this) }, renderSeries: function (v, k, v1, v2) {
      var Z = v.coordinateSystem; var Ij = v.id; var i = v.getData(); var m = this.markerGroupMap;
      var e = m.get(Ij) || m.set(Ij, { group: new B8() }); this.group.add(e.group); e.__keep = true; var v3 = aA(Z, v, k); k.setData(v3); v3.each(function (Ik) { v3.setItemLayout(Ik, Ef(gf, function (Il) { return xY(v3, Ik, Il, v, v2) })); v3.setItemVisual(Ik, { color: i.getVisual("color") }) }); v3.diff(e.__data).add(function (Ik) { var Il = new ia({ shape: { points: v3.getItemLayout(Ik) } }); v3.setItemGraphicEl(Ik, Il); e.group.add(Il) }).update(function (Im, Il) { var Ik = e.__data.getItemGraphicEl(Il); oS(Ik, { shape: { points: v3.getItemLayout(Im) } }, k, Im); e.group.add(Ik); v3.setItemGraphicEl(Im, Ik) }).remove(function (Ik) { var Il = e.__data.getItemGraphicEl(Ik); e.group.remove(Il) }).execute(); v3.eachItemGraphicEl(function (In, Il) { var Io = v3.getItemModel(Il); var Ip = Io.getModel("label"); var Ik = Io.getModel("emphasis.label"); var Im = v3.getItemVisual(Il, "color"); In.useStyle(De(Io.getModel("itemStyle").getItemStyle(), { fill: ik(Im, 0.4), stroke: Im })); In.hoverStyle = Io.getModel("emphasis.itemStyle").getItemStyle(); BD(In.style, In.hoverStyle, Ip, Ik, { labelFetcher: k, labelDataIndex: Il, defaultText: v3.getName(Il) || "", isRectText: true, autoColor: Im }); yn(In, {}); In.dataModel = k }); e.__data = v3; e.group.silent = k.get("silent") || v.get("silent")
    }
  }); function aA(Z, m, k) { var v1; var v; var v2 = ["x0", "y0", "x1", "y1"]; if (Z) { v1 = Ef(Z && Z.dimensions, function (v3) { var Ij = m.getData(); var Ik = Ij.getDimensionInfo(Ij.mapDimension(v3)) || {}; return De({ name: v3 }, Ik) }); v = new xt(Ef(v2, function (Ij, v3) { return { name: Ij, type: v1[v3 % 2].type } }), k) } else { v1 = [{ name: "value", type: "float" }]; v = new xt(v1, k) } var i = Ef(k.get("data"), sv(gI, m, Z, k)); if (Z) { i = q4(i, sv(Cr, Z)) } var e = Z ? function (Ij, Il, v3, Ik) { return Ij.coord[Math.floor(Ik / 2)][Ik % 2] } : function (v3) { return v3.value }; v.initData(i, null, e); v.hasItemOption = true; return v } y2(function (e) { e.markArea = e.markArea || {} }); var HW = function (i) { var e = i && i.timeline; if (!GG(e)) { e = e ? [e] : [] } o9(e, function (k) { if (!k) { return } x(k) }) }; function x(i) { var k = i.type; var e = { "number": "value", "time": "time" }; if (e[k]) { i.axisType = e[k]; delete i.type } B4(i); if (oL(i, "controlPosition")) { var m = i.controlStyle || (i.controlStyle = {}); if (!oL(m, "position")) { m.position = i.controlPosition } if (m.position === "none" && !oL(m, "show")) { m.show = false; delete m.position } delete i.controlPosition } o9(i.data || [], function (v) { if (tJ(v) && !GG(v)) { if (!oL(v, "value") && oL(v, "name")) { v.value = v.name } B4(v) } }) } function B4(m) { var Z = m.itemStyle || (m.itemStyle = {}); var k = Z.emphasis || (Z.emphasis = {}); var i = m.label || (m.label || {}); var v = i.normal || (i.normal = {}); var e = { normal: 1, emphasis: 1 }; o9(i, function (v2, v1) { if (!e[v1] && !oL(v, v1)) { v[v1] = v2 } }); if (k.label && !oL(i, "emphasis")) { i.emphasis = k.label; delete k.label } } function oL(i, e) { return i.hasOwnProperty(e) } aH.registerSubTypeDefaulter("timeline", function () { return "slider" }); b1({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function (k, e) { var i = e.getComponent("timeline"); if (i && k.currentIndex != null) { i.setCurrentIndex(k.currentIndex); if (!i.get("loop", true) && i.isIndexMax()) { i.setPlayState(false) } } e.resetOption("timeline"); return De({ currentIndex: i.option.currentIndex }, k) }); b1({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function (k, e) { var i = e.getComponent("timeline"); if (i && k.playState != null) { i.setPlayState(k.playState) } }); var b4 = aH.extend({ type: "timeline", layoutMode: "box", defaultOption: { zlevel: 0, z: 4, show: true, axisType: "time", realtime: true, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: false, rewind: false, loop: true, playInterval: 2000, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [] }, init: function (k, i, e) { this._data; this._names; this.mergeDefaultAndTheme(k, e); this._initData() }, mergeOption: function (e) { b4.superApply(this, "mergeOption", arguments); this._initData() }, setCurrentIndex: function (e) { if (e == null) { e = this.option.currentIndex } var i = this._data.count(); if (this.option.loop) { e = (e % i + i) % i } else { e >= i && (e = i - 1); e < 0 && (e = 0) } this.option.currentIndex = e }, getCurrentIndex: function () { return this.option.currentIndex }, isIndexMax: function () { return this.getCurrentIndex() >= this._data.count() - 1 }, setPlayState: function (e) { this.option.autoPlay = !!e }, getPlayState: function () { return !!this.option.autoPlay }, _initData: function () { var k = this.option; var m = k.data || []; var e = k.axisType; var Z = this._names = []; if (e === "category") { var i = []; o9(m, function (Ij, v2) { var Ik = xW(Ij); var v3; if (tJ(Ij)) { v3 = C5(Ij); v3.value = v2 } else { v3 = v2 } i.push(v3); if (!wb(Ik) && (Ik == null || isNaN(Ik))) { Ik = "" } Z.push(Ik + "") }); m = i } var v1 = ({ category: "ordinal", time: "time" })[e] || "number"; var v = this._data = new xt([{ name: "value", type: v1 }], this); v.initData(m, Z) }, getData: function () { return this._data }, getCategories: function () { if (this.get("axisType") === "category") { return this._names.slice() } } }); var P = b4.extend({ type: "timeline.slider", defaultOption: { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: false, tooltip: { trigger: "item" }, symbol: "emptyCircle", symbolSize: 10, lineStyle: { show: true, width: 2, color: "#304654" }, label: { position: "auto", show: true, interval: "auto", rotate: 0, color: "#304654" }, itemStyle: { color: "#304654", borderWidth: 1 }, checkpointStyle: { symbol: "circle", symbolSize: 13, color: "#c23531", borderWidth: 5, borderColor: "rgba(194,53,49, 0.5)", animation: true, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: true, showPlayBtn: true, showPrevBtn: true, showNextBtn: true, itemSize: 22, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z", prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z", color: "#304654", borderColor: "#304654", borderWidth: 1 }, emphasis: { label: { show: true, color: "#c23531" }, itemStyle: { color: "#c23531" }, controlStyle: { color: "#c23531", borderColor: "#c23531", borderWidth: 2 } }, data: [] } });
  Gq(P, u8); var sR = sT.extend({ type: "timeline" }); var sn = function (k, m, i, e) { BS.call(this, k, m, i); this.type = e || "value"; this.model = null }; sn.prototype = { constructor: sn, getLabelModel: function () { return this.model.getModel("label") }, isHorizontal: function () { return this.model.get("orient") === "horizontal" } }; mr(sn, BS); var ps = km; var to = o9; var yA = Math.PI; sR.extend({
    type: "timeline.slider", init: function (e, i) { this.api = i; this._axis; this._viewRect; this._timer; this._currentPointer; this._mainGroup; this._labelGroup }, render: function (Z, e, v, v2) { this.model = Z; this.api = v; this.ecModel = e; this.group.removeAll(); if (Z.get("show", true)) { var v1 = this._layout(Z, v); var k = this._createGroup("mainGroup"); var i = this._createGroup("labelGroup"); var m = this._axis = this._createAxis(v1, Z); Z.formatTooltip = function (v3) { return mv(m.scale.getLabel(v3)) }; to(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (v3) { this["_render" + v3](v1, k, m, Z) }, this); this._renderAxisLabel(v1, i, m, Z); this._position(v1, Z) } this._doPlayStop() }, remove: function () { this._clearTimer(); this.group.removeAll() }, dispose: function () { this._clearTimer() }, _layout: function (v2, Il) { var k = v2.get("label.position"); var v3 = v2.get("orient"); var Is = rO(v2, Il); if (k == null || k === "auto") { k = v3 === "horizontal" ? ((Is.y + Is.height / 2) < Il.getHeight() / 2 ? "-" : "+") : ((Is.x + Is.width / 2) < Il.getWidth() / 2 ? "+" : "-") } else { if (isNaN(k)) { k = ({ horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } })[v3][k] } } var Ip = { horizontal: "center", vertical: (k >= 0 || k === "+") ? "left" : "right" }; var v = { horizontal: (k >= 0 || k === "+") ? "top" : "bottom", vertical: "middle" }; var Iy = { horizontal: 0, vertical: yA / 2 }; var i = v3 === "vertical" ? Is.height : Is.width; var In = v2.getModel("controlStyle"); var v1 = In.get("show", true); var Im = v1 ? In.get("itemSize") : 0; var Iu = v1 ? In.get("itemGap") : 0; var Iw = Im + Iu; var It = v2.get("label.rotate") || 0; It = It * yA / 180; var Iv; var m; var Ir; var Z; var Io = In.get("position", true); var Ik = v1 && In.get("showPlayBtn", true); var Iq = v1 && In.get("showPrevBtn", true); var e = v1 && In.get("showNextBtn", true); var Ij = 0; var Ix = i; if (Io === "left" || Io === "bottom") { Ik && (Iv = [0, 0], Ij += Iw); Iq && (m = [Ij, 0], Ij += Iw); e && (Ir = [Ix - Im, 0], Ix -= Iw) } else { Ik && (Iv = [Ix - Im, 0], Ix -= Iw); Iq && (m = [0, 0], Ij += Iw); e && (Ir = [Ix - Im, 0], Ix -= Iw) } Z = [Ij, Ix]; if (v2.get("inverse")) { Z.reverse() } return { viewRect: Is, mainLength: i, orient: v3, rotation: Iy[v3], labelRotation: It, labelPosOpt: k, labelAlign: v2.get("label.align") || Ip[v3], labelBaseline: v2.get("label.verticalAlign") || v2.get("label.baseline") || v[v3], playPosition: Iv, prevBtnPosition: m, nextBtnPosition: Ir, axisExtent: Z, controlSize: Im, controlGap: Iu } }, _position: function (Im, v3) { var Z = this._mainGroup; var Il = this._labelGroup; var Ip = Im.viewRect; if (Im.orient === "vertical") { var Io = CB(); var i = Ip.x; var e = Ip.y + Ip.height; vm(Io, Io, [-i, -e]); ki(Io, Io, -yA / 2); vm(Io, Io, [i, e]); Ip = Ip.clone(); Ip.applyTransform(Io) } var k = Ij(Ip); var Is = Ij(Z.getBoundingRect()); var v1 = Ij(Il.getBoundingRect()); var Ir = Z.position; var Iq = Il.position; Iq[0] = Ir[0] = k[0][0]; var v = Im.labelPosOpt; if (isNaN(v)) { var Ik = v === "+" ? 0 : 1; v2(Ir, Is, k, 1, Ik); v2(Iq, v1, k, 1, 1 - Ik) } else { var Ik = v >= 0 ? 0 : 1; v2(Ir, Is, k, 1, Ik); Iq[1] = Ir[1] + v } Z.attr("position", Ir); Il.attr("position", Iq); Z.rotation = Il.rotation = Im.rotation; In(Z); In(Il); function In(m) { var It = m.position; m.origin = [k[0][0] - It[0], k[1][0] - It[1]] } function Ij(m) { return [[m.x, m.x + m.width], [m.y, m.y + m.height]] } function v2(Iu, Iw, Iv, It, m) { Iu[It] += Iv[It][m] - Iw[It][m] } }, _createAxis: function (Z, k) { var v = k.getData(); var e = k.get("axisType"); var v1 = nq(k, e); v1.getTicks = function () { return v.mapArray(["value"], function (v2) { return v2 }) }; var m = v.getDataExtent("value"); v1.setExtent(m[0], m[1]); v1.niceTicks(); var i = new sn("value", v1, Z.axisExtent, e); i.model = k; return i }, _createGroup: function (e) { var i = this["_" + e] = new B8(); this.group.add(i); return i }, _renderAxisLine: function (m, k, e, i) { var v = e.getExtent(); if (!i.get("lineStyle.show")) { return } k.add(new zB({ shape: { x1: v[0], y1: 0, x2: v[1], y2: 0 }, style: b0({ lineCap: "round" }, i.getModel("lineStyle").getLineStyle()), silent: true, z2: 1 })) }, _renderAxisTick: function (Z, v, e, k) { var m = k.getData(); var i = e.scale.getTicks(); to(i, function (Im) { var Ik = e.dataToCoord(Im); var Ij = m.getItemModel(Im); var Il = Ij.getModel("itemStyle"); var v2 = Ij.getModel("emphasis.itemStyle"); var v1 = { position: [Ik, 0], onclick: ps(this._changeTimeline, this, Im) }; var v3 = na(Ij, Il, v, v1); yn(v3, v2.getItemStyle()); if (Ij.get("tooltip")) { v3.dataIndex = Im; v3.dataModel = k } else { v3.dataIndex = v3.dataModel = null } }, this) }, _renderAxisLabel: function (v, m, e, i) { var Z = e.getLabelModel(); if (!Z.get("show")) { return } var k = i.getData(); var v1 = e.getViewLabels(); to(v1, function (Ij) { var Ik = Ij.tickValue; var In = k.getItemModel(Ik); var v3 = In.getModel("label"); var v2 = In.getModel("emphasis.label"); var Im = e.dataToCoord(Ij.tickValue); var Il = new iR({ position: [Im, 0], rotation: v.labelRotation - v.rotation, onclick: ps(this._changeTimeline, this, Ik), silent: false }); pe(Il.style, v3, { text: Ij.formattedLabel, textAlign: v.labelAlign, textVerticalAlign: v.labelBaseline }); m.add(Il); yn(Il, pe({}, v2)) }, this) }, _renderControl: function (k, Ik, i, e) {
      var Z = k.controlSize; var Il = k.rotation; var v2 = e.getModel("controlStyle").getItemStyle();
      var m = e.getModel("emphasis.controlStyle").getItemStyle(); var v3 = [0, -Z / 2, Z, Z]; var Ij = e.getPlayState(); var v = e.get("inverse", true); v1(k.nextBtnPosition, "controlStyle.nextIcon", ps(this._changeTimeline, this, v ? "-" : "+")); v1(k.prevBtnPosition, "controlStyle.prevIcon", ps(this._changeTimeline, this, v ? "+" : "-")); v1(k.playPosition, "controlStyle." + (Ij ? "stopIcon" : "playIcon"), ps(this._handlePlayClick, this, !Ij), true); function v1(Im, Iq, In, Ir) { if (!Im) { return } var Ip = { position: Im, origin: [Z / 2, 0], rotation: Ir ? -Il : 0, rectHover: true, style: v2, onclick: In }; var Io = dd(e, Iq, v3, Ip); Ik.add(Io); yn(Io, m) }
    }, _renderCurrentPointer: function (m, v2, k, e) { var v = e.getData(); var Z = e.getCurrentIndex(); var i = v.getItemModel(Z).getModel("checkpointStyle"); var v1 = this; var v3 = { onCreate: function (Ij) { Ij.draggable = true; Ij.drift = ps(v1._handlePointerDrag, v1); Ij.ondragend = ps(v1._handlePointerDragend, v1); uu(Ij, Z, k, e, true) }, onUpdate: function (Ij) { uu(Ij, Z, k, e) } }; this._currentPointer = na(i, i, this._mainGroup, {}, this._currentPointer, v3) }, _handlePlayClick: function (e) { this._clearTimer(); this.api.dispatchAction({ type: "timelinePlayChange", playState: e, from: this.uid }) }, _handlePointerDrag: function (k, i, m) { this._clearTimer(); this._pointerChangeTimeline([m.offsetX, m.offsetY]) }, _handlePointerDragend: function (i) { this._pointerChangeTimeline([i.offsetX, i.offsetY], true) }, _pointerChangeTimeline: function (e, i) { var k = this._toAxisCoord(e)[0]; var m = this._axis; var v1 = o7(m.getExtent().slice()); k > v1[1] && (k = v1[1]); k < v1[0] && (k = v1[0]); this._currentPointer.position[0] = k; this._currentPointer.dirty(); var Z = this._findNearestTick(k); var v = this.model; if (i || (Z !== v.getCurrentIndex() && v.get("realtime"))) { this._changeTimeline(Z) } }, _doPlayStop: function () { this._clearTimer(); if (this.model.getPlayState()) { this._timer = setTimeout(ps(e, this), this.model.get("playInterval")) } function e() { var i = this.model; this._changeTimeline(i.getCurrentIndex() + (i.get("rewind", true) ? -1 : 1)) } }, _toAxisCoord: function (i) { var e = this._mainGroup.getLocalTransform(); return v7(i, e, true) }, _findNearestTick: function (e) { var k = this.model.getData(); var v = Infinity; var m; var i = this._axis; k.each(["value"], function (v1, Z) { var v3 = i.dataToCoord(v1); var v2 = Math.abs(v3 - e); if (v2 < v) { v = v2; m = Z } }); return m }, _clearTimer: function () { if (this._timer) { clearTimeout(this._timer); this._timer = null } }, _changeTimeline: function (e) { var i = this.model.getCurrentIndex(); if (e === "+") { e = i + 1 } else { if (e === "-") { e = i - 1 } } this.api.dispatchAction({ type: "timelineChange", currentIndex: e, from: this.uid }) }
  }); function rO(e, i) { return kV(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }, e.get("padding")) } function dd(v, e, m, k) { var i = Bd(v.get(e).replace(/^path:\/\//, ""), C5(k || {}), new CH(m[0], m[1], m[2], m[3]), "center"); return i } function na(i, Z, Ik, e, m, Il) { var v = Z.get("color"); if (!m) { var Im = i.get("symbol"); m = t9(Im, -1, -1, 2, 2, v); m.setStyle("strokeNoScale", true); Ik.add(m); Il && Il.onCreate(m) } else { m.setColor(v); Ik.add(m); Il && Il.onUpdate(m) } var v1 = Z.getItemStyle(["color", "symbol", "symbolSize"]); m.setStyle(v1); e = v4({ rectHover: true, z2: 100 }, e, true); var k = i.get("symbolSize"); k = k instanceof Array ? k.slice() : [+k, +k]; k[0] /= 2; k[1] /= 2; e.scale = k; var v3 = i.get("symbolOffset"); if (v3) { var Ij = e.position = e.position || [0, 0]; Ij[0] += zN(v3[0], k[0]); Ij[1] += zN(v3[1], k[1]) } var v2 = i.get("symbolRotate"); e.rotation = (v2 || 0) * Math.PI / 180 || 0; m.attr(e); m.updateTransform(); return m } function uu(v1, m, v, Z, i) { if (v1.dragging) { return } var e = Z.getModel("checkpointStyle"); var k = v.dataToCoord(Z.getData().get(["value"], m)); if (i || !e.get("animation", true)) { v1.attr({ position: [k, 0] }) } else { v1.stopAnimation(true); v1.animateTo({ position: [k, 0] }, e.get("animationDuration", true), e.get("animationEasing", true)) } } y2(HW); var kH = p2({ type: "toolbox", layoutMode: { type: "box", ignoreSize: true }, optionUpdated: function () { kH.superApply(this, "optionUpdated", arguments); o9(this.option.feature, function (k, i) { var e = a1(i); e && v4(k, e.defaultOption) }) }, defaultOption: { show: true, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: true, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } } } }); qy({
    type: "toolbox", render: function (Z, k, m, v2) {
      var v3 = this.group; v3.removeAll(); if (!Z.get("show")) { return } var Ij = +Z.get("itemSize"); var Ik = Z.get("feature") || {}; var i = this._features || (this._features = {}); var e = []; o9(Ik, function (Im, Il) { e.push(Il) }); (new Gx(this._featureNames || [], e)).add(v1).update(v1).remove(sv(v1, null)).execute(); this._featureNames = e; function v1(Io, Is) {
        var Im = e[Io]; var Ip = e[Is]; var Ir = Ik[Im]; var Iq = new fv(Ir, Z, Z.ecModel); var In; if (Im && !Ip) { if (rZ(Im)) { In = { model: Iq, onclick: Iq.option.onclick, featureName: Im } } else { var Il = a1(Im); if (!Il) { return } In = new Il(Iq, k, m) } i[Im] = In } else { In = i[Ip]; if (!In) { return } In.model = Iq; In.ecModel = k; In.api = m } if (!Im && Ip) { In.dispose && In.dispose(k, m); return } if (!Iq.get("show") || In.unusable) { In.remove && In.remove(k, m); return } v(Iq, In, Im); Iq.setIconStatus = function (Iw, It) {
          var Iv = this.option; var Iu = this.iconPaths; Iv.iconStatus = Iv.iconStatus || {};
          Iv.iconStatus[Iw] = It; Iu[Iw] && Iu[Iw].trigger(It)
        }; if (In.render) { In.render(Iq, k, m, v2) }
      } function v(Is, Iu, It) { var In = Is.getModel("iconStyle"); var Il = Is.getModel("emphasis.iconStyle"); var Ir = Iu.getIcons ? Iu.getIcons() : Is.get("icon"); var Io = Is.get("title") || {}; if (typeof Ir === "string") { var Ip = Ir; var Iq = Io; Ir = {}; Io = {}; Ir[It] = Ip; Io[It] = Iq } var Im = Is.iconPaths = {}; o9(Ir, function (Iv, Ix) { var Iw = Gb(Iv, {}, { x: -Ij / 2, y: -Ij / 2, width: Ij, height: Ij }); Iw.setStyle(In.getItemStyle()); Iw.hoverStyle = Il.getItemStyle(); yn(Iw); if (Z.get("showTitle")) { Iw.__title = Io[Ix]; Iw.on("mouseover", function () { var Iy = Il.getItemStyle(); Iw.setStyle({ text: Io[Ix], textPosition: Iy.textPosition || "bottom", textFill: Iy.fill || Iy.stroke || "#000", textAlign: Iy.textAlign || "center" }) }).on("mouseout", function () { Iw.setStyle({ textFill: null }) }) } Iw.trigger(Is.get("iconStatus." + Ix) || "normal"); v3.add(Iw); Iw.on("click", km(Iu.onclick, Iu, k, m, Ix)); Im[Ix] = Iw }) } ee(v3, Z, m); v3.add(An(v3.getBoundingRect(), Z)); v3.eachChild(function (Ip) { var Im = Ip.__title; var Ir = Ip.hoverStyle; if (Ir && Im) { var Iq = Gr(Im, py(Ir)); var Il = Ip.position[0] + v3.position[0]; var Is = Ip.position[1] + v3.position[1] + Ij; var Io = false; if (Is + Iq.height > m.getHeight()) { Ir.textPosition = "top"; Io = true } var In = Io ? (-5 - Iq.height) : (Ij + 8); if (Il + Iq.width / 2 > m.getWidth()) { Ir.textPosition = ["100%", In]; Ir.textAlign = "right" } else { if (Il - Iq.width / 2 < 0) { Ir.textPosition = [0, In]; Ir.textAlign = "left" } } } })
    }, updateView: function (m, e, i, k) { o9(this._features, function (v) { v.updateView && v.updateView(v.model, e, i, k) }) }, remove: function (e, i) { o9(this._features, function (k) { k.remove && k.remove(e, i) }); this.group.removeAll() }, dispose: function (e, i) { o9(this._features, function (k) { k.dispose && k.dispose(e, i) }) }
  }); function rZ(e) { return e.indexOf("my") === 0 } var or = Cn.toolbox.saveAsImage; function po(e) { this.model = e } po.defaultOption = { show: true, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: or.title, type: "png", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: or.lang.slice() }; po.prototype.unusable = !sW.canvasSupported; var cb = po.prototype; cb.onclick = function (v3, Ij) { var v2 = this.model; var Im = v2.get("name") || v3.get("title.0.text") || "echarts"; var Z = document.createElement("a"); var Il = v2.get("type", true) || "png"; Z.download = Im + "." + Il; Z.target = "_blank"; var i = Ij.getConnectedDataURL({ type: Il, backgroundColor: v2.get("backgroundColor", true) || v3.get("backgroundColor") || "#fff", excludeComponents: v2.get("excludeComponents"), pixelRatio: v2.get("pixelRatio") }); Z.href = i; if (typeof MouseEvent === "function" && !sW.browser.ie && !sW.browser.edge) { var In = new MouseEvent("click", { view: window, bubbles: true, cancelable: false }); Z.dispatchEvent(In) } else { if (window.navigator.msSaveOrOpenBlob) { var k = atob(i.split(",")[1]); var v = k.length; var Ik = new Uint8Array(v); while (v--) { Ik[v] = k.charCodeAt(v) } var e = new Blob([Ik]); window.navigator.msSaveOrOpenBlob(e, Im + "." + Il) } else { var Io = v2.get("lang"); var v1 = "" + '<body style="margin:0;">' + '<img src="' + i + '" style="max-width:100%;" title="' + ((Io && Io[0]) || "") + '" />' + "</body>"; var m = window.open(); m.document.write(v1) } } }; aF("saveAsImage", po); var tc = Cn.toolbox.magicType; function mG(e) { this.model = e } mG.defaultOption = { show: true, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z", tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z" }, title: C5(tc.title), option: {}, seriesIndex: {} }; var ca = mG.prototype; ca.getIcons = function () { var e = this.model; var k = e.get("icon"); var i = {}; o9(e.get("type"), function (m) { if (k[m]) { i[m] = k[m] } }); return i }; var ut = { "line": function (i, m, e, k) { if (i === "bar") { return v4({ id: m, type: "line", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, k.get("option.line") || {}, true) } }, "bar": function (i, m, e, k) { if (i === "line") { return v4({ id: m, type: "bar", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, k.get("option.bar") || {}, true) } }, "stack": function (i, m, e, k) { if (i === "line" || i === "bar") { return v4({ id: m, stack: "__ec_magicType_stack__" }, k.get("option.stack") || {}, true) } }, "tiled": function (i, m, e, k) { if (i === "line" || i === "bar") { return v4({ id: m, stack: "" }, k.get("option.tiled") || {}, true) } } }; var r8 = [["line", "bar"], ["stack", "tiled"]]; ca.onclick = function (e, v, m) {
    var k = this.model; var i = k.get("seriesIndex." + m); if (!ut[m]) { return } var Z = { series: [] }; var v1 = function (v2) {
      var Ij = v2.subType; var Io = v2.id; var Ir = ut[m](Ij, Io, v2, k); if (Ir) { De(Ir, v2.option); Z.series.push(Ir) } var v3 = v2.coordinateSystem; if (v3 && v3.type === "cartesian2d" && (m === "line" || m === "bar")) {
        var Il = v3.getAxesByScale("ordinal")[0];
        if (Il) { var Im = Il.dim; var Ip = Im + "Axis"; var In = e.queryComponents({ mainType: Ip, index: v2.get(name + "Index"), id: v2.get(name + "Id") })[0]; var Iq = In.componentIndex; Z[Ip] = Z[Ip] || []; for (var Ik = 0; Ik <= Iq; Ik++) { Z[Ip][Iq] = Z[Ip][Iq] || {} } Z[Ip][Iq].boundaryGap = m === "bar" ? true : false }
      }
    }; o9(r8, function (v2) { if (eP(v2, m) >= 0) { o9(v2, function (v3) { k.setIconStatus(v3, "normal") }) } }); k.setIconStatus(m, "emphasis"); e.eachComponent({ mainType: "series", query: i == null ? null : { seriesIndex: i } }, v1); v.dispatchAction({ type: "changeMagicType", currentType: m, newOption: Z })
  }; b1({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function (i, e) { e.mergeOption(i.newOption) }); aF("magicType", mG); var En = Cn.toolbox.dataView; var fp = new Array(60).join("-"); var HL = "\t"; function e3(e) { var i = {}; var m = []; var k = []; e.eachRawSeries(function (v) { var v1 = v.coordinateSystem; if (v1 && (v1.type === "cartesian2d" || v1.type === "polar")) { var v2 = v1.getBaseAxis(); if (v2.type === "category") { var Z = v2.dim + "_" + v2.index; if (!i[Z]) { i[Z] = { categoryAxis: v2, valueAxis: v1.getOtherAxis(v2), series: [] }; k.push({ axisDim: v2.dim, axisIndex: v2.index }) } i[Z].series.push(v) } else { m.push(v) } } else { m.push(v) } }); return { seriesGroupByCategoryAxis: i, other: m, meta: k } } function jA(i) { var e = []; o9(i, function (Ij, Ik) { var v1 = Ij.categoryAxis; var Il = Ij.valueAxis; var v2 = Il.dim; var k = [" "].concat(Ef(Ij.series, function (In) { return In.name })); var m = [v1.model.getCategories()]; o9(Ij.series, function (In) { m.push(In.getRawData().mapArray(v2, function (Io) { return Io })) }); var Im = [k.join(HL)]; for (var Z = 0; Z < m[0].length; Z++) { var v3 = []; for (var v = 0; v < m.length; v++) { v3.push(m[v][Z]) } Im.push(v3.join(HL)) } e.push(Im.join("\n")) }); return e.join("\n\n" + fp + "\n\n") } function lM(e) { return Ef(e, function (k) { var v = k.getRawData(); var i = [k.name]; var m = []; v.each(v.dimensions, function () { var Z = arguments.length; var v3 = arguments[Z - 1]; var v1 = v.getName(v3); for (var v2 = 0; v2 < Z - 1; v2++) { m[v2] = arguments[v2] } i.push((v1 ? (v1 + HL) : "") + m.join(HL)) }); return i.join("\n") }).join("\n\n" + fp + "\n\n") } function w7(i) { var e = e3(i); return { value: q4([jA(e.seriesGroupByCategoryAxis), lM(e.other)], function (k) { return k.replace(/[\n\t\s]/g, "") }).join("\n\n" + fp + "\n\n"), meta: e.meta } } function cx(e) { return e.replace(/^\s\s*/, "").replace(/\s\s*$/, "") } function zk(i) { var e = i.slice(0, i.indexOf("\n")); if (e.indexOf(HL) >= 0) { return true } } var yr = new RegExp("[" + HL + "]+", "g"); function H1(v3) { var v1 = v3.split(/\n+/g); var v2 = cx(v1.shift()).split(yr); var k = []; var Z = Ef(v2, function (i) { return { name: i, data: [] } }); for (var v = 0; v < v1.length; v++) { var e = cx(v1[v]).split(yr); k.push(e.shift()); for (var m = 0; m < e.length; m++) { Z[m] && (Z[m].data[v] = e[m]) } } return { series: Z, categories: k } } function dh(v2) { var Ik = v2.split(/\n+/g); var v3 = cx(Ik.shift()); var m = []; for (var v = 0; v < Ik.length; v++) { var v1 = cx(Ik[v]).split(yr); var e = ""; var Ij; var Z = false; if (isNaN(v1[0])) { Z = true; e = v1[0]; v1 = v1.slice(1); m[v] = { name: e, value: [] }; Ij = m[v].value } else { Ij = m[v] = [] } for (var k = 0; k < v1.length; k++) { Ij.push(+v1[k]) } if (Ij.length === 1) { Z ? (m[v].value = Ij[0]) : (m[v] = Ij[0]) } } return { name: v3, data: m } } function Gk(m, k) { var i = m.split(new RegExp("\n*" + fp + "\n*", "g")); var e = { series: [] }; o9(i, function (v3, Z) { if (zk(v3)) { var v = H1(v3); var v2 = k[Z]; var v1 = v2.axisDim + "Axis"; if (v2) { e[v1] = e[v1] || []; e[v1][v2.axisIndex] = { data: v.categories }; e.series = e.series.concat(v.series) } } else { var v = dh(v3); e.series.push(v) } }); return e } function mb(e) { this._dom = null; this.model = e } mb.defaultOption = { show: true, readOnly: false, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: C5(En.title), lang: C5(En.lang), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }; mb.prototype.onclick = function (It, v2) {
    var v1 = v2.getDom(); var k = this.model; if (this._dom) { v1.removeChild(this._dom) } var Il = document.createElement("div"); Il.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;"; Il.style.backgroundColor = k.get("backgroundColor") || "#fff"; var In = document.createElement("h4"); var m = k.get("lang") || []; In.innerHTML = m[0] || k.get("title"); In.style.cssText = "margin: 10px 20px;"; In.style.color = k.get("textColor"); var Is = document.createElement("div"); var Ij = document.createElement("textarea"); Is.style.cssText = "display:block;width:100%;overflow:auto;"; var Im = k.get("optionToContent"); var v = k.get("contentToOption"); var Z = w7(It); if (typeof Im === "function") { var Ir = Im(v2.getOption()); if (typeof Ir === "string") { Is.innerHTML = Ir } else { if (ay(Ir)) { Is.appendChild(Ir) } } } else { Is.appendChild(Ij); Ij.readOnly = k.get("readOnly"); Ij.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;"; Ij.style.color = k.get("textColor"); Ij.style.borderColor = k.get("textareaBorderColor"); Ij.style.backgroundColor = k.get("textareaColor"); Ij.value = Z.value } var Ip = Z.meta; var Io = document.createElement("div"); Io.style.cssText = "position:absolute;bottom:0;left:0;right:0;"; var Iq = "float:right;margin-right:20px;border:none;" + "cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    var e = document.createElement("div"); var i = document.createElement("div"); Iq += ";background-color:" + k.get("buttonColor"); Iq += ";color:" + k.get("buttonTextColor"); var Ik = this; function v3() { v1.removeChild(Il); Ik._dom = null } fr(e, "click", v3); fr(i, "click", function () { var Iu; try { if (typeof v === "function") { Iu = v(Is, v2.getOption()) } else { Iu = Gk(Ij.value, Ip) } } catch (Iv) { v3(); throw new Error("Data view format error " + Iv) } if (Iu) { v2.dispatchAction({ type: "changeDataView", newOption: Iu }) } v3() }); e.innerHTML = m[1]; i.innerHTML = m[2]; i.style.cssText = Iq; e.style.cssText = Iq; !k.get("readOnly") && Io.appendChild(i); Io.appendChild(e); fr(Ij, "keydown", function (Iv) { if ((Iv.keyCode || Iv.which) === 9) { var Iw = this.value; var Ix = this.selectionStart; var Iu = this.selectionEnd; this.value = Iw.substring(0, Ix) + HL + Iw.substring(Iu); this.selectionStart = this.selectionEnd = Ix + 1; GP(Iv) } }); Il.appendChild(In); Il.appendChild(Is); Il.appendChild(Io); Is.style.height = (v1.clientHeight - 80) + "px"; v1.appendChild(Il); this._dom = Il
  }; mb.prototype.remove = function (e, i) { this._dom && i.getDom().removeChild(this._dom) }; mb.prototype.dispose = function (e, i) { this.remove(e, i) }; function so(e, i) { return Ef(e, function (m, k) { var v = i && i[k]; if (tJ(v) && !GG(v)) { if (tJ(m) && !GG(m)) { m = m.value } return De({ value: m }, v) } else { return m } }) } aF("dataView", mb); b1({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function (k, e) { var i = []; o9(k.newOption.series, function (m) { var v = e.getSeriesByName(m.name)[0]; if (!v) { i.push(b0({ type: "scatter" }, m)) } else { var Z = v.get("data"); i.push({ name: m.name, data: so(m.data, Z) }) } }); e.mergeOption(De({ series: i }, k.newOption)) }); var ti = o9; var bo = "\0_ec_hist_store"; function yg(e, k) { var i = oC(e); ti(k, function (v2, v) { var v1 = i.length - 1; for (; v1 >= 0; v1--) { var Z = i[v1]; if (Z[v]) { break } } if (v1 < 0) { var v3 = e.queryComponents({ mainType: "dataZoom", subType: "select", id: v })[0]; if (v3) { var m = v3.getPercentRange(); i[0][v] = { dataZoomId: v, start: m[0], end: m[1] } } } }); i.push(k) } function Bt(e) { var k = oC(e); var m = k[k.length - 1]; k.length > 1 && k.pop(); var i = {}; ti(m, function (v1, v) { for (var Z = k.length - 1; Z >= 0; Z--) { var v1 = k[Z][v]; if (v1) { i[v] = v1; break } } }); return i } function Ep(e) { e[bo] = null } function Dx(e) { return oC(e).length } function oC(e) { var i = e[bo]; if (!i) { i = e[bo] = [{}] } return i } yB.extend({ type: "dataZoom.select" }); D6.extend({ type: "dataZoom.select" }); var mS = Cn.toolbox.dataZoom; var tl = o9; var dm = "\0_ec_\0toolbox-dataZoom_"; function ub(i, e, k) { (this._brushController = new kx(k.getZr())).on("brush", km(this._onBrush, this)).mount(); this._isZoomActive } ub.defaultOption = { show: true, icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: C5(mS.title) }; var b9 = ub.prototype; b9.render = function (m, e, i, k) { this.model = m; this.ecModel = e; this.api = i; hW(m, e, this, k, i); qF(m, e) }; b9.onclick = function (e, k, i) { q2[i].call(this) }; b9.remove = function (e, i) { this._brushController.unmount() }; b9.dispose = function (e, i) { this._brushController.dispose() }; var q2 = { zoom: function () { var e = !this._isZoomActive; this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: e }) }, back: function () { this._dispatchZoomAction(Bt(this.ecModel)) } }; b9._onBrush = function (k, v) { if (!v.isEnd || !k.length) { return } var i = {}; var e = this.ecModel; this._brushController.updateCovers([]); var v1 = new Dm(pI(this.model.option), e, { include: ["grid"] }); v1.matchOutputRanges(k, e, function (v3, Ik, v2) { if (v2.type !== "cartesian2d") { return } var Ij = v3.brushType; if (Ij === "rect") { Z("x", v2, Ik[0]); Z("y", v2, Ik[1]) } else { Z(({ lineX: "x", lineY: "y" })[Ij], v2, Ik) } }); yg(e, i); this._dispatchZoomAction(i); function Z(Im, Ij, v2) { var Ik = Ij.getAxis(Im); var v3 = Ik.model; var In = m(Im, v3, e); var Il = In.findRepresentativeAxisProxy(v3).getMinMaxSpan(); if (Il.minValueSpan != null || Il.maxValueSpan != null) { v2 = nv(0, v2.slice(), Ik.scale.getExtent(), 0, Il.minValueSpan, Il.maxValueSpan) } In && (i[In.id] = { dataZoomId: In.id, startValue: v2[0], endValue: v2[1] }) } function m(Ik, v3, v2) { var Ij; v2.eachComponent({ mainType: "dataZoom", subType: "select" }, function (Im) { var Il = Im.getAxisModel(Ik, v3.componentIndex); Il && (Ij = Im) }); return Ij } }; b9._dispatchZoomAction = function (e) { var i = []; tl(e, function (m, k) { i.push(C5(m)) }); i.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: i }) }; function pI(i) { var e = {}; o9(["xAxisIndex", "yAxisIndex"], function (k) { e[k] = i[k]; e[k] == null && (e[k] = "all"); (e[k] === false || e[k] === "none") && (e[k] = []) }); return e } function qF(i, e) { i.setIconStatus("back", Dx(e) > 1 ? "emphasis" : "normal") } function hW(Z, e, i, v, m) { var v1 = i._isZoomActive; if (v && v.type === "takeGlobalCursor") { v1 = v.key === "dataZoomSelect" ? v.dataZoomSelectActive : false } i._isZoomActive = v1; Z.setIconStatus("zoom", v1 ? "emphasis" : "normal"); var k = new Dm(pI(Z.option), e, { include: ["grid"] }); i._brushController.setPanels(k.makePanelOpts(m, function (v2) { return (v2.xAxisDeclared && !v2.yAxisDeclared) ? "lineX" : (!v2.xAxisDeclared && v2.yAxisDeclared) ? "lineY" : "rect" })).enableBrush(v1 ? { brushType: "auto", brushStyle: { lineWidth: 0, fill: "rgba(0,0,0,0.2)" } } : false) } aF("dataZoom", ub); y2(function (k) {
    if (!k) { return } var v = k.dataZoom || (k.dataZoom = []); if (!GG(v)) {
      k.dataZoom = v = [v]
    } var Z = k.toolbox; if (Z) { if (GG(Z)) { Z = Z[0] } if (Z && Z.feature) { var i = Z.feature.dataZoom; e("xAxis", i); e("yAxis", i) } } function e(Ij, v2) { if (!v2) { return } var v1 = Ij + "Index"; var v3 = v2[v1]; if (v3 != null && v3 != "all" && !GG(v3)) { v3 = (v3 === false || v3 === "none") ? [] : [v3] } m(Ij, function (Ik, Il) { if (v3 != null && v3 != "all" && eP(v3, Il) === -1) { return } var Im = { type: "select", $fromToolbox: true, id: dm + Ij + Il }; Im[v1] = Il; v.push(Im) }) } function m(v3, v1) { var v2 = k[v3]; if (!GG(v2)) { v2 = v2 ? [v2] : [] } tl(v2, v1) }
  }); var tD = Cn.toolbox.restore; function vQ(e) { this.model = e } vQ.defaultOption = { show: true, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: tD.title }; var b8 = vQ.prototype; b8.onclick = function (e, k, i) { Ep(e); k.dispatchAction({ type: "restore", from: this.uid }) }; aF("restore", vQ); b1({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function (i, e) { e.resetOption("recreate") }); var f0 = "urn:schemas-microsoft-com:vml"; var wI = typeof window === "undefined" ? null : window; var zr = false; var sB = wI && wI.document; function Bk(e) { return cH(e) } var cH; if (sB && !sW.canvasSupported) { try { !sB.namespaces.zrvml && sB.namespaces.add("zrvml", f0); cH = function (e) { return sB.createElement("<zrvml:" + e + ' class="zrvml">') } } catch (Hi) { cH = function (e) { return sB.createElement("<" + e + ' xmlns="' + f0 + '" class="zrvml">') } } } function xO() { if (zr || !sB) { return } zr = true; var e = sB.styleSheets; if (e.length < 31) { sB.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") } else { e[0].addRule(".zrvml", "behavior:url(#default#VML)") } } var FP = j5.CMD; var FI = Math.round; var DG = Math.sqrt; var B1 = Math.abs; var DB = Math.cos; var Fu = Math.sin; var AD = Math.max; if (!sW.canvasSupported) {
    var mi = ","; var bT = "progid:DXImageTransform.Microsoft"; var Hp = 21600; var bQ = Hp / 2; var cg = 100000; var Da = 1000; var ta = function (e) { e.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;"; e.coordsize = Hp + "," + Hp; e.coordorigin = "0,0" }; var B0 = function (e) { return String(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;") }; var sE = function (k, i, e) { return "rgb(" + [k, i, e].join(",") + ")" }; var lc = function (e, i) { if (i && e && i.parentNode !== e) { e.appendChild(i) } }; var be = function (e, i) { if (i && e && i.parentNode === e) { e.removeChild(i) } }; var d0 = function (e, k, i) { return (parseFloat(e) || 0) * cg + (parseFloat(k) || 0) * Da + i }; var zH = function (e, i) { if (typeof e === "string") { if (e.lastIndexOf("%") >= 0) { return parseFloat(e) / 100 * i } return parseFloat(e) } return e }; var lb = function (k, e, i) { var m = eW(e); i = +i; if (isNaN(i)) { i = 1 } if (m) { k.color = sE(m[0], m[1], m[2]); k.opacity = i * m[3] } }; var ex = function (e) { var i = eW(e); return [sE(i[0], i[1], i[2]), i[3]] }; var gQ = function (v, IC, Il) { var Iz = IC.fill; if (Iz != null) { if (Iz instanceof lV) { var v3; var IF = 0; var It = [0, 0]; var IB = 0; var Iu = 1; var m = Il.getBoundingRect(); var e = m.width; var Iy = m.height; if (Iz.type === "linear") { v3 = "gradient"; var Io = Il.transform; var Z = [Iz.x * e, Iz.y * Iy]; var k = [Iz.x2 * e, Iz.y2 * Iy]; if (Io) { aY(Z, Z, Io); aY(k, k, Io) } var In = k[0] - Z[0]; var Im = k[1] - Z[1]; IF = Math.atan2(In, Im) * 180 / Math.PI; if (IF < 0) { IF += 360 } if (IF < 0.000001) { IF = 0 } } else { v3 = "gradientradial"; var Z = [Iz.x * e, Iz.y * Iy]; var Io = Il.transform; var v2 = Il.scale; var Iv = e; var Is = Iy; It = [(Z[0] - m.x) / Iv, (Z[1] - m.y) / Is]; if (Io) { aY(Z, Z, Io) } Iv /= v2[0] * Hp; Is /= v2[1] * Hp; var IG = AD(Iv, Is); IB = 2 * 0 / IG; Iu = 2 * Iz.r / IG - IB } var Ij = Iz.colorStops.slice(); Ij.sort(function (IH, i) { return IH.offset - i.offset }); var Ir = Ij.length; var Ix = []; var Ik = []; for (var IA = 0; IA < Ir; IA++) { var Iw = Ij[IA]; var v1 = ex(Iw.color); Ik.push(Iw.offset * Iu + IB + " " + v1[0]); if (IA === 0 || IA === Ir - 1) { Ix.push(v1) } } if (Ir >= 2) { var IE = Ix[0][0]; var ID = Ix[1][0]; var Iq = Ix[0][1] * IC.opacity; var Ip = Ix[1][1] * IC.opacity; v.type = v3; v.method = "none"; v.focus = "100%"; v.angle = IF; v.color = IE; v.color2 = ID; v.colors = Ik.join(","); v.opacity = Ip; v.opacity2 = Iq } if (v3 === "radial") { v.focusposition = It.join(",") } } else { lb(v, Iz, IC.opacity) } } }; var p5 = function (i, e) { if (e.lineDash != null) { i.dashstyle = e.lineDash.join(" ") } if (e.stroke != null && !(e.stroke instanceof lV)) { lb(i, e.stroke, e.opacity) } }; var sM = function (e, m, k, Z) { var v = m == "fill"; var i = e.getElementsByTagName(m)[0]; if (k[m] != null && k[m] !== "none" && (v || (!v && k.lineWidth))) { e[v ? "filled" : "stroked"] = "true"; if (k[m] instanceof lV) { be(e, i) } if (!i) { i = Bk(m) } v ? gQ(i, k, Z) : p5(i, k); lc(e, i) } else { e[v ? "filled" : "stroked"] = "false"; be(e, i) } }; var DI = [[], [], []]; var oB = function (ID, IG) {
      var v2 = FP.M; var Im = FP.C; var Ij = FP.L; var Ip = FP.A; var v = FP.Q; var Iy = []; var Z; var Iz; var IJ; var II; var IB; var It; var IN = ID.data; var Il = ID.len(); for (II = 0; II < Il;) {
        IJ = IN[II++]; Iz = ""; Z = 0; switch (IJ) {
          case v2: Iz = " m "; Z = 1; IB = IN[II++]; It = IN[II++]; DI[0][0] = IB; DI[0][1] = It; break; case Ij: Iz = " l "; Z = 1; IB = IN[II++]; It = IN[II++]; DI[0][0] = IB; DI[0][1] = It; break; case v: case Im: Iz = " c "; Z = 3; var Iq = IN[II++]; var IR = IN[II++]; var Io = IN[II++]; var IP = IN[II++]; var In; var IO; if (IJ === v) { In = Io; IO = IP; Io = (Io + 2 * Iq) / 3; IP = (IP + 2 * IR) / 3; Iq = (IB + 2 * Iq) / 3; IR = (It + 2 * IR) / 3 } else { In = IN[II++]; IO = IN[II++] } DI[0][0] = Iq; DI[0][1] = IR; DI[1][0] = Io; DI[1][1] = IP; DI[2][0] = In; DI[2][1] = IO; IB = In; It = IO; break; case Ip: var IC = 0; var IA = 0; var Ik = 1; var v3 = 1; var Is = 0; if (IG) {
            IC = IG[4]; IA = IG[5]; Ik = DG(IG[0] * IG[0] + IG[1] * IG[1]);
            v3 = DG(IG[2] * IG[2] + IG[3] * IG[3]); Is = Math.atan2(-IG[1] / v3, IG[0] / Ik)
          } var Iv = IN[II++]; var Iu = IN[II++]; var Ix = IN[II++]; var Iw = IN[II++]; var v1 = IN[II++] + Is; var IK = IN[II++] + v1 + Is; II++; var IF = IN[II++]; var Ir = Iv + DB(v1) * Ix; var e = Iu + Fu(v1) * Iw; var Iq = Iv + DB(IK) * Ix; var IR = Iu + Fu(IK) * Iw; var IQ = IF ? " wa " : " at "; if (Math.abs(Ir - Iq) < 0.0001) { if (Math.abs(IK - v1) > 0.01) { if (IF) { Ir += 270 / Hp } } else { if (Math.abs(e - Iu) < 0.0001) { if ((IF && Ir < Iv) || (!IF && Ir > Iv)) { IR -= 270 / Hp } else { IR += 270 / Hp } } else { if ((IF && e < Iu) || (!IF && e > Iu)) { Iq += 270 / Hp } else { Iq -= 270 / Hp } } } } Iy.push(IQ, FI(((Iv - Ix) * Ik + IC) * Hp - bQ), mi, FI(((Iu - Iw) * v3 + IA) * Hp - bQ), mi, FI(((Iv + Ix) * Ik + IC) * Hp - bQ), mi, FI(((Iu + Iw) * v3 + IA) * Hp - bQ), mi, FI((Ir * Ik + IC) * Hp - bQ), mi, FI((e * v3 + IA) * Hp - bQ), mi, FI((Iq * Ik + IC) * Hp - bQ), mi, FI((IR * v3 + IA) * Hp - bQ)); IB = Iq; It = IR; break; case FP.R: var IM = DI[0]; var IL = DI[1]; IM[0] = IN[II++]; IM[1] = IN[II++]; IL[0] = IM[0] + IN[II++]; IL[1] = IM[1] + IN[II++]; if (IG) { aY(IM, IM, IG); aY(IL, IL, IG) } IM[0] = FI(IM[0] * Hp - bQ); IL[0] = FI(IL[0] * Hp - bQ); IM[1] = FI(IM[1] * Hp - bQ); IL[1] = FI(IL[1] * Hp - bQ); Iy.push(" m ", IM[0], mi, IM[1], " l ", IL[0], mi, IM[1], " l ", IL[0], mi, IL[1], " l ", IM[0], mi, IL[1]); break; case FP.Z: Iy.push(" x ")
        }if (Z > 0) { Iy.push(Iz); for (var IH = 0; IH < Z; IH++) { var IE = DI[IH]; IG && aY(IE, IE, IG); Iy.push(FI(IE[0] * Hp - bQ), mi, FI(IE[1] * Hp - bQ), IH < Z - 1 ? mi : "") } }
      } return Iy.join("")
    }; mm.prototype.brushVML = function (v) { var i = this.style; var k = this._vmlEl; if (!k) { k = Bk("shape"); ta(k); this._vmlEl = k } sM(k, "fill", i, this); sM(k, "stroke", i, this); var Z = this.transform; var e = Z != null; var v3 = k.getElementsByTagName("stroke")[0]; if (v3) { var v1 = i.lineWidth; if (e && !i.strokeNoScale) { var v2 = Z[0] * Z[3] - Z[1] * Z[2]; v1 *= DG(B1(v2)) } v3.weight = v1 + "px" } var Ij = this.path || (this.path = new j5()); if (this.__dirtyPath) { Ij.beginPath(); this.buildPath(Ij, this.shape); Ij.toStatic(); this.__dirtyPath = false } k.path = oB(Ij, this.transform); k.style.zIndex = d0(this.zlevel, this.z, this.z2); lc(v, k); if (i.text != null) { this.drawRectText(v, this.getBoundingRect()) } else { this.removeRectText(v) } }; mm.prototype.onRemove = function (e) { be(e, this._vmlEl); this.removeRectText(e) }; mm.prototype.onAdd = function (e) { lc(e, this._vmlEl); this.appendRectText(e) }; var F6 = function (e) { return (typeof e === "object") && e.tagName && e.tagName.toUpperCase() === "IMG" }; Ft.prototype.brushVML = function (In) { var IE = this.style; var k = IE.image; var Iv; var IA; if (F6(k)) { var Is = k.src; if (Is === this._imageSrc) { Iv = this._imageWidth; IA = this._imageHeight } else { var Iu = k.runtimeStyle; var Iy = Iu.width; var Im = Iu.height; Iu.width = "auto"; Iu.height = "auto"; Iv = k.width; IA = k.height; Iu.width = Iy; Iu.height = Im; this._imageSrc = Is; this._imageWidth = Iv; this._imageHeight = IA } k = Is } else { if (k === this._imageSrc) { Iv = this._imageWidth; IA = this._imageHeight } } if (!k) { return } var IC = IE.x || 0; var IB = IE.y || 0; var v = IE.width; var Ij = IE.height; var v3 = IE.sWidth; var Io = IE.sHeight; var v2 = IE.sx || 0; var v1 = IE.sy || 0; var ID = v3 && Io; var Ik = this._vmlEl; if (!Ik) { Ik = sB.createElement("div"); ta(Ik); this._vmlEl = Ik } var IJ = Ik.style; var Iw = false; var IG; var Iz = 1; var Ix = 1; if (this.transform) { IG = this.transform; Iz = DG(IG[0] * IG[0] + IG[1] * IG[1]); Ix = DG(IG[2] * IG[2] + IG[3] * IG[3]); Iw = IG[1] || IG[2] } if (Iw) { var IN = [IC, IB]; var IM = [IC + v, IB]; var IL = [IC, IB + Ij]; var IK = [IC + v, IB + Ij]; aY(IN, IN, IG); aY(IM, IM, IG); aY(IL, IL, IG); aY(IK, IK, IG); var Ir = AD(IN[0], IM[0], IL[0], IK[0]); var Iq = AD(IN[1], IM[1], IL[1], IK[1]); var Ip = []; Ip.push("M11=", IG[0] / Iz, mi, "M12=", IG[2] / Ix, mi, "M21=", IG[1] / Iz, mi, "M22=", IG[3] / Ix, mi, "Dx=", FI(IC * Iz + IG[4]), mi, "Dy=", FI(IB * Ix + IG[5])); IJ.padding = "0 " + FI(Ir) + "px " + FI(Iq) + "px 0"; IJ.filter = bT + ".Matrix(" + Ip.join("") + ", SizingMethod=clip)" } else { if (IG) { IC = IC * Iz + IG[4]; IB = IB * Ix + IG[5] } IJ.filter = ""; IJ.left = FI(IC) + "px"; IJ.top = FI(IB) + "px" } var II = this._imageEl; var IF = this._cropEl; if (!II) { II = sB.createElement("div"); this._imageEl = II } var i = II.style; if (ID) { if (!(Iv && IA)) { var e = new Image(); var Z = this; e.onload = function () { e.onload = null; Iv = e.width; IA = e.height; i.width = FI(Iz * Iv * v / v3) + "px"; i.height = FI(Ix * IA * Ij / Io) + "px"; Z._imageWidth = Iv; Z._imageHeight = IA; Z._imageSrc = k }; e.src = k } else { i.width = FI(Iz * Iv * v / v3) + "px"; i.height = FI(Ix * IA * Ij / Io) + "px" } if (!IF) { IF = sB.createElement("div"); IF.style.overflow = "hidden"; this._cropEl = IF } var It = IF.style; It.width = FI((v + v2 * v / v3) * Iz); It.height = FI((Ij + v1 * Ij / Io) * Ix); It.filter = bT + ".Matrix(Dx=" + (-v2 * v / v3 * Iz) + ",Dy=" + (-v1 * Ij / Io * Ix) + ")"; if (!IF.parentNode) { Ik.appendChild(IF) } if (II.parentNode != IF) { IF.appendChild(II) } } else { i.width = FI(Iz * v) + "px"; i.height = FI(Ix * Ij) + "px"; Ik.appendChild(II); if (IF && IF.parentNode) { Ik.removeChild(IF); this._cropEl = null } } var Il = ""; var IH = IE.opacity; if (IH < 1) { Il += ".Alpha(opacity=" + FI(IH * 100) + ") " } Il += bT + ".AlphaImageLoader(src=" + k + ", SizingMethod=scale)"; i.filter = Il; Ik.style.zIndex = d0(this.zlevel, this.z, this.z2); lc(In, Ik); if (IE.text != null) { this.drawRectText(In, this.getBoundingRect()) } }; Ft.prototype.onRemove = function (e) { be(e, this._vmlEl); this._vmlEl = null; this._cropEl = null; this._imageEl = null; this.removeRectText(e) }; Ft.prototype.onAdd = function (e) { lc(e, this._vmlEl); this.appendRectText(e) }; var ph = "normal"; var iI = {}; var d = 0; var ud = 100; var cv = document.createElement("div"); var dL = function (Z) {
      var v = iI[Z]; if (!v) {
        if (d > ud) { d = 0; iI = {} } var k = cv.style; var i; try {
          k.font = Z;
          i = k.fontFamily.split(",")[0]
        } catch (m) { } v = { style: k.fontStyle || ph, variant: k.fontVariant || ph, weight: k.fontWeight || ph, size: parseFloat(k.fontSize || 12) | 0, family: i || "Microsoft YaHei" }; iI[Z] = v; d++
      } return v
    }; var BW; gY("measureText", function (m, i) { var k = sB; if (!BW) { BW = k.createElement("div"); BW.style.cssText = "position:absolute;top:-20000px;left:0;" + "padding:0;margin:0;border:none;white-space:pre;"; sB.body.appendChild(BW) } try { BW.style.font = i } catch (e) { } BW.innerHTML = ""; BW.appendChild(k.createTextNode(m)); return { width: BW.offsetWidth } }); var eq = new CH(); var As = function (IC, v1, Z, v2) { var IB = this.style; this.__dirty && pg(IB, true); var Is = IB.text; Is != null && (Is += ""); if (!Is) { return } if (IB.rich) { var Im = sq(Is, IB); Is = []; for (var IA = 0; IA < Im.lines.length; IA++) { var It = Im.lines[IA].tokens; var Ip = []; for (var Iy = 0; Iy < It.length; Iy++) { Ip.push(It[Iy].text) } Is.push(Ip.join("")) } Is = Is.join("\n") } var Io; var In; var Ix = IB.textAlign; var v = IB.textVerticalAlign; var v3 = dL(IB.font); var Iu = v3.style + " " + v3.variant + " " + v3.weight + " " + v3.size + 'px "' + v3.family + '"'; Z = Z || Gr(Is, Iu, Ix, v); var Iw = this.transform; if (Iw && !v2) { eq.copy(v1); eq.applyTransform(Iw); v1 = eq } if (!v2) { var Ik = IB.textPosition; var Ir = IB.textDistance; if (Ik instanceof Array) { Io = v1.x + zH(Ik[0], v1.width); In = v1.y + zH(Ik[1], v1.height); Ix = Ix || "left" } else { var IF = FW(Ik, v1, Ir); Io = IF.x; In = IF.y; Ix = Ix || IF.textAlign; v = v || IF.textVerticalAlign } } else { Io = v1.x; In = v1.y } Io = uz(Io, Z.width, Ix); In = uv(In, Z.height, v); In += Z.height / 2; var IE = Bk; var Iq = this._textVmlEl; var Iv; var k; var Ij; if (!Iq) { Iq = IE("line"); Iv = IE("path"); k = IE("textpath"); Ij = IE("skew"); k.style["v-text-align"] = "left"; ta(Iq); Iv.textpathok = true; k.on = true; Iq.from = "0 0"; Iq.to = "1000 0.05"; lc(Iq, Ij); lc(Iq, Iv); lc(Iq, k); this._textVmlEl = Iq } else { Ij = Iq.firstChild; Iv = Ij.nextSibling; k = Iv.nextSibling } var Iz = [Io, In]; var Il = Iq.style; if (Iw && v2) { aY(Iz, Iz, Iw); Ij.on = true; Ij.matrix = Iw[0].toFixed(3) + mi + Iw[2].toFixed(3) + mi + Iw[1].toFixed(3) + mi + Iw[3].toFixed(3) + ",0,0"; Ij.offset = (FI(Iz[0]) || 0) + "," + (FI(Iz[1]) || 0); Ij.origin = "0 0"; Il.left = "0px"; Il.top = "0px" } else { Ij.on = false; Il.left = FI(Io) + "px"; Il.top = FI(In) + "px" } k.string = B0(Is); try { k.style.font = Iu } catch (ID) { } sM(Iq, "fill", { fill: IB.textFill, opacity: IB.opacity }, this); sM(Iq, "stroke", { stroke: IB.textStroke, opacity: IB.opacity, lineDash: IB.lineDash }, this); Iq.style.zIndex = d0(this.zlevel, this.z, this.z2); lc(IC, Iq) }; var tK = function (e) { be(e, this._textVmlEl); this._textVmlEl = null }; var em = function (e) { lc(e, this._textVmlEl) }; var id = [y7, Ie, Ft, mm, iR]; for (var Aa = 0; Aa < id.length; Aa++) { var b7 = id[Aa].prototype; b7.drawRectText = As; b7.removeRectText = tK; b7.appendRectText = em } iR.prototype.brushVML = function (e) { var i = this.style; if (i.text != null) { this.drawRectText(e, { x: i.x || 0, y: i.y || 0, width: 0, height: 0 }, this.getBoundingRect(), true) } else { this.removeRectText(e) } }; iR.prototype.onRemove = function (e) { this.removeRectText(e) }; iR.prototype.onAdd = function (e) { this.appendRectText(e) }
  } function fj(e) { return parseInt(e, 10) } function ak(i, Z) { xO(); this.root = i; this.storage = Z; var e = document.createElement("div"); var m = document.createElement("div"); e.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;"; m.style.cssText = "position:absolute;left:0;top:0;"; i.appendChild(e); this._vmlRoot = m; this._vmlViewport = e; this.resize(); var k = Z.delFromStorage; var v = Z.addToStorage; Z.delFromStorage = function (v1) { k.call(Z, v1); if (v1) { v1.onRemove && v1.onRemove(m) } }; Z.addToStorage = function (v1) { v1.onAdd && v1.onAdd(m); v.call(Z, v1) }; this._firstPaint = true } ak.prototype = { constructor: ak, getType: function () { return "vml" }, getViewportRoot: function () { return this._vmlViewport }, getViewportRootOffset: function () { var e = this.getViewportRoot(); if (e) { return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 } } }, refresh: function () { var e = this.storage.getDisplayList(true, true); this._paintList(e) }, _paintList: function (v) { var k = this._vmlRoot; for (var e = 0; e < v.length; e++) { var m = v[e]; if (m.invisible || m.ignore) { if (!m.__alreadyNotVisible) { m.onRemove(k) } m.__alreadyNotVisible = true } else { if (m.__alreadyNotVisible) { m.onAdd(k) } m.__alreadyNotVisible = false; if (m.__dirty) { m.beforeBrush && m.beforeBrush(); (m.brushVML || m.brush).call(m, k); m.afterBrush && m.afterBrush() } } m.__dirty = false } if (this._firstPaint) { this._vmlViewport.appendChild(k); this._firstPaint = false } }, resize: function (k, e) { var k = k == null ? this._getWidth() : k; var e = e == null ? this._getHeight() : e; if (this._width != k || this._height != e) { this._width = k; this._height = e; var i = this._vmlViewport.style; i.width = k + "px"; i.height = e + "px" } }, dispose: function () { this.root.innerHTML = ""; this._vmlRoot = this._vmlViewport = this.storage = null }, getWidth: function () { return this._width }, getHeight: function () { return this._height }, clear: function () { if (this._vmlViewport) { this.root.removeChild(this._vmlViewport) } }, _getWidth: function () { var e = this.root; var i = e.currentStyle; return ((e.clientWidth || fj(i.width)) - fj(i.paddingLeft) - fj(i.paddingRight)) | 0 }, _getHeight: function () { var e = this.root; var i = e.currentStyle; return ((e.clientHeight || fj(i.height)) - fj(i.paddingTop) - fj(i.paddingBottom)) | 0 } }; function gi(e) {
    return function () {
      Gu('In IE8.0 VML mode painter not support method "' + e + '"')
    }
  } o9(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function (e) { ak.prototype[e] = gi(e) }); w3("vml", ak); var ba = "http://www.w3.org/2000/svg"; function F2(e) { return document.createElementNS(ba, e) } var FO = j5.CMD; var fq = Array.prototype.join; var B2 = "none"; var rF = Math.round; var GU = Math.sin; var z9 = Math.cos; var yz = Math.PI; var GT = Math.PI * 2; var ma = 180 / yz; var lk = 0.0001; function zd(e) { return rF(e * 10000) / 10000 } function hd(e) { return e < lk && e > -lk } function i6(e, k) { var i = k ? e.textFill : e.fill; return i != null && i !== B2 } function ep(e, k) { var i = k ? e.textStroke : e.stroke; return i != null && i !== B2 } function AV(i, e) { if (e) { rs(i, "transform", "matrix(" + fq.call(e, ",") + ")") } } function rs(i, e, k) { if (!k || k.type !== "linear" && k.type !== "radial") { if (typeof k === "string" && k.indexOf("NaN") > -1) { console.log(k) } i.setAttribute(e, k) } } function jc(i, e, k) { i.setAttributeNS("http://www.w3.org/1999/xlink", e, k) } function CR(Z, e, m, i) { if (i6(e, m)) { var v1 = m ? e.textFill : e.fill; v1 = v1 === "transparent" ? B2 : v1; if (Z.getAttribute("clip-path") !== "none" && v1 === B2) { v1 = "rgba(0, 0, 0, 0.002)" } rs(Z, "fill", v1); rs(Z, "fill-opacity", e.fillOpacity != null ? e.fillOpacity * e.opacity : e.opacity) } else { rs(Z, "fill", B2) } if (ep(e, m)) { var v2 = m ? e.textStroke : e.stroke; v2 = v2 === "transparent" ? B2 : v2; rs(Z, "stroke", v2); var v = m ? e.textStrokeWidth : e.lineWidth; var v3 = !m && e.strokeNoScale ? i.getLineScale() : 1; rs(Z, "stroke-width", v / v3); rs(Z, "paint-order", m ? "stroke" : "fill"); rs(Z, "stroke-opacity", e.strokeOpacity != null ? e.strokeOpacity : e.opacity); var k = e.lineDash; if (k) { rs(Z, "stroke-dasharray", e.lineDash.join(",")); rs(Z, "stroke-dashoffset", rF(e.lineDashOffset || 0)) } else { rs(Z, "stroke-dasharray", "") } e.lineCap && rs(Z, "stroke-linecap", e.lineCap); e.lineJoin && rs(Z, "stroke-linejoin", e.lineJoin); e.miterLimit && rs(Z, "stroke-miterlimit", e.miterLimit) } else { rs(Z, "stroke", B2) } } function Ga(Io) { var Iq = []; var IA = Io.data; var Ij = Io.len(); for (var Iu = 0; Iu < Ij;) { var It = IA[Iu++]; var v1 = ""; var k = 0; switch (It) { case FO.M: v1 = "M"; k = 2; break; case FO.L: v1 = "L"; k = 2; break; case FO.Q: v1 = "Q"; k = 4; break; case FO.C: v1 = "C"; k = 6; break; case FO.A: var v = IA[Iu++]; var m = IA[Iu++]; var v3 = IA[Iu++]; var v2 = IA[Iu++]; var Ik = IA[Iu++]; var Iy = IA[Iu++]; var Iz = IA[Iu++]; var Iw = IA[Iu++]; var Ip = Math.abs(Iy); var Ir = hd(Ip - GT) && !hd(Ip); var e = false; if (Ip >= GT) { e = true } else { if (hd(Ip)) { e = false } else { e = (Iy > -yz && Iy < 0 || Iy > yz) === !!Iw } } var Ix = zd(v + v3 * z9(Ik)); var Z = zd(m + v2 * GU(Ik)); if (Ir) { if (Iw) { Iy = GT - 0.0001 } else { Iy = -GT + 0.0001 } e = true; if (Iu === 9) { Iq.push("M", Ix, Z) } } var Im = zd(v + v3 * z9(Ik + Iy)); var Il = zd(m + v2 * GU(Ik + Iy)); Iq.push("A", zd(v3), zd(v2), rF(Iz * ma), +e, +Iw, Im, Il); break; case FO.Z: v1 = "Z"; break; case FO.R: var Im = zd(IA[Iu++]); var Il = zd(IA[Iu++]); var In = zd(IA[Iu++]); var Iv = zd(IA[Iu++]); Iq.push("M", Im, Il, "L", Im + In, Il, "L", Im + In, Il + Iv, "L", Im, Il + Iv, "L", Im, Il); break }v1 && Iq.push(v1); for (var Is = 0; Is < k; Is++) { Iq.push(zd(IA[Iu++])) } } return Iq.join(" ") } var rX = {}; rX.brush = function (k) { var i = k.style; var v = k.__svgEl; if (!v) { v = F2("path"); k.__svgEl = v } if (!k.path) { k.createPathProxy() } var m = k.path; if (k.__dirtyPath) { m.beginPath(); k.buildPath(m, k.shape); k.__dirtyPath = false; var e = Ga(m); if (e.indexOf("NaN") < 0) { rs(v, "d", e) } } CR(v, i, false, k); AV(v, k.transform); if (i.text != null) { wi(k, k.getBoundingRect()) } }; var i1 = {}; i1.brush = function (m) { var k = m.style; var v = k.image; if (v instanceof HTMLImageElement) { var e = v.src; v = e } if (!v) { return } var v2 = k.x || 0; var v1 = k.y || 0; var i = k.width; var Z = k.height; var v3 = m.__svgEl; if (!v3) { v3 = F2("image"); m.__svgEl = v3 } if (v !== m.__imageSrc) { jc(v3, "href", v); m.__imageSrc = v } rs(v3, "width", i); rs(v3, "height", Z); rs(v3, "x", v2); rs(v3, "y", v1); AV(v3, m.transform); if (k.text != null) { wi(m, m.getBoundingRect()) } }; var om = {}; var eo = new CH(); var wi = function (v, m, k) {
    var IA = v.style; v.__dirty && pg(IA, true); var Ir = IA.text; if (Ir == null) { return } else { Ir += "" } var v2 = v.__textSvgEl; if (!v2) { v2 = F2("text"); v.__textSvgEl = v2 } var Io; var In; var Ij = IA.textPosition; var v3 = IA.textDistance; var Iv = IA.textAlign || "left"; if (typeof IA.fontSize === "number") { IA.fontSize += "px" } var It = IA.font || [IA.fontStyle || "", IA.fontWeight || "", IA.fontSize || "", IA.fontFamily || ""].join(" ") || EY; var e = hn(IA.textVerticalAlign); k = Gr(Ir, It, Iv, e); var v1 = k.lineHeight; if (Ij instanceof Array) { Io = m.x + Ij[0]; In = m.y + Ij[1] } else { var Z = FW(Ij, m, v3); Io = Z.x; In = Z.y; e = hn(Z.textVerticalAlign); Iv = Z.textAlign } rs(v2, "alignment-baseline", e); if (It) { v2.style.font = It } var Iy = IA.textPadding; rs(v2, "x", Io); rs(v2, "y", In); CR(v2, IA, true, v); if (v instanceof iR || v.style.transformText) { AV(v2, v.transform) } else { if (v.transform) { eo.copy(m); eo.applyTransform(v.transform); m = eo } else { var Il = v.transformCoordToGlobal(m.x, m.y); m.x = Il[0]; m.y = Il[1]; v.transform = lN(CB()) } var IC = IA.textOrigin; if (IC === "center") { Io = k.width / 2 + Io; In = k.height / 2 + In } else { if (IC) { Io = IC[0] + Io; In = IC[1] + In } } var IB = -IA.textRotation || 0; var Iq = CB(); ki(Iq, Iq, IB); var Il = [v.transform[4], v.transform[5]]; vm(Iq, Iq, Il); AV(v2, Iq) } var Is = Ir.split("\n"); var Iu = Is.length; var Ix = Iv; if (Ix === "left") { Ix = "start"; Iy && (Io += Iy[3]) } else {
      if (Ix === "right") { Ix = "end"; Iy && (Io -= Iy[1]) } else {
        if (Ix === "center") {
          Ix = "middle"; Iy && (Io += (Iy[3] - Iy[1]) / 2)
        }
      }
    } var Ip = 0; if (e === "after-edge") { Ip = -k.height + v1; Iy && (Ip -= Iy[2]) } else { if (e === "middle") { Ip = (-k.height + v1) / 2; Iy && (In += (Iy[0] - Iy[2]) / 2) } else { Iy && (Ip += Iy[0]) } } if (v.__text !== Ir || v.__textFont !== It) { var Ik = v.__tspanList || []; v.__tspanList = Ik; for (var Iw = 0; Iw < Iu; Iw++) { var Im = Ik[Iw]; if (!Im) { Im = Ik[Iw] = F2("tspan"); v2.appendChild(Im); rs(Im, "alignment-baseline", e); rs(Im, "text-anchor", Ix) } else { Im.innerHTML = "" } rs(Im, "x", Io); rs(Im, "y", In + Iw * v1 + Ip); Im.appendChild(document.createTextNode(Is[Iw])) } for (; Iw < Ik.length; Iw++) { v2.removeChild(Ik[Iw]) } Ik.length = Iu; v.__text = Ir; v.__textFont = It } else { if (v.__tspanList.length) { var Iz = v.__tspanList.length; for (var Iw = 0; Iw < Iz; ++Iw) { var Im = v.__tspanList[Iw]; if (Im) { rs(Im, "x", Io); rs(Im, "y", In + Iw * v1 + Ip) } } } }
  }; function hn(e) { if (e === "middle") { return "middle" } else { if (e === "bottom") { return "after-edge" } else { return "hanging" } } } om.drawRectText = wi; om.brush = function (i) { var e = i.style; if (e.text != null) { e.textPosition = [0, 0]; wi(i, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, i.getBoundingRect()) } }; function od() { } od.prototype = { diff: function (k, v3, m) { if (!m) { m = function (Ip, i) { return Ip === i } } this.equals = m; var Io = this; k = k.slice(); v3 = v3.slice(); var Ij = v3.length; var v = k.length; var e = 1; var Im = Ij + v; var Il = [{ newPos: -1, components: [] }]; var Z = this.extractCommon(Il[0], v3, k, 0); if (Il[0].newPos + 1 >= Ij && Z + 1 >= v) { var In = []; for (var v2 = 0; v2 < v3.length; v2++) { In.push(v2) } return [{ indices: In, count: v3.length }] } function v1() { for (var Iq = -1 * e; Iq <= e; Iq += 2) { var Iu; var Ip = Il[Iq - 1]; var i = Il[Iq + 1]; var Ir = (i ? i.newPos : 0) - Iq; if (Ip) { Il[Iq - 1] = undefined } var Is = Ip && Ip.newPos + 1 < Ij; var It = i && 0 <= Ir && Ir < v; if (!Is && !It) { Il[Iq] = undefined; continue } if (!Is || (It && Ip.newPos < i.newPos)) { Iu = cW(i); Io.pushComponent(Iu.components, undefined, true) } else { Iu = Ip; Iu.newPos++; Io.pushComponent(Iu.components, true, undefined) } Ir = Io.extractCommon(Iu, v3, k, Iq); if (Iu.newPos + 1 >= Ij && Ir + 1 >= v) { return bx(Io, Iu.components, v3, k) } else { Il[Iq] = Iu } } e++ } while (e <= Im) { var Ik = v1(); if (Ik) { return Ik } } }, pushComponent: function (k, e, m) { var i = k[k.length - 1]; if (i && i.added === e && i.removed === m) { k[k.length - 1] = { count: i.count + 1, added: e, removed: m } } else { k.push({ count: 1, added: e, removed: m }) } }, extractCommon: function (v3, m, e, v2) { var v = m.length; var i = e.length; var v1 = v3.newPos; var k = v1 - v2; var Z = 0; while (v1 + 1 < v && k + 1 < i && this.equals(m[v1 + 1], e[k + 1])) { v1++; k++; Z++ } if (Z) { v3.components.push({ count: Z }) } v3.newPos = v1; return k }, tokenize: function (e) { return e.slice() }, join: function (e) { return e.slice() } }; function bx(Ik, v2, Z, e) { var v1 = 0; var k = v2.length; var v3 = 0; var m = 0; for (; v1 < k; v1++) { var Ij = v2[v1]; if (!Ij.removed) { var Il = []; for (var v = v3; v < v3 + Ij.count; v++) { Il.push(v) } Ij.indices = Il; v3 += Ij.count; if (!Ij.added) { m += Ij.count } } else { var Il = []; for (var v = m; v < m + Ij.count; v++) { Il.push(v) } Ij.indices = Il; m += Ij.count } } return v2 } function cW(e) { return { newPos: e.newPos, components: e.components.slice(0) } } var jk = new od(); var gF = function (e, i, k) { return jk.diff(e, i, k) }; var m9 = "0"; var gT = "1"; function s6(m, i, e, v, k) { this._zrId = m; this._svgRoot = i; this._tagNames = typeof e === "string" ? [e] : e; this._markLabel = v; this._domName = k || "_dom"; this.nextId = 0 } s6.prototype.createElement = F2; s6.prototype.getDefs = function (k) { var i = this._svgRoot; var e = this._svgRoot.getElementsByTagName("defs"); if (e.length === 0) { if (k) { e = i.insertBefore(this.createElement("defs"), i.firstChild); if (!e.contains) { e.contains = function (Z) { var v = e.children; if (!v) { return false } for (var m = v.length - 1; m >= 0; --m) { if (v[m] === Z) { return true } } return false } } return e } else { return null } } else { return e[0] } }; s6.prototype.update = function (k, i) { if (!k) { return } var e = this.getDefs(false); if (k[this._domName] && e.contains(k[this._domName])) { if (typeof i === "function") { i(k) } } else { var m = this.add(k); if (m) { k[this._domName] = m } } }; s6.prototype.addDom = function (i) { var e = this.getDefs(true); e.appendChild(i) }; s6.prototype.removeDom = function (i) { var e = this.getDefs(false); if (e && i[this._domName]) { e.removeChild(i[this._domName]); i[this._domName] = null } }; s6.prototype.getDoms = function () { var e = this.getDefs(false); if (!e) { return [] } var i = []; o9(this._tagNames, function (m) { var k = e.getElementsByTagName(m); i = i.concat([].slice.call(k)) }); return i }; s6.prototype.markAllUnused = function () { var i = this.getDoms(); var e = this; o9(i, function (k) { k[e._markLabel] = m9 }) }; s6.prototype.markUsed = function (e) { if (e) { e[this._markLabel] = gT } }; s6.prototype.removeUnused = function () { var e = this.getDefs(false); if (!e) { return } var k = this.getDoms(); var i = this; o9(k, function (m) { if (m[i._markLabel] !== gT) { e.removeChild(m) } }) }; s6.prototype.getSvgProxy = function (e) { if (e instanceof mm) { return rX } else { if (e instanceof Ft) { return i1 } else { if (e instanceof iR) { return om } else { return rX } } } }; s6.prototype.getTextSvgElement = function (e) { return e.__textSvgEl }; s6.prototype.getSvgElement = function (e) { return e.__svgEl }; function gO(i, e) { s6.call(this, i, e, ["linearGradient", "radialGradient"], "__gradient_in_use__") } mr(gO, s6); gO.prototype.addWithoutUpdate = function (k, e) {
    if (e && e.style) {
      var i = this; o9(["fill", "stroke"], function (v) {
        if (e.style[v] && (e.style[v].type === "linear" || e.style[v].type === "radial")) {
          var Z = e.style[v]; var m = i.getDefs(true); var v1; if (Z._dom) {
            v1 = Z._dom; if (!m.contains(Z._dom)) {
              i.addDom(v1)
            }
          } else { v1 = i.add(Z) } i.markUsed(e); var v2 = v1.getAttribute("id"); k.setAttribute(v, "url(#" + v2 + ")")
        }
      })
    }
  }; gO.prototype.add = function (e) { var i; if (e.type === "linear") { i = this.createElement("linearGradient") } else { if (e.type === "radial") { i = this.createElement("radialGradient") } else { Gu("Illegal gradient type."); return null } } e.id = e.id || this.nextId++; i.setAttribute("id", "zr" + this._zrId + "-gradient-" + e.id); this.updateDom(e, i); this.addDom(i); return i }; gO.prototype.update = function (i) { var e = this; s6.prototype.update.call(this, i, function () { var m = i.type; var k = i._dom.tagName; if (m === "linear" && k === "linearGradient" || m === "radial" && k === "radialGradient") { e.updateDom(i, i._dom) } else { e.removeDom(i); e.add(i) } }) }; gO.prototype.updateDom = function (Z, v1) { if (Z.type === "linear") { v1.setAttribute("x1", Z.x); v1.setAttribute("y1", Z.y); v1.setAttribute("x2", Z.x2); v1.setAttribute("y2", Z.y2) } else { if (Z.type === "radial") { v1.setAttribute("cx", Z.x); v1.setAttribute("cy", Z.y); v1.setAttribute("r", Z.r) } else { Gu("Illegal gradient type."); return } } if (Z.global) { v1.setAttribute("gradientUnits", "userSpaceOnUse") } else { v1.setAttribute("gradientUnits", "objectBoundingBox") } v1.innerHTML = ""; var k = Z.colorStops; for (var v = 0, e = k.length; v < e; ++v) { var m = this.createElement("stop"); m.setAttribute("offset", k[v].offset * 100 + "%"); m.setAttribute("stop-color", k[v].color); v1.appendChild(m) } Z._dom = v1 }; gO.prototype.markUsed = function (e) { if (e.style) { var i = e.style.fill; if (i && i._dom) { s6.prototype.markUsed.call(this, i._dom) } i = e.style.stroke; if (i && i._dom) { s6.prototype.markUsed.call(this, i._dom) } } }; function jK(i, e) { s6.call(this, i, e, "clipPath", "__clippath_in_use__") } mr(jK, s6); jK.prototype.update = function (e) { var k = this.getSvgElement(e); if (k) { this.updateDom(k, e.__clipPaths, false) } var i = this.getTextSvgElement(e); if (i) { this.updateDom(i, e.__clipPaths, true) } this.markUsed(e) }; jK.prototype.updateDom = function (v1, v3, Z) { if (v3 && v3.length > 0) { var v = this.getDefs(true); var Ij = v3[0]; var Ik; var e; var m = Z ? "_textDom" : "_dom"; if (Ij[m]) { e = Ij[m].getAttribute("id"); Ik = Ij[m]; if (!v.contains(Ik)) { v.appendChild(Ik) } } else { e = "zr" + this._zrId + "-clip-" + this.nextId; ++this.nextId; Ik = this.createElement("clipPath"); Ik.setAttribute("id", e); v.appendChild(Ik); Ij[m] = Ik } var k = this.getSvgProxy(Ij); if (Ij.transform && Ij.parent.invTransform && !Z) { var i = Array.prototype.slice.call(Ij.transform); l(Ij.transform, Ij.parent.invTransform, Ij.transform); k.brush(Ij); Ij.transform = i } else { k.brush(Ij) } var v2 = this.getSvgElement(Ij); Ik.innerHTML = ""; Ik.appendChild(v2.cloneNode()); v1.setAttribute("clip-path", "url(#" + e + ")"); if (v3.length > 1) { this.updateDom(Ik, v3.slice(1), Z) } } else { if (v1) { v1.setAttribute("clip-path", "none") } } }; jK.prototype.markUsed = function (e) { var i = this; if (e.__clipPaths && e.__clipPaths.length > 0) { o9(e.__clipPaths, function (k) { if (k._dom) { s6.prototype.markUsed.call(i, k._dom) } if (k._textDom) { s6.prototype.markUsed.call(i, k._textDom) } }) } }; function hi(i, e) { s6.call(this, i, e, ["filter"], "__filter_in_use__", "_shadowDom") } mr(hi, s6); hi.prototype.addWithoutUpdate = function (m, i) { if (i && cw(i.style)) { var k = i.style; var v; if (k._shadowDom) { v = k._shadowDom; var e = this.getDefs(true); if (!e.contains(k._shadowDom)) { this.addDom(v) } } else { v = this.add(i) } this.markUsed(i); var Z = v.getAttribute("id"); m.style.filter = "url(#" + Z + ")" } }; hi.prototype.add = function (e) { var k = this.createElement("filter"); var i = e.style; i._shadowDomId = i._shadowDomId || this.nextId++; k.setAttribute("id", "zr" + this._zrId + "-shadow-" + i._shadowDomId); this.updateDom(e, k); this.addDom(k); return k }; hi.prototype.update = function (m, e) { var i = e.style; if (cw(i)) { var k = this; s6.prototype.update.call(this, e, function (v) { k.updateDom(e, v._shadowDom) }) } else { this.remove(m, i) } }; hi.prototype.remove = function (i, e) { if (e._shadowDomId != null) { this.removeDom(e); i.style.filter = "" } }; hi.prototype.updateDom = function (v, m) { var Ij = m.getElementsByTagName("feDropShadow"); if (Ij.length === 0) { Ij = this.createElement("feDropShadow") } else { Ij = Ij[0] } var e = v.style; var Im = v.scale ? (v.scale[0] || 1) : 1; var Il = v.scale ? (v.scale[1] || 1) : 1; var v1, Z, i, k; if (e.shadowBlur || e.shadowOffsetX || e.shadowOffsetY) { v1 = e.shadowOffsetX || 0; Z = e.shadowOffsetY || 0; i = e.shadowBlur; k = e.shadowColor } else { if (e.textShadowBlur) { v1 = e.textShadowOffsetX || 0; Z = e.textShadowOffsetY || 0; i = e.textShadowBlur; k = e.textShadowColor } else { this.removeDom(m, e); return } } Ij.setAttribute("dx", v1 / Im); Ij.setAttribute("dy", Z / Il); Ij.setAttribute("flood-color", k); var v3 = i / 2 / Im; var v2 = i / 2 / Il; var Ik = v3 + " " + v2; Ij.setAttribute("stdDeviation", Ik); m.setAttribute("x", "-100%"); m.setAttribute("y", "-100%"); m.setAttribute("width", Math.ceil(i / 2 * 200) + "%"); m.setAttribute("height", Math.ceil(i / 2 * 200) + "%"); m.appendChild(Ij); e._shadowDom = m }; hi.prototype.markUsed = function (e) { var i = e.style; if (i && i._shadowDom) { s6.prototype.markUsed.call(this, i._shadowDom) } }; function cw(e) { return e && (e.shadowBlur || e.shadowOffsetX || e.shadowOffsetY || e.textShadowBlur || e.textShadowOffsetX || e.textShadowOffsetY) } function fh(e) { return parseInt(e, 10) } function nI(e) { if (e instanceof mm) { return rX } else { if (e instanceof Ft) { return i1 } else { if (e instanceof iR) { return om } else { return rX } } } } function Hx(e, i) {
    return i && e && i.parentNode !== e
  } function y5(i, m, e) { if (Hx(i, m) && e) { var k = e.nextSibling; k ? i.insertBefore(m, k) : i.appendChild(m) } } function qj(e, k) { if (Hx(e, k)) { var i = e.firstChild; i ? e.insertBefore(k, i) : e.appendChild(k) } } function a4(e, i) { if (i && e && i.parentNode === e) { e.removeChild(i) } } function Ff(e) { return e.__textSvgEl } function nK(e) { return e.__svgEl } var vy = function (k, Z, v, m) { this.root = k; this.storage = Z; this._opts = v = b0({}, v || {}); var i = F2("svg"); i.setAttribute("xmlns", "http://www.w3.org/2000/svg"); i.setAttribute("version", "1.1"); i.setAttribute("baseProfile", "full"); i.style.cssText = "user-select:none;position:absolute;left:0;top:0;"; this.gradientManager = new gO(m, i); this.clipPathManager = new jK(m, i); this.shadowManager = new hi(m, i); var e = document.createElement("div"); e.style.cssText = "overflow:hidden;position:relative"; this._svgRoot = i; this._viewport = e; k.appendChild(e); e.appendChild(i); this.resize(v.width, v.height); this._visibleList = [] }; vy.prototype = { constructor: vy, getType: function () { return "svg" }, getViewportRoot: function () { return this._viewport }, getViewportRootOffset: function () { var e = this.getViewportRoot(); if (e) { return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 } } }, refresh: function () { var e = this.storage.getDisplayList(true); this._paintList(e) }, setBackgroundColor: function (e) { this._viewport.style.background = e }, _paintList: function (Ij) { this.gradientManager.markAllUnused(); this.clipPathManager.markAllUnused(); this.shadowManager.markAllUnused(); var Io = this._svgRoot; var Il = this._visibleList; var e = Ij.length; var v1 = []; var v2; for (v2 = 0; v2 < e; v2++) { var v = Ij[v2]; var Z = nI(v); var Ik = nK(v) || Ff(v); if (!v.invisible) { if (v.__dirty) { Z && Z.brush(v); this.clipPathManager.update(v); if (v.style) { this.gradientManager.update(v.style.fill); this.gradientManager.update(v.style.stroke); this.shadowManager.update(Ik, v) } v.__dirty = false } v1.push(v) } } var In = gF(Il, v1); var v3; for (v2 = 0; v2 < In.length; v2++) { var Ip = In[v2]; if (Ip.removed) { for (var m = 0; m < Ip.count; m++) { var v = Il[Ip.indices[m]]; var Ik = nK(v); var Im = Ff(v); a4(Io, Ik); a4(Io, Im) } } } for (v2 = 0; v2 < In.length; v2++) { var Ip = In[v2]; if (Ip.added) { for (var m = 0; m < Ip.count; m++) { var v = v1[Ip.indices[m]]; var Ik = nK(v); var Im = Ff(v); v3 ? y5(Io, Ik, v3) : qj(Io, Ik); if (Ik) { y5(Io, Im, Ik) } else { if (v3) { y5(Io, Im, v3) } else { qj(Io, Im) } } y5(Io, Im, Ik); v3 = Im || Ik || v3; this.gradientManager.addWithoutUpdate(Ik, v); this.shadowManager.addWithoutUpdate(v3, v); this.clipPathManager.markUsed(v) } } else { if (!Ip.removed) { for (var m = 0; m < Ip.count; m++) { var v = v1[Ip.indices[m]]; v3 = Ik = Ff(v) || nK(v) || v3; this.gradientManager.markUsed(v); this.gradientManager.addWithoutUpdate(Ik, v); this.shadowManager.markUsed(v); this.shadowManager.addWithoutUpdate(Ik, v); this.clipPathManager.markUsed(v) } } } } this.gradientManager.removeUnused(); this.clipPathManager.removeUnused(); this.shadowManager.removeUnused(); this._visibleList = v1 }, _getDefs: function (k) { var i = this._svgRoot; var e = this._svgRoot.getElementsByTagName("defs"); if (e.length === 0) { if (k) { var e = i.insertBefore(F2("defs"), i.firstChild); if (!e.contains) { e.contains = function (Z) { var v = e.children; if (!v) { return false } for (var m = v.length - 1; m >= 0; --m) { if (v[m] === Z) { return true } } return false } } return e } else { return null } } else { return e[0] } }, resize: function (v, i) { var e = this._viewport; e.style.display = "none"; var Z = this._opts; v != null && (Z.width = v); i != null && (Z.height = i); v = this._getSize(0); i = this._getSize(1); e.style.display = ""; if (this._width !== v || this._height !== i) { this._width = v; this._height = i; var m = e.style; m.width = v + "px"; m.height = i + "px"; var k = this._svgRoot; k.setAttribute("width", v); k.setAttribute("height", i) } }, getWidth: function () { return this._width }, getHeight: function () { return this._height }, _getSize: function (v) { var v2 = this._opts; var m = ["width", "height"][v]; var k = ["clientWidth", "clientHeight"][v]; var Z = ["paddingLeft", "paddingTop"][v]; var e = ["paddingRight", "paddingBottom"][v]; if (v2[m] != null && v2[m] !== "auto") { return parseFloat(v2[m]) } var i = this.root; var v1 = document.defaultView.getComputedStyle(i); return ((i[k] || fh(v1[m]) || fh(i.style[m])) - (fh(v1[Z]) || 0) - (fh(v1[e]) || 0)) | 0 }, dispose: function () { this.root.innerHTML = ""; this._svgRoot = this._viewport = this.storage = null }, clear: function () { if (this._viewport) { this.root.removeChild(this._viewport) } }, pathToDataUrl: function () { this.refresh(); var e = this._svgRoot.outerHTML; return "data:image/svg+xml;charset=UTF-8," + e } }; function D1(e) { return function () { Gu('In SVG mode painter not support method "' + e + '"') } } o9(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function (e) { vy.prototype[e] = D1(e) }); w3("svg", vy); rA.version = H5; rA.dependencies = qY; rA.PRIORITY = B6; rA.init = EV; rA.connect = nM; rA.disConnect = hF; rA.disconnect = yW; rA.dispose = u3; rA.getInstanceByDom = b2; rA.getInstanceById = dT; rA.registerTheme = zx; rA.registerPreprocessor = y2; rA.registerProcessor = eb; rA.registerPostUpdate = wh; rA.registerAction = b1; rA.registerCoordinateSystem = wA; rA.getCoordinateSystemDimensions = g1; rA.registerLayout = pr; rA.registerVisual = G; rA.registerLoading = xV; rA.extendComponentModel = p2; rA.extendComponentView = qy; rA.extendSeriesModel = B3; rA.extendChartView = BL;
  rA.setCanvasCreator = eG; rA.registerMap = fE; rA.getMap = va; rA.dataTool = wB; rA.zrender = lq; rA.number = ng; rA.format = fP; rA.throttle = e1; rA.helper = B9; rA.matrix = kC; rA.vector = EC; rA.color = wE; rA.parseGeoJSON = bK; rA.parseGeoJson = ko; rA.util = k6; rA.graphic = tY; rA.List = xt; rA.Model = fv; rA.Axis = BS; rA.env = sW
})));